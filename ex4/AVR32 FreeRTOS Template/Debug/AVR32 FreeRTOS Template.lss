
AVR32 FreeRTOS Template.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         0000388c  80002020  80002020  00002420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005a00  80005a00  00005e00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005c00  80005c00  00006000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000164  80005c18  80005c18  00006018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .lalign       00000004  80005d7c  80005d7c  0000617c  2**0
                  ALLOC
  8 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  9 .ctors        00000008  00000008  80005d80  00006408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dtors        00000008  00000010  80005d88  00006410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .jcr          00000004  00000018  80005d90  00006418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .got          00000000  0000001c  80005d94  0000641c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .data         000005d8  0000001c  80005d94  0000641c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          00000430  00000610  00000610  00000000  2**2
                  ALLOC
 15 .heap         0000e5c0  00000a40  00000a40  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  000069f4  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000cd0  00000000  00000000  00006a24  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 000019b8  00000000  00000000  000076f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00025b1b  00000000  00000000  000090ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 00004780  00000000  00000000  0002ebc7  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   0000f018  00000000  00000000  00033347  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001d90  00000000  00000000  00042360  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00007e06  00000000  00000000  000440f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    000043a5  00000000  00000000  0004bef6  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 014adad4  00000000  00000000  0005029b  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00000d58  00000000  00000000  014fdd6f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

80002004 <_init>:
80002004:	eb cd 40 40 	pushm	r6,lr
80002008:	48 26       	lddpc	r6,80002010 <_init+0xc>
8000200a:	1e 26       	rsub	r6,pc
8000200c:	c0 48       	rjmp	80002014 <_init+0x10>
8000200e:	d7 03       	nop
80002010:	80 00       	ld.sh	r0,r0[0x0]
80002012:	1f ee       	ld.ub	lr,pc[0x6]
80002014:	c5 ec       	rcall	800020d0 <frame_dummy>
80002016:	e0 a0 1c 3f 	rcall	80005894 <__do_global_ctors_aux>
8000201a:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002020 <_stext>:
80002020:	30 07       	mov	r7,0
80002022:	49 5a       	lddpc	r10,80002074 <_stext+0x54>
80002024:	5b fa       	cp.w	r10,-1
80002026:	f4 0d 17 10 	movne	sp,r10
8000202a:	49 4b       	lddpc	r11,80002078 <_stext+0x58>
8000202c:	49 4c       	lddpc	r12,8000207c <_stext+0x5c>
8000202e:	18 3b       	cp.w	r11,r12
80002030:	c0 60       	breq	8000203c <_stext+0x1c>
80002032:	49 4a       	lddpc	r10,80002080 <_stext+0x60>
80002034:	b7 09       	ld.d	r8,r11++
80002036:	b9 28       	st.d	r12++,r8
80002038:	14 3c       	cp.w	r12,r10
8000203a:	cf d5       	brlt	80002034 <_stext+0x14>
8000203c:	49 2a       	lddpc	r10,80002084 <_stext+0x64>
8000203e:	49 1c       	lddpc	r12,80002080 <_stext+0x60>
80002040:	30 08       	mov	r8,0
80002042:	30 09       	mov	r9,0
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf e5       	brlt	80002044 <_stext+0x24>
8000204a:	e0 a0 11 43 	rcall	800042d0 <_init_startup>
8000204e:	fe cc c4 4e 	sub	r12,pc,-15282
80002052:	e0 a0 14 d7 	rcall	80004a00 <atexit>
80002056:	cd 7f       	rcall	80002004 <_init>
80002058:	1a 9c       	mov	r12,sp
8000205a:	30 0b       	mov	r11,0
8000205c:	e0 a0 17 ce 	rcall	80004ff8 <_init_argv>
80002060:	5b fc       	cp.w	r12,-1
80002062:	f9 bc 00 00 	moveq	r12,0
80002066:	f9 ba 00 00 	moveq	r10,0
8000206a:	14 1d       	sub	sp,r10
8000206c:	e0 a0 14 9c 	rcall	800049a4 <main>
80002070:	e0 a0 14 d0 	rcall	80004a10 <exit>
80002074:	00 01       	add	r1,r0
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	5d 80       	*unknown*
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	00 00       	add	r0,r0
80002082:	05 f8       	ld.ub	r8,r2[0x7]
80002084:	00 00       	add	r0,r0
80002086:	0a 40       	or	r0,r5

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	48 e8       	lddpc	r8,800020c0 <__do_global_dtors_aux+0x38>
8000208c:	11 89       	ld.ub	r9,r8[0x0]
8000208e:	30 08       	mov	r8,0
80002090:	f0 09 18 00 	cp.b	r9,r8
80002094:	c1 41       	brne	800020bc <__do_global_dtors_aux+0x34>
80002096:	48 c8       	lddpc	r8,800020c4 <__do_global_dtors_aux+0x3c>
80002098:	48 c6       	lddpc	r6,800020c8 <__do_global_dtors_aux+0x40>
8000209a:	10 95       	mov	r5,r8
8000209c:	10 16       	sub	r6,r8
8000209e:	48 c7       	lddpc	r7,800020cc <__do_global_dtors_aux+0x44>
800020a0:	a3 46       	asr	r6,0x2
800020a2:	20 16       	sub	r6,1
800020a4:	c0 68       	rjmp	800020b0 <__do_global_dtors_aux+0x28>
800020a6:	2f f8       	sub	r8,-1
800020a8:	8f 08       	st.w	r7[0x0],r8
800020aa:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ae:	5d 18       	icall	r8
800020b0:	6e 08       	ld.w	r8,r7[0x0]
800020b2:	0c 38       	cp.w	r8,r6
800020b4:	cf 93       	brcs	800020a6 <__do_global_dtors_aux+0x1e>
800020b6:	30 19       	mov	r9,1
800020b8:	48 28       	lddpc	r8,800020c0 <__do_global_dtors_aux+0x38>
800020ba:	b0 89       	st.b	r8[0x0],r9
800020bc:	d8 22       	popm	r4-r7,pc
800020be:	d7 03       	nop
800020c0:	00 00       	add	r0,r0
800020c2:	06 10       	sub	r0,r3
800020c4:	00 00       	add	r0,r0
800020c6:	00 10       	sub	r0,r0
800020c8:	00 00       	add	r0,r0
800020ca:	00 14       	sub	r4,r0
800020cc:	00 00       	add	r0,r0
800020ce:	06 14       	sub	r4,r3

800020d0 <frame_dummy>:
800020d0:	d4 01       	pushm	lr
800020d2:	48 5c       	lddpc	r12,800020e4 <frame_dummy+0x14>
800020d4:	78 08       	ld.w	r8,r12[0x0]
800020d6:	58 08       	cp.w	r8,0
800020d8:	c0 50       	breq	800020e2 <frame_dummy+0x12>
800020da:	48 48       	lddpc	r8,800020e8 <frame_dummy+0x18>
800020dc:	58 08       	cp.w	r8,0
800020de:	c0 20       	breq	800020e2 <frame_dummy+0x12>
800020e0:	5d 18       	icall	r8
800020e2:	d8 02       	popm	pc
800020e4:	00 00       	add	r0,r0
800020e6:	00 18       	sub	r8,r0
800020e8:	00 00       	add	r0,r0
	...

800020ec <board_init>:
#endif



void board_init (void)
{
800020ec:	d4 01       	pushm	lr
    gpio_configure_pin (LED0_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020ee:	30 3b       	mov	r11,3
800020f0:	32 3c       	mov	r12,35
800020f2:	f0 1f 00 0a 	mcall	80002118 <board_init+0x2c>
    gpio_configure_pin (LED1_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020f6:	30 3b       	mov	r11,3
800020f8:	34 9c       	mov	r12,73
800020fa:	f0 1f 00 08 	mcall	80002118 <board_init+0x2c>
    gpio_configure_pin (LED2_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020fe:	30 3b       	mov	r11,3
80002100:	32 2c       	mov	r12,34
80002102:	f0 1f 00 06 	mcall	80002118 <board_init+0x2c>
    gpio_configure_pin (LED3_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002106:	30 3b       	mov	r11,3
80002108:	32 6c       	mov	r12,38
8000210a:	f0 1f 00 04 	mcall	80002118 <board_init+0x2c>

    gpio_configure_pin (GPIO_PUSH_BUTTON_0, (GPIO_DIR_INPUT | GPIO_PULL_UP));
8000210e:	30 4b       	mov	r11,4
80002110:	32 1c       	mov	r12,33
80002112:	f0 1f 00 02 	mcall	80002118 <board_init+0x2c>
     * the platform Xplained board has configured basic clock settings,
     * GPIO pin mapping, interrupt controller options, etc.
     */
    sensor_board_init ();
#endif
}
80002116:	d8 02       	popm	pc
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	21 1c       	sub	r12,17

8000211c <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{  
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];  
8000211c:	f8 08 16 05 	lsr	r8,r12,0x5
80002120:	a9 68       	lsl	r8,0x8
80002122:	e0 28 f0 00 	sub	r8,61440
    if (flags & GPIO_PULL_DOWN)
            gpio_port->pders = 1 << (pin & 0x1F);
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
#endif    
    if (flags & GPIO_PULL_UP)
80002126:	16 99       	mov	r9,r11
80002128:	e2 19 00 04 	andl	r9,0x4,COH
8000212c:	c0 70       	breq	8000213a <gpio_configure_pin+0x1e>
            gpio_port->puers = 1 << (pin & 0x1F);
8000212e:	30 19       	mov	r9,1
80002130:	f2 0c 09 49 	lsl	r9,r9,r12
80002134:	f1 49 00 74 	st.w	r8[116],r9
80002138:	c0 68       	rjmp	80002144 <gpio_configure_pin+0x28>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
8000213a:	30 19       	mov	r9,1
8000213c:	f2 0c 09 49 	lsl	r9,r9,r12
80002140:	f1 49 00 78 	st.w	r8[120],r9
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
80002144:	16 99       	mov	r9,r11
80002146:	e2 19 00 80 	andl	r9,0x80,COH
8000214a:	c2 40       	breq	80002192 <gpio_configure_pin+0x76>
            if (flags & GPIO_BOTHEDGES)
8000214c:	16 99       	mov	r9,r11
8000214e:	e2 19 01 80 	andl	r9,0x180,COH
80002152:	c0 90       	breq	80002164 <gpio_configure_pin+0x48>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002154:	30 19       	mov	r9,1
80002156:	f2 0c 09 49 	lsl	r9,r9,r12
8000215a:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
8000215e:	f1 49 00 b8 	st.w	r8[184],r9
80002162:	c1 88       	rjmp	80002192 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_RISING)
80002164:	16 99       	mov	r9,r11
80002166:	e2 19 02 80 	andl	r9,0x280,COH
8000216a:	c0 90       	breq	8000217c <gpio_configure_pin+0x60>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
8000216c:	30 19       	mov	r9,1
8000216e:	f2 0c 09 49 	lsl	r9,r9,r12
80002172:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
80002176:	f1 49 00 b8 	st.w	r8[184],r9
8000217a:	c0 c8       	rjmp	80002192 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_FALLING)
8000217c:	16 99       	mov	r9,r11
8000217e:	e2 19 03 80 	andl	r9,0x380,COH
80002182:	c0 80       	breq	80002192 <gpio_configure_pin+0x76>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002184:	30 19       	mov	r9,1
80002186:	f2 0c 09 49 	lsl	r9,r9,r12
8000218a:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
8000218e:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
80002192:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
80002196:	c1 50       	breq	800021c0 <gpio_configure_pin+0xa4>
            if (flags & GPIO_INIT_HIGH)
80002198:	e2 1b 00 02 	andl	r11,0x2,COH
8000219c:	c0 70       	breq	800021aa <gpio_configure_pin+0x8e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
8000219e:	30 19       	mov	r9,1
800021a0:	f2 0c 09 49 	lsl	r9,r9,r12
800021a4:	f1 49 00 54 	st.w	r8[84],r9
800021a8:	c0 68       	rjmp	800021b4 <gpio_configure_pin+0x98>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
800021aa:	30 19       	mov	r9,1
800021ac:	f2 0c 09 49 	lsl	r9,r9,r12
800021b0:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
800021b4:	30 19       	mov	r9,1
800021b6:	f2 0c 09 49 	lsl	r9,r9,r12
800021ba:	f1 49 00 44 	st.w	r8[68],r9
800021be:	c0 68       	rjmp	800021ca <gpio_configure_pin+0xae>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
800021c0:	30 19       	mov	r9,1
800021c2:	f2 0c 09 49 	lsl	r9,r9,r12
800021c6:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
800021ca:	30 19       	mov	r9,1
800021cc:	f2 0c 09 4c 	lsl	r12,r9,r12
800021d0:	91 1c       	st.w	r8[0x4],r12
}
800021d2:	5e fc       	retal	r12

800021d4 <gpio_toggle_pin>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_toggle_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800021d4:	f8 08 16 05 	lsr	r8,r12,0x5
800021d8:	a9 68       	lsl	r8,0x8
800021da:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrt  = 1 << (pin & 0x1F); // Toggle the I/O line.
800021de:	30 19       	mov	r9,1
800021e0:	f2 0c 09 4c 	lsl	r12,r9,r12
800021e4:	f1 4c 00 5c 	st.w	r8[92],r12
}
800021e8:	5e fc       	retal	r12

800021ea <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800021ea:	c0 08       	rjmp	800021ea <_unhandled_interrupt>

800021ec <INTC_register_interrupt>:


void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level)
{
  // Determine the group of the IRQ.
  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800021ec:	f6 08 16 05 	lsr	r8,r11,0x5

  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
800021f0:	48 99       	lddpc	r9,80002214 <INTC_register_interrupt+0x28>
800021f2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800021f6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800021fa:	72 19       	ld.w	r9,r9[0x4]
800021fc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
  // Program the corresponding IPRX register to set the interrupt priority level
  // and the interrupt vector offset that will be fetched by the core interrupt
  // system.
  // NOTE: The _intx functions are intermediate assembly functions between the
  // core interrupt system and the user interrupt handler.
  AVR32_INTC.ipr[int_grp] = ipr_val[int_level & (AVR32_INTC_IPR_INTLEVEL_MASK >> AVR32_INTC_IPR_INTLEVEL_OFFSET)];
80002200:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002204:	48 59       	lddpc	r9,80002218 <INTC_register_interrupt+0x2c>
80002206:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
8000220a:	fe 79 08 00 	mov	r9,-63488
8000220e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
}
80002212:	5e fc       	retal	r12
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	5c 18       	scr	r8
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	5b 3c       	cp.w	r12,-13

8000221c <INTC_init_interrupts>:
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
}

void INTC_init_interrupts(void)
{
8000221c:	d4 21       	pushm	r4-r7,lr
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
8000221e:	49 18       	lddpc	r8,80002260 <INTC_init_interrupts+0x44>
80002220:	e3 b8 00 01 	mtsr	0x4,r8
80002224:	49 0e       	lddpc	lr,80002264 <INTC_init_interrupts+0x48>
80002226:	30 07       	mov	r7,0
80002228:	0e 94       	mov	r4,r7
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000222a:	49 0c       	lddpc	r12,80002268 <INTC_init_interrupts+0x4c>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
8000222c:	49 08       	lddpc	r8,8000226c <INTC_init_interrupts+0x50>
8000222e:	70 05       	ld.w	r5,r8[0x0]
80002230:	fe 76 08 00 	mov	r6,-63488
80002234:	c1 08       	rjmp	80002254 <INTC_init_interrupts+0x38>
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
80002236:	08 98       	mov	r8,r4
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
80002238:	7c 1b       	ld.w	r11,lr[0x4]

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000223a:	7c 0a       	ld.w	r10,lr[0x0]
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000223c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
80002240:	2f f8       	sub	r8,-1
80002242:	10 3a       	cp.w	r10,r8
80002244:	fe 9b ff fc 	brhi	8000223c <INTC_init_interrupts+0x20>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80002248:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
  unsigned int int_grp, int_req;

  INTC_init_evba();

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000224c:	2f f7       	sub	r7,-1
8000224e:	2f 8e       	sub	lr,-8
80002250:	59 e7       	cp.w	r7,30
80002252:	c0 50       	breq	8000225c <INTC_init_interrupts+0x40>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
80002254:	7c 08       	ld.w	r8,lr[0x0]
80002256:	58 08       	cp.w	r8,0
80002258:	ce f1       	brne	80002236 <INTC_init_interrupts+0x1a>
8000225a:	cf 7b       	rjmp	80002248 <INTC_init_interrupts+0x2c>
8000225c:	d8 22       	popm	r4-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	5a 00       	cp.w	r0,-32
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	5c 18       	scr	r8
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	21 ea       	sub	r10,30
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	5b 3c       	cp.w	r12,-13

80002270 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(unsigned int int_level)
{
  // ICR3 is mapped first, ICR0 last.
  // Code in exception.S puts int_level in R12 which is used by AVR32-GCC to
  // pass a single argument to a function.
  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002270:	fe 78 08 00 	mov	r8,-63488
80002274:	e0 69 00 83 	mov	r9,131
80002278:	f2 0c 01 0c 	sub	r12,r9,r12
8000227c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
  unsigned int int_req = AVR32_INTC.irr[int_grp];
80002280:	f2 ca ff c0 	sub	r10,r9,-64
80002284:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
  // exception.S will provide the interrupt handler with a clean interrupt stack
  // frame, with nothing more pushed onto the stack. The interrupt handler must
  // manage the `rete' instruction, what can be done thanks to pure assembly,
  // inline assembly or the `__attribute__((__interrupt__))' C function
  // attribute.
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
80002288:	58 08       	cp.w	r8,0
8000228a:	c0 21       	brne	8000228e <_get_interrupt_handler+0x1e>
8000228c:	5e fd       	retal	0
8000228e:	f0 08 12 00 	clz	r8,r8
80002292:	48 5a       	lddpc	r10,800022a4 <_get_interrupt_handler+0x34>
80002294:	f4 09 00 39 	add	r9,r10,r9<<0x3
80002298:	f0 08 11 1f 	rsub	r8,r8,31
8000229c:	72 19       	ld.w	r9,r9[0x4]
8000229e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
}
800022a2:	5e fc       	retal	r12
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	5c 18       	scr	r8

800022a8 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800022a8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800022aa:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800022ae:	99 a8       	st.w	r12[0x28],r8
}
800022b0:	5e fc       	retal	r12
800022b2:	d7 03       	nop

800022b4 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800022b4:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800022b6:	ec 5b bb 9f 	cp.w	r11,899999
800022ba:	e0 8b 00 04 	brhi	800022c2 <pm_enable_osc0_crystal+0xe>
800022be:	30 4b       	mov	r11,4
800022c0:	c1 38       	rjmp	800022e6 <pm_enable_osc0_crystal+0x32>
800022c2:	e0 68 c6 bf 	mov	r8,50879
800022c6:	ea 18 00 2d 	orh	r8,0x2d
800022ca:	10 3b       	cp.w	r11,r8
800022cc:	e0 8b 00 04 	brhi	800022d4 <pm_enable_osc0_crystal+0x20>
800022d0:	30 5b       	mov	r11,5
800022d2:	c0 a8       	rjmp	800022e6 <pm_enable_osc0_crystal+0x32>
800022d4:	e0 68 12 00 	mov	r8,4608
800022d8:	ea 18 00 7a 	orh	r8,0x7a
800022dc:	10 3b       	cp.w	r11,r8
800022de:	f9 bb 03 06 	movlo	r11,6
800022e2:	f9 bb 02 07 	movhs	r11,7
800022e6:	f0 1f 00 02 	mcall	800022ec <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800022ea:	d8 02       	popm	pc
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	22 a8       	sub	r8,42

800022f0 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800022f0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800022f2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800022f6:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800022f8:	78 08       	ld.w	r8,r12[0x0]
800022fa:	a3 a8       	sbr	r8,0x2
800022fc:	99 08       	st.w	r12[0x0],r8
}
800022fe:	5e fc       	retal	r12

80002300 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002300:	79 58       	ld.w	r8,r12[0x54]
80002302:	e2 18 00 80 	andl	r8,0x80,COH
80002306:	cf d0       	breq	80002300 <pm_wait_for_clk0_ready>
}
80002308:	5e fc       	retal	r12
8000230a:	d7 03       	nop

8000230c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000230c:	eb cd 40 80 	pushm	r7,lr
80002310:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002312:	f0 1f 00 04 	mcall	80002320 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002316:	0e 9c       	mov	r12,r7
80002318:	f0 1f 00 03 	mcall	80002324 <pm_enable_clk0+0x18>
}
8000231c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	22 f0       	sub	r0,47
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	23 00       	sub	r0,48

80002328 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002328:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000232a:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000232e:	99 08       	st.w	r12[0x0],r8
}
80002330:	5e fc       	retal	r12
80002332:	d7 03       	nop

80002334 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002334:	eb cd 40 c0 	pushm	r6-r7,lr
80002338:	18 97       	mov	r7,r12
8000233a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000233c:	f0 1f 00 06 	mcall	80002354 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002340:	0c 9b       	mov	r11,r6
80002342:	0e 9c       	mov	r12,r7
80002344:	f0 1f 00 05 	mcall	80002358 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002348:	30 1b       	mov	r11,1
8000234a:	0e 9c       	mov	r12,r7
8000234c:	f0 1f 00 04 	mcall	8000235c <pm_switch_to_osc0+0x28>
}
80002350:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	22 b4       	sub	r4,43
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	23 0c       	sub	r12,48
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	23 28       	sub	r8,50

80002360 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3C device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
80002360:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
80002362:	58 0c       	cp.w	r12,0
80002364:	c0 40       	breq	8000236c <pcl_switch_to_osc+0xc>
80002366:	fe 7c d8 f0 	mov	r12,-10000
8000236a:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
8000236c:	fe 7c 0c 00 	mov	r12,-62464
80002370:	f0 1f 00 02 	mcall	80002378 <pcl_switch_to_osc+0x18>
80002374:	d8 0a       	popm	pc,r12=0
80002376:	00 00       	add	r0,r0
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	23 34       	sub	r4,51

8000237c <udd_include_vbus_monitoring>:


bool udd_include_vbus_monitoring(void)
{
	return true;
}
8000237c:	5e ff       	retal	1

8000237e <udd_is_high_speed>:
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
#endif
}
8000237e:	5e fd       	retal	0

80002380 <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
80002380:	fe 68 00 00 	mov	r8,-131072
80002384:	70 09       	ld.w	r9,r8[0x0]
80002386:	a7 d9       	cbr	r9,0x7
80002388:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
8000238a:	70 09       	ld.w	r9,r8[0x0]
8000238c:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80002390:	e0 19 ff 80 	andl	r9,0xff80
80002394:	f9 e9 10 09 	or	r9,r12,r9
80002398:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
8000239a:	70 09       	ld.w	r9,r8[0x0]
8000239c:	a7 b9       	sbr	r9,0x7
8000239e:	91 09       	st.w	r8[0x0],r9
}
800023a0:	5e fc       	retal	r12

800023a2 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
800023a2:	fe 68 00 00 	mov	r8,-131072
800023a6:	70 0c       	ld.w	r12,r8[0x0]
}
800023a8:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023ac:	5e fc       	retal	r12

800023ae <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
800023ae:	fe 68 00 00 	mov	r8,-131072
800023b2:	70 8c       	ld.w	r12,r8[0x20]
}
800023b4:	f9 dc c0 6b 	bfextu	r12,r12,0x3,0xb
800023b8:	5e fc       	retal	r12

800023ba <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
	return udd_micro_frame_number();
800023ba:	fe 68 00 00 	mov	r8,-131072
800023be:	70 8c       	ld.w	r12,r8[0x20]
}
800023c0:	f9 dc c0 0e 	bfextu	r12,r12,0x0,0xe
800023c4:	5e fc       	retal	r12
800023c6:	d7 03       	nop

800023c8 <udd_set_setup_payload>:
}


void udd_set_setup_payload( uint8_t *payload,	uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
800023c8:	48 28       	lddpc	r8,800023d0 <udd_set_setup_payload+0x8>
800023ca:	91 2c       	st.w	r8[0x8],r12
	udd_g_ctrlreq.payload_size = payload_size;
800023cc:	b0 6b       	st.h	r8[0xc],r11
}
800023ce:	5e fc       	retal	r12
800023d0:	00 00       	add	r0,r0
800023d2:	0a 10       	sub	r0,r5

800023d4 <udd_ep_is_halted>:
}


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
800023d4:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
800023d8:	a3 68       	lsl	r8,0x2
800023da:	e0 38 fe 40 	sub	r8,130624
800023de:	70 0c       	ld.w	r12,r8[0x0]
}
800023e0:	f9 dc c2 61 	bfextu	r12,r12,0x13,0x1
800023e4:	5e fc       	retal	r12
800023e6:	d7 03       	nop

800023e8 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
800023e8:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

	if (USB_DEVICE_MAX_EP < index)
800023ec:	30 38       	mov	r8,3
800023ee:	f0 0c 18 00 	cp.b	r12,r8
800023f2:	e0 8b 00 35 	brhi	8000245c <udd_ep_set_halt+0x74>
		return false;

	ptr_job = &udd_ep_job[index - 1];
800023f6:	18 99       	mov	r9,r12
800023f8:	f8 c8 00 01 	sub	r8,r12,1
800023fc:	a5 68       	lsl	r8,0x4
800023fe:	49 9a       	lddpc	r10,80002460 <udd_ep_set_halt+0x78>
80002400:	f4 08 00 08 	add	r8,r10,r8
	if (ptr_job->busy == true) {
80002404:	70 0a       	ld.w	r10,r8[0x0]
80002406:	58 0a       	cp.w	r10,0
80002408:	c2 a5       	brlt	8000245c <udd_ep_set_halt+0x74>
		return false;	// Job on going, stall impossible
	}
	
	if (0 != udd_nb_busy_bank(index)) {
8000240a:	a3 69       	lsl	r9,0x2
8000240c:	fe 6b 01 30 	mov	r11,-130768
80002410:	f2 0b 00 0a 	add	r10,r9,r11
80002414:	74 0a       	ld.w	r10,r10[0x0]
80002416:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
8000241a:	c1 10       	breq	8000243c <udd_ep_set_halt+0x54>
		// Wait end of transfer on USB line before stall endpoint
		// Flag a stall requested
		ptr_job->stall_requested = true;
8000241c:	70 0b       	ld.w	r11,r8[0x0]
8000241e:	30 1a       	mov	r10,1
80002420:	f7 da d3 81 	bfins	r11,r10,0x1c,0x1
80002424:	91 0b       	st.w	r8[0x0],r11
		udd_enable_bank_interrupt(index);
80002426:	e0 39 fe 10 	sub	r9,130576
8000242a:	e0 68 10 00 	mov	r8,4096
8000242e:	93 08       	st.w	r9[0x0],r8
		udd_enable_endpoint_interrupt(index);
80002430:	f0 0c 09 4c 	lsl	r12,r8,r12
80002434:	fe 69 00 00 	mov	r9,-131072
80002438:	93 6c       	st.w	r9[0x18],r12
8000243a:	5e fa       	retal	r10
	} else {
		// Stall endpoint
		udd_disable_endpoint_bank_autoswitch(index);
8000243c:	fe 6a 01 00 	mov	r10,-130816
80002440:	f2 0a 00 08 	add	r8,r9,r10
80002444:	70 0a       	ld.w	r10,r8[0x0]
80002446:	a9 da       	cbr	r10,0x9
80002448:	91 0a       	st.w	r8[0x0],r10
		udd_enable_stall_handshake(index);
8000244a:	e0 39 fe 10 	sub	r9,130576
8000244e:	e8 68 00 00 	mov	r8,524288
80002452:	93 08       	st.w	r9[0x0],r8
		udd_reset_data_toggle(index);
80002454:	e4 68 00 00 	mov	r8,262144
80002458:	93 08       	st.w	r9[0x0],r8
8000245a:	5e ff       	retal	1
8000245c:	5e fd       	retal	0
8000245e:	00 00       	add	r0,r0
80002460:	00 00       	add	r0,r0
80002462:	07 28       	ld.uh	r8,r3++

80002464 <udd_ep_clear_halt>:
	return true;
}


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
80002464:	d4 01       	pushm	lr
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
80002466:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
8000246a:	30 38       	mov	r8,3
8000246c:	f0 0c 18 00 	cp.b	r12,r8
80002470:	e0 88 00 03 	brls	80002476 <udd_ep_clear_halt+0x12>
80002474:	d8 0a       	popm	pc,r12=0
		return false;
	ptr_job = &udd_ep_job[ep - 1];
80002476:	f8 c8 00 01 	sub	r8,r12,1
8000247a:	a5 68       	lsl	r8,0x4
8000247c:	49 69       	lddpc	r9,800024d4 <udd_ep_clear_halt+0x70>
8000247e:	f2 08 00 08 	add	r8,r9,r8

	if (Is_udd_endpoint_stall_requested(ep)	// Endpoint stalled
80002482:	a3 6c       	lsl	r12,0x2
80002484:	fe 6a 01 c0 	mov	r10,-130624
80002488:	f8 0a 00 09 	add	r9,r12,r10
8000248c:	72 09       	ld.w	r9,r9[0x0]
8000248e:	e6 19 00 08 	andh	r9,0x8,COH
80002492:	c0 51       	brne	8000249c <udd_ep_clear_halt+0x38>
			|| ptr_job->stall_requested) {	// Endpoint stall is requested
80002494:	70 09       	ld.w	r9,r8[0x0]
80002496:	e6 19 10 00 	andh	r9,0x1000,COH
8000249a:	c1 c0       	breq	800024d2 <udd_ep_clear_halt+0x6e>
		// Remove request to stall
		ptr_job->stall_requested = false;
8000249c:	70 09       	ld.w	r9,r8[0x0]
8000249e:	30 0a       	mov	r10,0
800024a0:	f3 da d3 81 	bfins	r9,r10,0x1c,0x1
800024a4:	91 09       	st.w	r8[0x0],r9
		// Remove stall
		udd_disable_stall_handshake(ep);
800024a6:	fe 6a 02 20 	mov	r10,-130528
800024aa:	f8 0a 00 09 	add	r9,r12,r10
800024ae:	e8 6a 00 00 	mov	r10,524288
800024b2:	93 0a       	st.w	r9[0x0],r10
		udd_enable_endpoint_bank_autoswitch(ep);	
800024b4:	e0 3c ff 00 	sub	r12,130816
800024b8:	78 09       	ld.w	r9,r12[0x0]
800024ba:	a9 b9       	sbr	r9,0x9
800024bc:	99 09       	st.w	r12[0x0],r9
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
800024be:	70 09       	ld.w	r9,r8[0x0]
800024c0:	58 09       	cp.w	r9,0
800024c2:	c0 84       	brge	800024d2 <udd_ep_clear_halt+0x6e>
			ptr_job->busy = false;
800024c4:	30 0a       	mov	r10,0
800024c6:	f3 da d3 e1 	bfins	r9,r10,0x1f,0x1
800024ca:	91 09       	st.w	r8[0x0],r9
			ptr_job->call_nohalt();
800024cc:	70 38       	ld.w	r8,r8[0xc]
800024ce:	5d 18       	icall	r8
800024d0:	da 0a       	popm	pc,r12=1
800024d2:	da 0a       	popm	pc,r12=1
800024d4:	00 00       	add	r0,r0
800024d6:	07 28       	ld.uh	r8,r3++

800024d8 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
800024d8:	30 59       	mov	r9,5
800024da:	48 58       	lddpc	r8,800024ec <udd_ctrl_stall_data+0x14>
800024dc:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
800024de:	e8 69 00 00 	mov	r9,524288
800024e2:	fe 68 01 f0 	mov	r8,-130576
800024e6:	91 09       	st.w	r8[0x0],r9
}
800024e8:	5e fc       	retal	r12
800024ea:	00 00       	add	r0,r0
800024ec:	00 00       	add	r0,r0
800024ee:	07 5c       	ld.sh	r12,--r3

800024f0 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
800024f0:	d4 01       	pushm	lr
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
800024f2:	48 48       	lddpc	r8,80002500 <udd_ctrl_endofrequest+0x10>
800024f4:	70 48       	ld.w	r8,r8[0x10]
800024f6:	58 08       	cp.w	r8,0
800024f8:	c0 20       	breq	800024fc <udd_ctrl_endofrequest+0xc>
		udd_g_ctrlreq.callback();
800024fa:	5d 18       	icall	r8
800024fc:	d8 02       	popm	pc
800024fe:	00 00       	add	r0,r0
80002500:	00 00       	add	r0,r0
80002502:	0a 10       	sub	r0,r5

80002504 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort)
{
80002504:	d4 01       	pushm	lr
80002506:	16 99       	mov	r9,r11
	if (ptr_job->busy == false)
80002508:	78 08       	ld.w	r8,r12[0x0]
8000250a:	58 08       	cp.w	r8,0
8000250c:	c0 b4       	brge	80002522 <udd_ep_finish_job+0x1e>
		return;	// No on-going job
	ptr_job->busy = false;
8000250e:	30 0a       	mov	r10,0
80002510:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80002514:	99 08       	st.w	r12[0x0],r8
	if (NULL == ptr_job->call_trans)
80002516:	78 38       	ld.w	r8,r12[0xc]
80002518:	58 08       	cp.w	r8,0
8000251a:	c0 40       	breq	80002522 <udd_ep_finish_job+0x1e>
		return;	// No callback linked to job
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
8000251c:	78 2b       	ld.w	r11,r12[0x8]
8000251e:	12 9c       	mov	r12,r9
80002520:	5d 18       	icall	r8
80002522:	d8 02       	popm	pc

80002524 <udd_ep_abort_job>:
	}
}


static void udd_ep_abort_job(udd_ep_id_t ep)
{
80002524:	d4 01       	pushm	lr
	ep &= USB_EP_ADDR_MASK;
	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
80002526:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
8000252a:	20 18       	sub	r8,1
8000252c:	a5 68       	lsl	r8,0x4
8000252e:	30 1b       	mov	r11,1
80002530:	48 3c       	lddpc	r12,8000253c <udd_ep_abort_job+0x18>
80002532:	10 0c       	add	r12,r8
80002534:	f0 1f 00 03 	mcall	80002540 <udd_ep_abort_job+0x1c>
}
80002538:	d8 02       	popm	pc
8000253a:	00 00       	add	r0,r0
8000253c:	00 00       	add	r0,r0
8000253e:	07 28       	ld.uh	r8,r3++
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	25 04       	sub	r4,80

80002544 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
80002544:	d4 01       	pushm	lr
	udd_disable_endpoint(ep & USB_EP_ADDR_MASK);
80002546:	fe 69 00 00 	mov	r9,-131072
8000254a:	72 7b       	ld.w	r11,r9[0x1c]
8000254c:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
80002550:	30 1a       	mov	r10,1
80002552:	f4 08 09 4a 	lsl	r10,r10,r8
80002556:	5c da       	com	r10
80002558:	16 6a       	and	r10,r11
8000255a:	93 7a       	st.w	r9[0x1c],r10
	udd_unallocate_memory(ep & USB_EP_ADDR_MASK);
8000255c:	a3 68       	lsl	r8,0x2
8000255e:	e0 38 ff 00 	sub	r8,130816
80002562:	70 09       	ld.w	r9,r8[0x0]
80002564:	a1 d9       	cbr	r9,0x1
80002566:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
80002568:	f0 1f 00 02 	mcall	80002570 <udd_ep_free+0x2c>
}
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	25 24       	sub	r4,82

80002574 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
80002574:	eb cd 40 fc 	pushm	r2-r7,lr
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
	ep &= USB_EP_ADDR_MASK;
80002578:	fd dc c0 04 	bfextu	lr,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
8000257c:	30 37       	mov	r7,3
8000257e:	ee 0e 18 00 	cp.b	lr,r7
80002582:	e0 8b 00 99 	brhi	800026b4 <udd_ep_run+0x140>
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80002586:	fe 67 00 00 	mov	r7,-131072
8000258a:	6e 76       	ld.w	r6,r7[0x1c]
8000258c:	1c 95       	mov	r5,lr
8000258e:	30 17       	mov	r7,1
80002590:	ee 0e 09 47 	lsl	r7,r7,lr
80002594:	0c 67       	and	r7,r6
80002596:	e0 80 00 8f 	breq	800026b4 <udd_ep_run+0x140>
			|| Is_udd_endpoint_stall_requested(ep)
8000259a:	fc 06 15 02 	lsl	r6,lr,0x2
8000259e:	fe 64 01 c0 	mov	r4,-130624
800025a2:	ec 04 00 07 	add	r7,r6,r4
800025a6:	6e 07       	ld.w	r7,r7[0x0]
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
800025a8:	e6 17 00 08 	andh	r7,0x8,COH
800025ac:	e0 81 00 84 	brne	800026b4 <udd_ep_run+0x140>
	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep)
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
800025b0:	fc c7 00 01 	sub	r7,lr,1
800025b4:	a5 67       	lsl	r7,0x4
800025b6:	4c 14       	lddpc	r4,800026b8 <udd_ep_run+0x144>
800025b8:	e8 07 00 07 	add	r7,r4,r7

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested)
800025bc:	6e 04       	ld.w	r4,r7[0x0]
800025be:	e6 14 10 00 	andh	r4,0x1000,COH
800025c2:	c7 91       	brne	800026b4 <udd_ep_run+0x140>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800025c4:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
800025c8:	d3 03       	ssrf	0x10
		return false;	// Endpoint is halted

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
800025ca:	6e 03       	ld.w	r3,r7[0x0]
800025cc:	58 03       	cp.w	r3,0
800025ce:	c0 54       	brge	800025d8 <udd_ep_run+0x64>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800025d0:	e3 b4 00 00 	mtsr	0x0,r4
#endif
	barrier();
800025d4:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
	bool b_dir_in;
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
800025d8:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false;	// Job already on going
	}
	ptr_job->busy = true;
800025dc:	6e 03       	ld.w	r3,r7[0x0]
800025de:	30 12       	mov	r2,1
800025e0:	e7 d2 d3 e1 	bfins	r3,r2,0x1f,0x1
800025e4:	8f 03       	st.w	r7[0x0],r3
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800025e6:	e3 b4 00 00 	mtsr	0x0,r4
	cpu_irq_restore(flags);
	ptr_job->buf = buf;
800025ea:	8f 1a       	st.w	r7[0x4],r10
	ptr_job->call_trans = callback;
800025ec:	8f 38       	st.w	r7[0xc],r8
	ptr_job->b_raise_dma = false;
800025ee:	6e 08       	ld.w	r8,r7[0x0]
800025f0:	30 04       	mov	r4,0
800025f2:	f1 d4 d3 a1 	bfins	r8,r4,0x1d,0x1
800025f6:	8f 08       	st.w	r7[0x0],r8

	// The USBB supports a maximum transfer size of 64KB
	if (0x10000 <= buf_size) {
800025f8:	e0 49 ff ff 	cp.w	r9,65535
800025fc:	e0 88 00 07 	brls	8000260a <udd_ep_run+0x96>
		// Transfer size = 64KB
		ptr_job->buf_size = 0x10000;
80002600:	e0 78 00 00 	mov	r8,65536
80002604:	8f 28       	st.w	r7[0x8],r8
80002606:	08 99       	mov	r9,r4
80002608:	c3 58       	rjmp	80002672 <udd_ep_run+0xfe>
		buf_size = 0;
	} else {
		ptr_job->buf_size = buf_size;
8000260a:	8f 29       	st.w	r7[0x8],r9
		if (b_dir_in) {
8000260c:	58 0c       	cp.w	r12,0
8000260e:	c3 20       	breq	80002672 <udd_ep_run+0xfe>
			if (buf_size==0) {
80002610:	58 09       	cp.w	r9,0
80002612:	c1 71       	brne	80002640 <udd_ep_run+0xcc>
				// The USB DMA can't send a empty buffer
				// thus we raise the DMA interrupt end of transfert 
				// to execute ZLP process
				ptr_job->b_raise_dma = true;
80002614:	6e 08       	ld.w	r8,r7[0x0]
80002616:	30 1c       	mov	r12,1
				ptr_job->b_send_zlp = true;
80002618:	bd b8       	sbr	r8,0x1d
8000261a:	f1 dc d3 c1 	bfins	r8,r12,0x1e,0x1
8000261e:	8f 08       	st.w	r7[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002620:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002624:	d3 03       	ssrf	0x10
				flags = cpu_irq_save();
				udd_enable_endpoint_dma_interrupt(ep);
80002626:	20 15       	sub	r5,1
80002628:	fc 19 02 00 	movh	r9,0x200
8000262c:	f2 05 09 49 	lsl	r9,r9,r5
80002630:	fe 68 00 00 	mov	r8,-131072
80002634:	91 69       	st.w	r8[0x18],r9
				udd_raise_endpoint_dma_interrupt(ep);
80002636:	91 39       	st.w	r8[0xc],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002638:	e3 ba 00 00 	mtsr	0x0,r10
				cpu_irq_restore(flags);
				return true;
8000263c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			}
			if (0 != buf_size % udd_get_endpoint_size(ep)) {
80002640:	e0 36 ff 00 	sub	r6,130816
80002644:	6c 08       	ld.w	r8,r6[0x0]
80002646:	f1 d8 c0 83 	bfextu	r8,r8,0x4,0x3
8000264a:	30 86       	mov	r6,8
8000264c:	ec 08 09 48 	lsl	r8,r6,r8
80002650:	20 18       	sub	r8,1
80002652:	12 68       	and	r8,r9
80002654:	c0 b0       	breq	8000266a <udd_ep_run+0xf6>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
80002656:	6e 08       	ld.w	r8,r7[0x0]
80002658:	30 0b       	mov	r11,0
8000265a:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
8000265e:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
80002660:	a5 6e       	lsl	lr,0x4
80002662:	e0 3e fd 00 	sub	lr,130304
80002666:	9d 1a       	st.w	lr[0x4],r10
80002668:	c1 18       	rjmp	8000268a <udd_ep_run+0x116>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
			}else{
				ptr_job->b_send_zlp = b_shortpacket;
8000266a:	6e 08       	ld.w	r8,r7[0x0]
8000266c:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
80002670:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
80002672:	a5 6e       	lsl	lr,0x4
80002674:	e0 3e fd 00 	sub	lr,130304
80002678:	9d 1a       	st.w	lr[0x4],r10
	if (b_shortpacket) {
8000267a:	58 0b       	cp.w	r11,0
8000267c:	c0 31       	brne	80002682 <udd_ep_run+0x10e>
8000267e:	30 08       	mov	r8,0
80002680:	c0 68       	rjmp	8000268c <udd_ep_run+0x118>
		if (b_dir_in) {
80002682:	58 0c       	cp.w	r12,0
80002684:	c0 31       	brne	8000268a <udd_ep_run+0x116>
80002686:	31 48       	mov	r8,20
80002688:	c0 28       	rjmp	8000268c <udd_ep_run+0x118>
8000268a:	30 88       	mov	r8,8
		} else {
			udd_dma_ctrl = AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
					| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
		}
	}
	udd_dma_ctrl |= (buf_size <<
8000268c:	e8 18 00 21 	orl	r8,0x21
			AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
			& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
	udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80002690:	f1 e9 11 09 	or	r9,r8,r9<<0x10
			AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;
	udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
80002694:	9d 29       	st.w	lr[0x8],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002696:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000269a:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_endpoint_dma_interrupt(ep);
8000269c:	20 15       	sub	r5,1
8000269e:	fc 19 02 00 	movh	r9,0x200
800026a2:	f2 05 09 45 	lsl	r5,r9,r5
800026a6:	fe 69 00 00 	mov	r9,-131072
800026aa:	93 65       	st.w	r9[0x18],r5
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026ac:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
800026b0:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
	cpu_irq_restore(flags);

	return true;
800026b4:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800026b8:	00 00       	add	r0,r0
800026ba:	07 28       	ld.uh	r8,r3++

800026bc <udd_sleep_mode>:
 * 
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
800026bc:	58 0c       	cp.w	r12,0
800026be:	c1 11       	brne	800026e0 <udd_sleep_mode+0x24>
800026c0:	49 18       	lddpc	r8,80002704 <udd_sleep_mode+0x48>
800026c2:	11 89       	ld.ub	r9,r8[0x0]
800026c4:	30 08       	mov	r8,0
800026c6:	f0 09 18 00 	cp.b	r9,r8
800026ca:	c1 a0       	breq	800026fe <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026cc:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800026d0:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
800026d2:	48 e8       	lddpc	r8,80002708 <udd_sleep_mode+0x4c>
800026d4:	11 9a       	ld.ub	r10,r8[0x1]
800026d6:	2f fa       	sub	r10,-1
800026d8:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026da:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
800026de:	c1 08       	rjmp	800026fe <udd_sleep_mode+0x42>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
800026e0:	48 98       	lddpc	r8,80002704 <udd_sleep_mode+0x48>
800026e2:	11 89       	ld.ub	r9,r8[0x0]
800026e4:	30 08       	mov	r8,0
800026e6:	f0 09 18 00 	cp.b	r9,r8
800026ea:	c0 a1       	brne	800026fe <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026ec:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800026f0:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
800026f2:	48 68       	lddpc	r8,80002708 <udd_sleep_mode+0x4c>
800026f4:	11 9a       	ld.ub	r10,r8[0x1]
800026f6:	20 1a       	sub	r10,1
800026f8:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026fa:	e3 b9 00 00 	mtsr	0x0,r9
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
800026fe:	48 28       	lddpc	r8,80002704 <udd_sleep_mode+0x48>
80002700:	b0 8c       	st.b	r8[0x0],r12
}
80002702:	5e fc       	retal	r12
80002704:	00 00       	add	r0,r0
80002706:	07 58       	ld.sh	r8,--r3
80002708:	00 00       	add	r0,r0
8000270a:	0a 28       	rsub	r8,r5

8000270c <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
8000270c:	d4 01       	pushm	lr
	otg_unfreeze_clock();
8000270e:	fe 68 00 00 	mov	r8,-131072
80002712:	f0 f9 08 00 	ld.w	r9,r8[2048]
80002716:	af c9       	cbr	r9,0xe
80002718:	f1 49 08 00 	st.w	r8[2048],r9
	// Detach device from the bus
	udd_detach_device();
8000271c:	70 09       	ld.w	r9,r8[0x0]
8000271e:	a9 a9       	sbr	r9,0x8
80002720:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
80002722:	30 0c       	mov	r12,0
80002724:	f0 1f 00 02 	mcall	8000272c <udd_detach+0x20>
}
80002728:	d8 02       	popm	pc
8000272a:	00 00       	add	r0,r0
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	26 bc       	sub	r12,107

80002730 <udd_ctrl_init>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002730:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002734:	d3 03       	ssrf	0x10
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI), 
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI 
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
80002736:	30 1a       	mov	r10,1
80002738:	fe 69 02 20 	mov	r9,-130528
8000273c:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000273e:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);
	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
80002742:	30 29       	mov	r9,2
80002744:	fe 68 01 60 	mov	r8,-130720
80002748:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
8000274a:	48 59       	lddpc	r9,8000275c <udd_ctrl_init+0x2c>
8000274c:	30 08       	mov	r8,0
8000274e:	93 48       	st.w	r9[0x10],r8
	udd_g_ctrlreq.over_under_run = NULL;
80002750:	93 58       	st.w	r9[0x14],r8
	udd_g_ctrlreq.payload_size = 0;
80002752:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
80002754:	48 39       	lddpc	r9,80002760 <udd_ctrl_init+0x30>
80002756:	93 08       	st.w	r9[0x0],r8
}
80002758:	5e fc       	retal	r12
8000275a:	00 00       	add	r0,r0
8000275c:	00 00       	add	r0,r0
8000275e:	0a 10       	sub	r0,r5
80002760:	00 00       	add	r0,r0
80002762:	07 5c       	ld.sh	r12,--r3

80002764 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
80002764:	30 39       	mov	r9,3
80002766:	48 a8       	lddpc	r8,8000278c <udd_ctrl_send_zlp_in+0x28>
80002768:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000276a:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
8000276e:	d3 03       	ssrf	0x10
	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
80002770:	fe 6a 01 60 	mov	r10,-130720
80002774:	30 19       	mov	r9,1
80002776:	95 09       	st.w	r10[0x0],r9
	udd_enable_in_send_interrupt(0);
80002778:	fe 68 01 f0 	mov	r8,-130576
8000277c:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
8000277e:	30 89       	mov	r9,8
80002780:	95 09       	st.w	r10[0x0],r9
	udd_enable_nak_out_interrupt(0);
80002782:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002784:	e3 bb 00 00 	mtsr	0x0,r11
	cpu_irq_restore(flags);
}
80002788:	5e fc       	retal	r12
8000278a:	00 00       	add	r0,r0
8000278c:	00 00       	add	r0,r0
8000278e:	07 5c       	ld.sh	r12,--r3

80002790 <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
80002790:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002794:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002798:	d3 03       	ssrf	0x10
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
8000279a:	30 1a       	mov	r10,1
8000279c:	fe 69 02 20 	mov	r9,-130528
800027a0:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027a2:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
800027a6:	4c 38       	lddpc	r8,800028b0 <udd_ctrl_in_sent+0x120>
800027a8:	70 08       	ld.w	r8,r8[0x0]
800027aa:	58 38       	cp.w	r8,3
800027ac:	c0 71       	brne	800027ba <udd_ctrl_in_sent+0x2a>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
800027ae:	f0 1f 00 42 	mcall	800028b4 <udd_ctrl_in_sent+0x124>
		// Reinitializes control endpoint management
		udd_ctrl_init();
800027b2:	f0 1f 00 42 	mcall	800028b8 <udd_ctrl_in_sent+0x128>
		return;
800027b6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
800027ba:	4c 18       	lddpc	r8,800028bc <udd_ctrl_in_sent+0x12c>
800027bc:	90 68       	ld.sh	r8,r8[0xc]
800027be:	4c 19       	lddpc	r9,800028c0 <udd_ctrl_in_sent+0x130>
800027c0:	92 07       	ld.sh	r7,r9[0x0]
800027c2:	f0 07 01 07 	sub	r7,r8,r7
800027c6:	5c 87       	casts.h	r7
	if (0 == nb_remain) {
800027c8:	c3 b1       	brne	8000283e <udd_ctrl_in_sent+0xae>
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
800027ca:	4b f9       	lddpc	r9,800028c4 <udd_ctrl_in_sent+0x134>
800027cc:	13 8a       	ld.ub	r10,r9[0x0]
800027ce:	30 09       	mov	r9,0
800027d0:	f2 0a 18 00 	cp.b	r10,r9
800027d4:	c1 21       	brne	800027f8 <udd_ctrl_in_sent+0x68>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
800027d6:	30 49       	mov	r9,4
800027d8:	4b 68       	lddpc	r8,800028b0 <udd_ctrl_in_sent+0x120>
800027da:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027dc:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800027e0:	d3 03       	ssrf	0x10
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
800027e2:	31 08       	mov	r8,16
800027e4:	fe 6a 01 60 	mov	r10,-130720
800027e8:	95 08       	st.w	r10[0x0],r8
	udd_enable_nak_in_interrupt(0);
800027ea:	fe 6a 01 f0 	mov	r10,-130576
800027ee:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027f0:	e3 b9 00 00 	mtsr	0x0,r9
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
800027f4:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
800027f8:	4b 19       	lddpc	r9,800028bc <udd_ctrl_in_sent+0x12c>
800027fa:	92 b9       	ld.uh	r9,r9[0x6]
800027fc:	5c 78       	castu.h	r8
800027fe:	4b 3a       	lddpc	r10,800028c8 <udd_ctrl_in_sent+0x138>
80002800:	94 8a       	ld.uh	r10,r10[0x0]
80002802:	14 08       	add	r8,r10
80002804:	10 39       	cp.w	r9,r8
80002806:	e0 89 00 08 	brgt	80002816 <udd_ctrl_in_sent+0x86>
								+
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
8000280a:	4a d8       	lddpc	r8,800028bc <udd_ctrl_in_sent+0x12c>
8000280c:	70 5c       	ld.w	r12,r8[0x14]
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
8000280e:	58 0c       	cp.w	r12,0
80002810:	c0 30       	breq	80002816 <udd_ctrl_in_sent+0x86>
80002812:	5d 1c       	icall	r12
80002814:	c0 51       	brne	8000281e <udd_ctrl_in_sent+0x8e>
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun or data packet complette than send zlp on IN (note don't change DataToggle)
			udd_ctrl_payload_need_in_zlp = false;
80002816:	30 09       	mov	r9,0
80002818:	4a b8       	lddpc	r8,800028c4 <udd_ctrl_in_sent+0x134>
8000281a:	b0 89       	st.b	r8[0x0],r9
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
8000281c:	c1 18       	rjmp	8000283e <udd_ctrl_in_sent+0xae>
			udd_ctrl_payload_need_in_zlp = false;
			// nb_remain==0 allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			// Update number of total data sending by previous playlaod buffer
			udd_ctrl_prev_payload_nb_trans +=
8000281e:	4a b9       	lddpc	r9,800028c8 <udd_ctrl_in_sent+0x138>
80002820:	4a 88       	lddpc	r8,800028c0 <udd_ctrl_in_sent+0x130>
80002822:	90 0b       	ld.sh	r11,r8[0x0]
80002824:	92 0a       	ld.sh	r10,r9[0x0]
80002826:	f6 0a 00 0a 	add	r10,r11,r10
8000282a:	b2 0a       	st.h	r9[0x0],r10
					udd_ctrl_payload_nb_trans;
			// Update maangement of current playoad transfer
			udd_ctrl_payload_nb_trans = 0;
8000282c:	30 09       	mov	r9,0
8000282e:	b0 09       	st.h	r8[0x0],r9
			nb_remain = udd_g_ctrlreq.payload_size;
80002830:	4a 38       	lddpc	r8,800028bc <udd_ctrl_in_sent+0x12c>
80002832:	90 67       	ld.sh	r7,r8[0xc]
			// Compute if an IN ZLP must be send after IN data
			udd_ctrl_payload_need_in_zlp =
80002834:	f1 d7 c0 06 	bfextu	r8,r7,0x0,0x6
80002838:	5f 09       	sreq	r9
8000283a:	4a 38       	lddpc	r8,800028c4 <udd_ctrl_in_sent+0x134>
8000283c:	b0 89       	st.b	r8[0x0],r9
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
8000283e:	4a 08       	lddpc	r8,800028bc <udd_ctrl_in_sent+0x12c>
80002840:	70 2a       	ld.w	r10,r8[0x8]
80002842:	4a 08       	lddpc	r8,800028c0 <udd_ctrl_in_sent+0x130>
80002844:	90 09       	ld.sh	r9,r8[0x0]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002846:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
8000284a:	d3 03       	ssrf	0x10
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write 
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
8000284c:	fe 68 01 30 	mov	r8,-130768
80002850:	70 08       	ld.w	r8,r8[0x0]
80002852:	e2 18 00 02 	andl	r8,0x2,COH
80002856:	c0 91       	brne	80002868 <udd_ctrl_in_sent+0xd8>
80002858:	34 08       	mov	r8,64
8000285a:	f0 07 19 00 	cp.h	r7,r8
8000285e:	f9 b7 0b 40 	movhi	r7,64
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
80002862:	58 07       	cp.w	r7,0
80002864:	c0 91       	brne	80002876 <udd_ctrl_in_sent+0xe6>
80002866:	c1 48       	rjmp	8000288e <udd_ctrl_in_sent+0xfe>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002868:	e3 bb 00 00 	mtsr	0x0,r11
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
8000286c:	30 49       	mov	r9,4
8000286e:	49 18       	lddpc	r8,800028b0 <udd_ctrl_in_sent+0x120>
80002870:	91 09       	st.w	r8[0x0],r9
		return;	// Exit of IN DATA phase
80002872:	e3 cd 80 80 	ldm	sp++,r7,pc
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002876:	5c 79       	castu.h	r9
80002878:	f4 09 00 09 	add	r9,r10,r9
8000287c:	fc 18 e0 00 	movh	r8,0xe000
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
80002880:	13 3a       	ld.ub	r10,r9++
80002882:	10 ca       	st.b	r8++,r10
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
80002884:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002888:	ee 0a 19 00 	cp.h	r10,r7
8000288c:	cf a3       	brcs	80002880 <udd_ctrl_in_sent+0xf0>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
8000288e:	48 d8       	lddpc	r8,800028c0 <udd_ctrl_in_sent+0x130>
80002890:	90 09       	ld.sh	r9,r8[0x0]
80002892:	f2 07 00 07 	add	r7,r9,r7
80002896:	b0 07       	st.h	r8[0x0],r7

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
80002898:	30 18       	mov	r8,1
8000289a:	fe 69 01 60 	mov	r9,-130720
8000289e:	93 08       	st.w	r9[0x0],r8
	udd_enable_in_send_interrupt(0);
800028a0:	fe 69 01 f0 	mov	r9,-130576
800028a4:	93 08       	st.w	r9[0x0],r8
800028a6:	e3 bb 00 00 	mtsr	0x0,r11
#endif
	barrier();
800028aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800028ae:	00 00       	add	r0,r0
800028b0:	00 00       	add	r0,r0
800028b2:	07 5c       	ld.sh	r12,--r3
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	24 f0       	sub	r0,79
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	27 30       	sub	r0,115
800028bc:	00 00       	add	r0,r0
800028be:	0a 10       	sub	r0,r5
800028c0:	00 00       	add	r0,r0
800028c2:	07 5a       	ld.sh	r10,--r3
800028c4:	00 00       	add	r0,r0
800028c6:	07 60       	ld.uh	r0,--r3
800028c8:	00 00       	add	r0,r0
800028ca:	07 24       	ld.uh	r4,r3++

800028cc <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
800028cc:	eb cd 40 e0 	pushm	r5-r7,lr
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
800028d0:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4

	if (ep > USB_DEVICE_MAX_EP)
800028d4:	30 39       	mov	r9,3
800028d6:	f2 08 18 00 	cp.b	r8,r9
800028da:	e0 8b 00 88 	brhi	800029ea <udd_ep_alloc+0x11e>
		return false;
	if (Is_udd_endpoint_enabled(ep))
800028de:	fe 69 00 00 	mov	r9,-131072
800028e2:	72 79       	ld.w	r9,r9[0x1c]
800028e4:	30 17       	mov	r7,1
800028e6:	ee 08 09 47 	lsl	r7,r7,r8
800028ea:	ef e9 00 09 	and	r9,r7,r9
800028ee:	c7 e1       	brne	800029ea <udd_ep_alloc+0x11e>
		return false;

	// Bank choise
	switch(bmAttributes&USB_EP_TYPE_MASK) {
800028f0:	f3 db c0 02 	bfextu	r9,r11,0x0,0x2
800028f4:	58 19       	cp.w	r9,1
800028f6:	c7 a5       	brlt	800029ea <udd_ep_alloc+0x11e>
800028f8:	58 29       	cp.w	r9,2
800028fa:	e0 8a 00 06 	brle	80002906 <udd_ep_alloc+0x3a>
800028fe:	58 39       	cp.w	r9,3
80002900:	c7 51       	brne	800029ea <udd_ep_alloc+0x11e>
80002902:	30 06       	mov	r6,0
80002904:	c0 28       	rjmp	80002908 <udd_ep_alloc+0x3c>
80002906:	30 16       	mov	r6,1
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);
		   
	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
80002908:	f0 09 15 02 	lsl	r9,r8,0x2
8000290c:	e0 39 ff 00 	sub	r9,130816
80002910:	72 0e       	ld.w	lr,r9[0x0]
80002912:	5c 7a       	castu.h	r10
80002914:	30 85       	mov	r5,8
80002916:	f4 05 0c 4a 	max	r10,r10,r5
8000291a:	e0 65 04 00 	mov	r5,1024
8000291e:	f4 05 0d 4a 	min	r10,r10,r5
80002922:	a1 7a       	lsl	r10,0x1
80002924:	20 1a       	sub	r10,1
80002926:	f4 0a 12 00 	clz	r10,r10
8000292a:	f9 dc c0 e1 	bfextu	r12,r12,0x7,0x1
8000292e:	ab 7b       	lsl	r11,0xb
80002930:	e2 1b 18 00 	andl	r11,0x1800,COH
80002934:	f7 ec 10 8c 	or	r12,r11,r12<<0x8
80002938:	f4 0b 11 1c 	rsub	r11,r10,28
8000293c:	f9 eb 10 4b 	or	r11,r12,r11<<0x4
80002940:	f7 e6 10 2b 	or	r11,r11,r6<<0x2
80002944:	e2 1b 19 7c 	andl	r11,0x197c,COH
80002948:	1c 9a       	mov	r10,lr
8000294a:	e0 1a e6 83 	andl	r10,0xe683
8000294e:	f7 ea 10 0a 	or	r10,r11,r10
80002952:	93 0a       	st.w	r9[0x0],r10
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
80002954:	5c 87       	casts.h	r7

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
80002956:	30 29       	mov	r9,2
80002958:	f2 08 18 00 	cp.b	r8,r9
8000295c:	e0 8b 00 1d 	brhi	80002996 <udd_ep_alloc+0xca>
80002960:	fe 6a 01 0c 	mov	r10,-130804
80002964:	30 39       	mov	r9,3
		if (Is_udd_endpoint_enabled(i)) {
80002966:	fe 6c 00 00 	mov	r12,-131072
8000296a:	30 16       	mov	r6,1
8000296c:	78 7e       	ld.w	lr,r12[0x1c]
8000296e:	ec 09 09 4b 	lsl	r11,r6,r9
80002972:	f7 ee 00 0e 	and	lr,r11,lr
80002976:	c0 b0       	breq	8000298c <udd_ep_alloc+0xc0>
			ep_allocated |= 1 << i;
80002978:	f7 e7 10 07 	or	r7,r11,r7
8000297c:	5c 87       	casts.h	r7
			udd_disable_endpoint(i);
8000297e:	78 7e       	ld.w	lr,r12[0x1c]
80002980:	5c db       	com	r11
80002982:	1c 6b       	and	r11,lr
80002984:	99 7b       	st.w	r12[0x1c],r11
			udd_unallocate_memory(i);
80002986:	74 0b       	ld.w	r11,r10[0x0]
80002988:	a1 db       	cbr	r11,0x1
8000298a:	95 0b       	st.w	r10[0x0],r11
8000298c:	20 19       	sub	r9,1
8000298e:	20 4a       	sub	r10,4
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
80002990:	f2 08 18 00 	cp.b	r8,r9
80002994:	ce c3       	brcs	8000296c <udd_ep_alloc+0xa0>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
80002996:	0e 9c       	mov	r12,r7
80002998:	5c 7c       	castu.h	r12
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
8000299a:	fe 6e 00 00 	mov	lr,-131072
8000299e:	30 16       	mov	r6,1
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800029a0:	30 37       	mov	r7,3
		if (ep_allocated & (1 << i)) {
800029a2:	f8 08 08 49 	asr	r9,r12,r8
800029a6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800029aa:	c1 80       	breq	800029da <udd_ep_alloc+0x10e>
			udd_allocate_memory(i);
800029ac:	f0 0b 15 02 	lsl	r11,r8,0x2
800029b0:	fe 65 01 00 	mov	r5,-130816
800029b4:	f6 05 00 09 	add	r9,r11,r5
800029b8:	72 05       	ld.w	r5,r9[0x0]
800029ba:	a1 b5       	sbr	r5,0x1
800029bc:	93 05       	st.w	r9[0x0],r5
			udd_enable_endpoint(i);
800029be:	7c 75       	ld.w	r5,lr[0x1c]
800029c0:	ec 08 09 4a 	lsl	r10,r6,r8
800029c4:	0a 4a       	or	r10,r5
800029c6:	9d 7a       	st.w	lr[0x1c],r10
			if (!Is_udd_endpoint_configured(i))
800029c8:	e0 3b fe d0 	sub	r11,130768
800029cc:	76 0a       	ld.w	r10,r11[0x0]
800029ce:	e6 1a 00 04 	andh	r10,0x4,COH
800029d2:	c0 c0       	breq	800029ea <udd_ep_alloc+0x11e>
				return false;
			udd_enable_endpoint_bank_autoswitch(i);	
800029d4:	72 0a       	ld.w	r10,r9[0x0]
800029d6:	a9 ba       	sbr	r10,0x9
800029d8:	93 0a       	st.w	r9[0x0],r10
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800029da:	2f f8       	sub	r8,-1
800029dc:	5c 58       	castu.b	r8
800029de:	ee 08 18 00 	cp.b	r8,r7
800029e2:	fe 98 ff e0 	brls	800029a2 <udd_ep_alloc+0xd6>
800029e6:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800029ea:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0

800029ee <udd_reset_ep_ctrl>:

static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;
	// Reset USB address to 0
	udd_configure_address(0);
800029ee:	fe 68 00 00 	mov	r8,-131072
800029f2:	70 09       	ld.w	r9,r8[0x0]
800029f4:	e0 19 ff 80 	andl	r9,0xff80
800029f8:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
800029fa:	70 09       	ld.w	r9,r8[0x0]
800029fc:	a7 b9       	sbr	r9,0x7
800029fe:	91 09       	st.w	r8[0x0],r9
	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80002a00:	fe 69 01 00 	mov	r9,-130816
80002a04:	72 0b       	ld.w	r11,r9[0x0]
80002a06:	30 8c       	mov	r12,8
80002a08:	34 0a       	mov	r10,64
80002a0a:	f4 0c 0c 4a 	max	r10,r10,r12
80002a0e:	e0 6c 04 00 	mov	r12,1024
80002a12:	f4 0c 0d 4a 	min	r10,r10,r12
80002a16:	a1 7a       	lsl	r10,0x1
80002a18:	20 1a       	sub	r10,1
80002a1a:	f4 0a 12 00 	clz	r10,r10
80002a1e:	f4 0a 11 1c 	rsub	r10,r10,28
80002a22:	a5 6a       	lsl	r10,0x4
80002a24:	e2 1a 19 7c 	andl	r10,0x197c,COH
80002a28:	e0 1b e6 83 	andl	r11,0xe683
80002a2c:	16 4a       	or	r10,r11
80002a2e:	93 0a       	st.w	r9[0x0],r10
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
80002a30:	72 0a       	ld.w	r10,r9[0x0]
80002a32:	a1 ba       	sbr	r10,0x1
80002a34:	93 0a       	st.w	r9[0x0],r10
	udd_enable_endpoint(0);
80002a36:	70 79       	ld.w	r9,r8[0x1c]
80002a38:	a1 a9       	sbr	r9,0x0
80002a3a:	91 79       	st.w	r8[0x1c],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002a3c:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002a40:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
80002a42:	fe 69 01 f0 	mov	r9,-130576
80002a46:	30 4b       	mov	r11,4
80002a48:	93 0b       	st.w	r9[0x0],r11
	udd_enable_out_received_interrupt(0);
80002a4a:	30 2b       	mov	r11,2
80002a4c:	93 0b       	st.w	r9[0x0],r11
	udd_enable_endpoint_interrupt(0);
80002a4e:	e0 69 10 00 	mov	r9,4096
80002a52:	91 69       	st.w	r8[0x18],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002a54:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);
}
80002a58:	5e fc       	retal	r12
80002a5a:	d7 03       	nop

80002a5c <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
80002a5c:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002a60:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002a64:	d3 03       	ssrf	0x10
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown, 
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80002a66:	30 1c       	mov	r12,1
80002a68:	f0 1f 00 15 	mcall	80002abc <udd_attach+0x60>
	otg_unfreeze_clock();
80002a6c:	fe 67 00 00 	mov	r7,-131072
80002a70:	ee f8 08 00 	ld.w	r8,r7[2048]
80002a74:	af c8       	cbr	r8,0xe
80002a76:	ef 48 08 00 	st.w	r7[2048],r8
#else
	// Check USB clock because the source can be a PLL
	while( !Is_clock_usable() );
#endif
	// Authorize attach if VBus is present
	udd_attach_device();
80002a7a:	6e 08       	ld.w	r8,r7[0x0]
80002a7c:	a9 c8       	cbr	r8,0x8
80002a7e:	8f 08       	st.w	r7[0x0],r8

	// (RESET_AND_WAKEUP)
	// After the attach and the first USB suspend, the following USB Reset time can be inferior to CPU restart clock time.
	// Thus, the USB Reset state is not detected and endpoint control is not allocated
	// In this case, a Reset is do automatically after attach.
	udc_reset();	// Reset USB Device Stack Core
80002a80:	f0 1f 00 10 	mcall	80002ac0 <udd_attach+0x64>
	udd_reset_ep_ctrl();	// Reset endpoint control
80002a84:	f0 1f 00 10 	mcall	80002ac4 <udd_attach+0x68>
	udd_ctrl_init();	// Reset endpoint control management
80002a88:	f0 1f 00 10 	mcall	80002ac8 <udd_attach+0x6c>

	// Enable USB line events
	udd_enable_reset_interrupt();
80002a8c:	30 8b       	mov	r11,8
80002a8e:	8f 6b       	st.w	r7[0x18],r11
	udd_enable_suspend_interrupt();
80002a90:	30 19       	mov	r9,1
80002a92:	8f 69       	st.w	r7[0x18],r9
	udd_enable_wake_up_interrupt();
80002a94:	31 08       	mov	r8,16
80002a96:	8f 68       	st.w	r7[0x18],r8
	udd_enable_sof_interrupt();
80002a98:	30 4a       	mov	r10,4
80002a9a:	8f 6a       	st.w	r7[0x18],r10
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interupts flag
	udd_ack_reset();
80002a9c:	8f 2b       	st.w	r7[0x8],r11
	udd_ack_sof();
80002a9e:	8f 2a       	st.w	r7[0x8],r10
	udd_ack_msof();
80002aa0:	30 2a       	mov	r10,2
80002aa2:	8f 2a       	st.w	r7[0x8],r10

	// The first suspend interrupt must be forced
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
80002aa4:	8f 29       	st.w	r7[0x8],r9
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
#endif
	udd_ack_wake_up();
80002aa6:	8f 28       	st.w	r7[0x8],r8
	otg_freeze_clock();
80002aa8:	ee f8 08 00 	ld.w	r8,r7[2048]
80002aac:	af a8       	sbr	r8,0xe
80002aae:	ef 48 08 00 	st.w	r7[2048],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002ab2:	e3 b6 00 00 	mtsr	0x0,r6
	cpu_irq_restore(flags);
}
80002ab6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002aba:	00 00       	add	r0,r0
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	26 bc       	sub	r12,107
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	39 90       	mov	r0,-103
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	29 ee       	sub	lr,-98
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	27 30       	sub	r0,115

80002acc <udd_enable>:
	return true;
}


void udd_enable(void)
{
80002acc:	eb cd 40 c0 	pushm	r6-r7,lr
	irqflags_t flags;
	sysclk_enable_usb();
80002ad0:	f0 1f 00 39 	mcall	80002bb4 <udd_enable+0xe8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002ad4:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002ad8:	d3 03       	ssrf	0x10

	flags = cpu_irq_save();

	//** Enable USB hardware
	otg_disable();
80002ada:	fe 67 00 00 	mov	r7,-131072
80002ade:	ee f8 08 00 	ld.w	r8,r7[2048]
80002ae2:	af d8       	cbr	r8,0xf
80002ae4:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_enabled();
80002ae8:	ee f8 08 00 	ld.w	r8,r7[2048]
	// Check UID pin state before enter in USB device mode
	if (!Is_otg_id_device())
		return false;
#else
	// Here, only the Device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(udd_interrupt, AVR32_USBB_IRQ, UDD_USB_INT_LEVEL);
80002aec:	30 0a       	mov	r10,0
80002aee:	e0 6b 02 20 	mov	r11,544
80002af2:	4b 2c       	lddpc	r12,80002bb8 <udd_enable+0xec>
80002af4:	f0 1f 00 32 	mcall	80002bbc <udd_enable+0xf0>
	otg_force_device_mode();
80002af8:	ee f8 08 00 	ld.w	r8,r7[2048]
80002afc:	b9 b8       	sbr	r8,0x19
80002afe:	ef 48 08 00 	st.w	r7[2048],r8
80002b02:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b06:	b9 c8       	cbr	r8,0x18
80002b08:	ef 48 08 00 	st.w	r7[2048],r8
#endif
	otg_disable_pad();
80002b0c:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b10:	ad c8       	cbr	r8,0xc
80002b12:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable_pad();
80002b16:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b1a:	ad a8       	sbr	r8,0xc
80002b1c:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable();
80002b20:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b24:	af b8       	sbr	r8,0xf
80002b26:	ef 48 08 00 	st.w	r7[2048],r8
	otg_unfreeze_clock();
80002b2a:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b2e:	af c8       	cbr	r8,0xe
80002b30:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_clock_frozen();
80002b34:	ee f8 08 00 	ld.w	r8,r7[2048]

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002b38:	4a 28       	lddpc	r8,80002bc0 <udd_enable+0xf4>
80002b3a:	70 0a       	ld.w	r10,r8[0x0]
80002b3c:	30 09       	mov	r9,0
		udd_ep_job[i].stall_requested = false;
80002b3e:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002b42:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002b46:	91 0a       	st.w	r8[0x0],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002b48:	70 4a       	ld.w	r10,r8[0x10]
		udd_ep_job[i].stall_requested = false;
80002b4a:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002b4e:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002b52:	91 4a       	st.w	r8[0x10],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002b54:	70 8a       	ld.w	r10,r8[0x20]
		udd_ep_job[i].stall_requested = false;
80002b56:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002b5a:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002b5e:	91 8a       	st.w	r8[0x20],r10

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80002b60:	6e 08       	ld.w	r8,r7[0x0]
80002b62:	ad c8       	cbr	r8,0xc
80002b64:	8f 08       	st.w	r7[0x0],r8
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
80002b66:	6e 08       	ld.w	r8,r7[0x0]
80002b68:	e8 18 0c 00 	orl	r8,0xc00
80002b6c:	8f 08       	st.w	r7[0x0],r8
#  endif
#endif
	udd_enable_vbus_interrupt();
80002b6e:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b72:	a1 b8       	sbr	r8,0x1
80002b74:	ef 48 08 00 	st.w	r7[2048],r8
	otg_freeze_clock();
80002b78:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b7c:	af a8       	sbr	r8,0xe
80002b7e:	ef 48 08 00 	st.w	r7[2048],r8
	// Always authorize asynchrone USB interrupts to exit of sleep mode
	AVR32_PM.AWEN.usb_waken = 1;
80002b82:	fe 78 0c 00 	mov	r8,-62464
80002b86:	f0 fa 01 44 	ld.w	r10,r8[324]
80002b8a:	30 1b       	mov	r11,1
80002b8c:	f5 db d0 01 	bfins	r10,r11,0x0,0x1
80002b90:	f1 4a 01 44 	st.w	r8[324],r10

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
80002b94:	48 c8       	lddpc	r8,80002bc4 <udd_enable+0xf8>
80002b96:	b0 89       	st.b	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b98:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002b9c:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002b9e:	48 b8       	lddpc	r8,80002bc8 <udd_enable+0xfc>
80002ba0:	11 ba       	ld.ub	r10,r8[0x3]
80002ba2:	2f fa       	sub	r10,-1
80002ba4:	b0 ba       	st.b	r8[0x3],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002ba6:	e3 b9 00 00 	mtsr	0x0,r9
80002baa:	e3 b6 00 00 	mtsr	0x0,r6
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
#endif

	cpu_irq_restore(flags);
}
80002bae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bb2:	00 00       	add	r0,r0
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	32 74       	mov	r4,39
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	2b cc       	sub	r12,-68
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	21 ec       	sub	r12,30
80002bc0:	00 00       	add	r0,r0
80002bc2:	07 28       	ld.uh	r8,r3++
80002bc4:	00 00       	add	r0,r0
80002bc6:	07 58       	ld.sh	r8,--r3
80002bc8:	00 00       	add	r0,r0
80002bca:	0a 28       	rsub	r8,r5

80002bcc <udd_interrupt>:
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#endif
{
80002bcc:	eb cd 40 fc 	pushm	r2-r7,lr
	if (Is_udd_sof()) {
80002bd0:	fe 68 00 00 	mov	r8,-131072
80002bd4:	70 18       	ld.w	r8,r8[0x4]
80002bd6:	e2 18 00 04 	andl	r8,0x4,COH
80002bda:	c0 f0       	breq	80002bf8 <udd_interrupt+0x2c>
		udd_ack_sof();
80002bdc:	fe 68 00 00 	mov	r8,-131072
80002be0:	30 49       	mov	r9,4
80002be2:	91 29       	st.w	r8[0x8],r9
		if (Is_udd_full_speed_mode()) {
80002be4:	f0 f8 08 04 	ld.w	r8,r8[2052]
80002be8:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
80002bec:	e0 81 02 ce 	brne	80003188 <udd_interrupt+0x5bc>
		udc_sof_notify();
80002bf0:	f0 1f 01 6f 	mcall	800031ac <udd_interrupt+0x5e0>
80002bf4:	e0 8f 02 ca 	bral	80003188 <udd_interrupt+0x5bc>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_end;
	}
	if (Is_udd_msof()) {
80002bf8:	fe 68 00 00 	mov	r8,-131072
80002bfc:	70 18       	ld.w	r8,r8[0x4]
80002bfe:	e2 18 00 02 	andl	r8,0x2,COH
80002c02:	c0 90       	breq	80002c14 <udd_interrupt+0x48>
		udd_ack_msof();
80002c04:	30 29       	mov	r9,2
80002c06:	fe 68 00 00 	mov	r8,-131072
80002c0a:	91 29       	st.w	r8[0x8],r9
		udc_sof_notify();
80002c0c:	f0 1f 01 68 	mcall	800031ac <udd_interrupt+0x5e0>
		goto udd_interrupt_end;
80002c10:	e0 8f 02 bc 	bral	80003188 <udd_interrupt+0x5bc>


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0))
80002c14:	fe 68 00 00 	mov	r8,-131072
80002c18:	70 18       	ld.w	r8,r8[0x4]
80002c1a:	e2 18 10 00 	andl	r8,0x1000,COH
80002c1e:	e0 80 01 6f 	breq	80002efc <udd_interrupt+0x330>
		return false;	// No interrupt events on control endpoint

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80002c22:	fe 68 02 20 	mov	r8,-130528
80002c26:	31 09       	mov	r9,16
80002c28:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
80002c2a:	30 89       	mov	r9,8
80002c2c:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
80002c2e:	fe 68 01 30 	mov	r8,-130768
80002c32:	70 08       	ld.w	r8,r8[0x0]
80002c34:	e2 18 00 04 	andl	r8,0x4,COH
80002c38:	e0 80 00 87 	breq	80002d46 <udd_interrupt+0x17a>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80002c3c:	fe f8 05 74 	ld.w	r8,pc[1396]
80002c40:	70 08       	ld.w	r8,r8[0x0]
80002c42:	58 08       	cp.w	r8,0
80002c44:	c0 50       	breq	80002c4e <udd_interrupt+0x82>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80002c46:	f0 1f 01 5c 	mcall	800031b4 <udd_interrupt+0x5e8>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002c4a:	f0 1f 01 5c 	mcall	800031b8 <udd_interrupt+0x5ec>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80002c4e:	fe 68 01 30 	mov	r8,-130768
80002c52:	70 08       	ld.w	r8,r8[0x0]
80002c54:	f1 d8 c2 8b 	bfextu	r8,r8,0x14,0xb
80002c58:	58 88       	cp.w	r8,8
80002c5a:	c0 90       	breq	80002c6c <udd_interrupt+0xa0>
		udd_ctrl_stall_data();
80002c5c:	f0 1f 01 58 	mcall	800031bc <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002c60:	30 49       	mov	r9,4
80002c62:	fe 68 01 60 	mov	r8,-130720
80002c66:	91 09       	st.w	r8[0x0],r9
80002c68:	e0 8f 02 90 	bral	80003188 <udd_interrupt+0x5bc>
80002c6c:	fc 18 e0 00 	movh	r8,0xe000
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80002c70:	fe fc 05 50 	ld.w	r12,pc[1360]
80002c74:	fc 1b 20 00 	movh	r11,0x2000
80002c78:	f0 0c 00 09 	add	r9,r8,r12
80002c7c:	11 3a       	ld.ub	r10,r8++
80002c7e:	f2 0b 0b 0a 	st.b	r9[r11],r10
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80002c82:	30 8a       	mov	r10,8
80002c84:	ea 1a e0 00 	orh	r10,0xe000
80002c88:	14 38       	cp.w	r8,r10
80002c8a:	cf 71       	brne	80002c78 <udd_interrupt+0xac>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80002c8c:	fe f8 05 34 	ld.w	r8,pc[1332]
80002c90:	90 19       	ld.sh	r9,r8[0x2]
80002c92:	5c c9       	swap.bh	r9
80002c94:	b0 19       	st.h	r8[0x2],r9
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80002c96:	90 29       	ld.sh	r9,r8[0x4]
80002c98:	5c c9       	swap.bh	r9
80002c9a:	b0 29       	st.h	r8[0x4],r9
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80002c9c:	90 39       	ld.sh	r9,r8[0x6]
80002c9e:	5c c9       	swap.bh	r9
80002ca0:	b0 39       	st.h	r8[0x6],r9

	// Decode setup request
	if (udc_process_setup() == false) {
80002ca2:	f0 1f 01 49 	mcall	800031c4 <udd_interrupt+0x5f8>
80002ca6:	c0 91       	brne	80002cb8 <udd_interrupt+0xec>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
80002ca8:	f0 1f 01 45 	mcall	800031bc <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002cac:	30 49       	mov	r9,4
80002cae:	fe 68 01 60 	mov	r8,-130720
80002cb2:	91 09       	st.w	r8[0x0],r9
80002cb4:	e0 8f 02 6a 	bral	80003188 <udd_interrupt+0x5bc>
		return;
	}
	udd_ack_setup_received(0);
80002cb8:	30 49       	mov	r9,4
80002cba:	fe 68 01 60 	mov	r8,-130720
80002cbe:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80002cc0:	fe f8 05 00 	ld.w	r8,pc[1280]
80002cc4:	11 89       	ld.ub	r9,r8[0x0]
80002cc6:	30 08       	mov	r8,0
80002cc8:	f0 09 18 00 	cp.b	r9,r8
80002ccc:	c1 94       	brge	80002cfe <udd_interrupt+0x132>
		// Compute if an IN ZLP must be send after IN data
		udd_ctrl_payload_need_in_zlp =
80002cce:	fe f8 04 f2 	ld.w	r8,pc[1266]
80002cd2:	90 e8       	ld.uh	r8,r8[0xc]
80002cd4:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80002cd8:	5f 09       	sreq	r9
80002cda:	fe f8 04 ee 	ld.w	r8,pc[1262]
80002cde:	b0 89       	st.b	r8[0x0],r9
				((udd_g_ctrlreq.payload_size %
						USB_DEVICE_EP_CTRL_SIZE) == 0);
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002ce0:	30 08       	mov	r8,0
80002ce2:	fe f9 04 ea 	ld.w	r9,pc[1258]
80002ce6:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002ce8:	fe f9 04 e8 	ld.w	r9,pc[1256]
80002cec:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80002cee:	30 29       	mov	r9,2
80002cf0:	fe f8 04 c0 	ld.w	r8,pc[1216]
80002cf4:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent();	// Send first data transfer
80002cf6:	f0 1f 01 38 	mcall	800031d4 <udd_interrupt+0x608>
80002cfa:	e0 8f 02 47 	bral	80003188 <udd_interrupt+0x5bc>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80002cfe:	fe f8 04 c2 	ld.w	r8,pc[1218]
80002d02:	90 39       	ld.sh	r9,r8[0x6]
80002d04:	30 08       	mov	r8,0
80002d06:	f0 09 19 00 	cp.h	r9,r8
80002d0a:	c0 51       	brne	80002d14 <udd_interrupt+0x148>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
80002d0c:	f0 1f 01 33 	mcall	800031d8 <udd_interrupt+0x60c>
80002d10:	e0 8f 02 3c 	bral	80003188 <udd_interrupt+0x5bc>
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d14:	30 08       	mov	r8,0
80002d16:	fe f9 04 b6 	ld.w	r9,pc[1206]
80002d1a:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d1c:	fe f9 04 b4 	ld.w	r9,pc[1204]
80002d20:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80002d22:	30 19       	mov	r9,1
80002d24:	fe f8 04 8c 	ld.w	r8,pc[1164]
80002d28:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80002d2a:	31 08       	mov	r8,16
80002d2c:	fe 69 01 60 	mov	r9,-130720
80002d30:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002d32:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002d36:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
80002d38:	fe 6a 01 f0 	mov	r10,-130576
80002d3c:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002d3e:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002d42:	e0 8f 02 23 	bral	80003188 <udd_interrupt+0x5bc>
	if (Is_udd_setup_received(0)) {
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
80002d46:	fe 68 01 30 	mov	r8,-130768
80002d4a:	70 08       	ld.w	r8,r8[0x0]
80002d4c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d50:	c0 b0       	breq	80002d66 <udd_interrupt+0x19a>
80002d52:	fe 68 01 c0 	mov	r8,-130624
80002d56:	70 08       	ld.w	r8,r8[0x0]
80002d58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002d5c:	c0 50       	breq	80002d66 <udd_interrupt+0x19a>
		// IN packet sent
		udd_ctrl_in_sent();
80002d5e:	f0 1f 01 1e 	mcall	800031d4 <udd_interrupt+0x608>
80002d62:	e0 8f 02 13 	bral	80003188 <udd_interrupt+0x5bc>
		return true;
	}
	if (Is_udd_out_received(0)) {
80002d66:	fe 68 01 30 	mov	r8,-130768
80002d6a:	70 08       	ld.w	r8,r8[0x0]
80002d6c:	e2 18 00 02 	andl	r8,0x2,COH
80002d70:	e0 80 00 a3 	breq	80002eb6 <udd_interrupt+0x2ea>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80002d74:	fe f8 04 3c 	ld.w	r8,pc[1084]
80002d78:	70 08       	ld.w	r8,r8[0x0]
80002d7a:	58 18       	cp.w	r8,1
80002d7c:	c1 10       	breq	80002d9e <udd_interrupt+0x1d2>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80002d7e:	58 28       	cp.w	r8,2
80002d80:	5f 09       	sreq	r9
80002d82:	58 48       	cp.w	r8,4
80002d84:	5f 08       	sreq	r8
80002d86:	f3 e8 10 08 	or	r8,r9,r8
80002d8a:	c0 40       	breq	80002d92 <udd_interrupt+0x1c6>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
80002d8c:	f0 1f 01 0a 	mcall	800031b4 <udd_interrupt+0x5e8>
80002d90:	c0 38       	rjmp	80002d96 <udd_interrupt+0x1ca>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80002d92:	f0 1f 01 0b 	mcall	800031bc <udd_interrupt+0x5f0>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002d96:	f0 1f 01 09 	mcall	800031b8 <udd_interrupt+0x5ec>
80002d9a:	e0 8f 01 f7 	bral	80003188 <udd_interrupt+0x5bc>
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
80002d9e:	fe 68 01 30 	mov	r8,-130768
80002da2:	70 0b       	ld.w	r11,r8[0x0]
80002da4:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
80002da8:	fe f8 04 18 	ld.w	r8,pc[1048]
80002dac:	90 69       	ld.sh	r9,r8[0xc]
80002dae:	fe f8 04 22 	ld.w	r8,pc[1058]
80002db2:	90 08       	ld.sh	r8,r8[0x0]
80002db4:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
80002db8:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002dbc:	f6 0a 00 0a 	add	r10,r11,r10
80002dc0:	14 3c       	cp.w	r12,r10
80002dc2:	c0 44       	brge	80002dca <udd_interrupt+0x1fe>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80002dc4:	10 19       	sub	r9,r8
80002dc6:	f7 d9 b0 10 	bfexts	r11,r9,0x0,0x10
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002dca:	fe f9 03 f6 	ld.w	r9,pc[1014]
80002dce:	72 29       	ld.w	r9,r9[0x8]
	for (i = 0; i < nb_data; i++) {
80002dd0:	58 0b       	cp.w	r11,0
80002dd2:	e0 80 01 e2 	breq	80003196 <udd_interrupt+0x5ca>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002dd6:	5c 78       	castu.h	r8
80002dd8:	10 09       	add	r9,r8
80002dda:	fc 18 e0 00 	movh	r8,0xe000
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
80002dde:	11 3a       	ld.ub	r10,r8++
80002de0:	12 ca       	st.b	r9++,r10
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
80002de2:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002de6:	f6 0a 19 00 	cp.h	r10,r11
80002dea:	cf a3       	brcs	80002dde <udd_interrupt+0x212>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80002dec:	fe f9 03 e4 	ld.w	r9,pc[996]
80002df0:	92 08       	ld.sh	r8,r9[0x0]
80002df2:	16 08       	add	r8,r11
80002df4:	5c 88       	casts.h	r8
80002df6:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80002df8:	34 09       	mov	r9,64
80002dfa:	f2 0b 19 00 	cp.h	r11,r9
80002dfe:	c0 e1       	brne	80002e1a <udd_interrupt+0x24e>
80002e00:	fe f9 03 c0 	ld.w	r9,pc[960]
80002e04:	92 ba       	ld.uh	r10,r9[0x6]
80002e06:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80002e0a:	fe f9 03 c2 	ld.w	r9,pc[962]
80002e0e:	92 89       	ld.uh	r9,r9[0x0]
80002e10:	f6 09 00 09 	add	r9,r11,r9
80002e14:	12 3a       	cp.w	r10,r9
80002e16:	e0 89 00 1a 	brgt	80002e4a <udd_interrupt+0x27e>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback 
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80002e1a:	fe f9 03 a6 	ld.w	r9,pc[934]
80002e1e:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
80002e20:	72 5c       	ld.w	r12,r9[0x14]
80002e22:	58 0c       	cp.w	r12,0
80002e24:	c0 b0       	breq	80002e3a <udd_interrupt+0x26e>
			if (!udd_g_ctrlreq.over_under_run()) {
80002e26:	5d 1c       	icall	r12
80002e28:	c0 91       	brne	80002e3a <udd_interrupt+0x26e>
				// Stall ZLP
				udd_ctrl_stall_data();
80002e2a:	f0 1f 00 e5 	mcall	800031bc <udd_interrupt+0x5f0>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80002e2e:	30 29       	mov	r9,2
80002e30:	fe 68 01 60 	mov	r8,-130720
80002e34:	91 09       	st.w	r8[0x0],r9
80002e36:	e0 8f 01 a9 	bral	80003188 <udd_interrupt+0x5bc>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80002e3a:	30 29       	mov	r9,2
80002e3c:	fe 68 01 60 	mov	r8,-130720
80002e40:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80002e42:	f0 1f 00 e6 	mcall	800031d8 <udd_interrupt+0x60c>
80002e46:	e0 8f 01 a1 	bral	80003188 <udd_interrupt+0x5bc>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
80002e4a:	fe f9 03 76 	ld.w	r9,pc[886]
80002e4e:	92 69       	ld.sh	r9,r9[0xc]
80002e50:	f0 09 19 00 	cp.h	r9,r8
80002e54:	c2 21       	brne	80002e98 <udd_interrupt+0x2cc>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
80002e56:	fe f8 03 6a 	ld.w	r8,pc[874]
80002e5a:	70 5c       	ld.w	r12,r8[0x14]
80002e5c:	58 0c       	cp.w	r12,0
80002e5e:	c0 91       	brne	80002e70 <udd_interrupt+0x2a4>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
80002e60:	f0 1f 00 d7 	mcall	800031bc <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002e64:	30 29       	mov	r9,2
80002e66:	fe 68 01 60 	mov	r8,-130720
80002e6a:	91 09       	st.w	r8[0x0],r9
80002e6c:	e0 8f 01 8e 	bral	80003188 <udd_interrupt+0x5bc>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
80002e70:	5d 1c       	icall	r12
80002e72:	c0 81       	brne	80002e82 <udd_interrupt+0x2b6>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
80002e74:	f0 1f 00 d2 	mcall	800031bc <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002e78:	30 29       	mov	r9,2
80002e7a:	fe 68 01 60 	mov	r8,-130720
80002e7e:	91 09       	st.w	r8[0x0],r9
80002e80:	c8 49       	rjmp	80003188 <udd_interrupt+0x5bc>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80002e82:	fe f9 03 4a 	ld.w	r9,pc[842]
80002e86:	fe f8 03 4a 	ld.w	r8,pc[842]
80002e8a:	90 0b       	ld.sh	r11,r8[0x0]
80002e8c:	92 0a       	ld.sh	r10,r9[0x0]
80002e8e:	f6 0a 00 0a 	add	r10,r11,r10
80002e92:	b2 0a       	st.h	r9[0x0],r10
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80002e94:	30 09       	mov	r9,0
80002e96:	b0 09       	st.h	r8[0x0],r9
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
80002e98:	fe 69 01 60 	mov	r9,-130720
80002e9c:	30 28       	mov	r8,2
80002e9e:	93 08       	st.w	r9[0x0],r8
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80002ea0:	31 08       	mov	r8,16
80002ea2:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002ea4:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002ea8:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
80002eaa:	fe 6a 01 f0 	mov	r10,-130576
80002eae:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002eb0:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002eb4:	c6 a9       	rjmp	80003188 <udd_interrupt+0x5bc>
	if (Is_udd_out_received(0)) {
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
80002eb6:	fe 68 01 30 	mov	r8,-130768
80002eba:	70 08       	ld.w	r8,r8[0x0]
80002ebc:	e2 18 00 08 	andl	r8,0x8,COH
80002ec0:	c1 80       	breq	80002ef0 <udd_interrupt+0x324>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
80002ec2:	30 89       	mov	r9,8
80002ec4:	fe 68 01 60 	mov	r8,-130720
80002ec8:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
80002eca:	fe 68 01 30 	mov	r8,-130768
80002ece:	70 08       	ld.w	r8,r8[0x0]
80002ed0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002ed4:	e0 81 01 5a 	brne	80003188 <udd_interrupt+0x5bc>
		return;	// overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002ed8:	fe f8 02 d8 	ld.w	r8,pc[728]
80002edc:	70 08       	ld.w	r8,r8[0x0]
80002ede:	58 38       	cp.w	r8,3
80002ee0:	e0 81 01 54 	brne	80003188 <udd_interrupt+0x5bc>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80002ee4:	e8 69 00 00 	mov	r9,524288
80002ee8:	fe 68 01 f0 	mov	r8,-130576
80002eec:	91 09       	st.w	r8[0x0],r9
80002eee:	c4 d9       	rjmp	80003188 <udd_interrupt+0x5bc>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
80002ef0:	fe 68 01 30 	mov	r8,-130768
80002ef4:	70 08       	ld.w	r8,r8[0x0]
80002ef6:	e2 18 00 10 	andl	r8,0x10,COH
80002efa:	c0 e1       	brne	80002f16 <udd_interrupt+0x34a>
80002efc:	fe f7 02 e0 	ld.w	r7,pc[736]
80002f00:	0e 9a       	mov	r10,r7
80002f02:	fe 69 01 34 	mov	r9,-130764
80002f06:	30 0b       	mov	r11,0
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f08:	fe 66 00 00 	mov	r6,-131072
80002f0c:	fc 14 02 00 	movh	r4,0x200
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80002f10:	e0 63 10 00 	mov	r3,4096
80002f14:	c1 e8       	rjmp	80002f50 <udd_interrupt+0x384>
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
		// Underflow on IN packet
		udd_ack_nak_in(0);
80002f16:	31 09       	mov	r9,16
80002f18:	fe 68 01 60 	mov	r8,-130720
80002f1c:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
80002f1e:	fe 68 01 30 	mov	r8,-130768
80002f22:	70 08       	ld.w	r8,r8[0x0]
80002f24:	e2 18 00 02 	andl	r8,0x2,COH
80002f28:	e0 81 01 30 	brne	80003188 <udd_interrupt+0x5bc>
		return;	// underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80002f2c:	fe f8 02 84 	ld.w	r8,pc[644]
80002f30:	70 08       	ld.w	r8,r8[0x0]
80002f32:	58 18       	cp.w	r8,1
80002f34:	c0 41       	brne	80002f3c <udd_interrupt+0x370>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
80002f36:	f0 1f 00 a9 	mcall	800031d8 <udd_interrupt+0x60c>
80002f3a:	c2 79       	rjmp	80003188 <udd_interrupt+0x5bc>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80002f3c:	58 48       	cp.w	r8,4
80002f3e:	e0 81 01 25 	brne	80003188 <udd_interrupt+0x5bc>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80002f42:	e8 69 00 00 	mov	r9,524288
80002f46:	fe 68 01 f0 	mov	r8,-130576
80002f4a:	91 09       	st.w	r8[0x0],r9
80002f4c:	c1 e9       	rjmp	80003188 <udd_interrupt+0x5bc>
80002f4e:	10 9b       	mov	r11,r8
80002f50:	f6 c8 ff ff 	sub	r8,r11,-1
80002f54:	14 9c       	mov	r12,r10
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f56:	6c 45       	ld.w	r5,r6[0x10]
80002f58:	10 9e       	mov	lr,r8
80002f5a:	e8 0b 09 4b 	lsl	r11,r4,r11
80002f5e:	f7 e5 00 05 	and	r5,r11,r5
80002f62:	c4 b0       	breq	80002ff8 <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80002f64:	6c 15       	ld.w	r5,r6[0x4]
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f66:	f7 e5 00 05 	and	r5,r11,r5
80002f6a:	c4 70       	breq	80002ff8 <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			udd_disable_endpoint_dma_interrupt(ep);
80002f6c:	fe 69 00 00 	mov	r9,-131072
80002f70:	93 5b       	st.w	r9[0x14],r11
			if (ptr_job->b_raise_dma) {
80002f72:	74 09       	ld.w	r9,r10[0x0]
80002f74:	e6 19 20 00 	andh	r9,0x2000,COH
80002f78:	c0 50       	breq	80002f82 <udd_interrupt+0x3b6>
				// In case of manual raise DMA interrupt
				// to process a ZLP packet
				udd_raise_endpoint_dma_interrupt(ep);
80002f7a:	fe 69 00 00 	mov	r9,-131072
80002f7e:	93 3b       	st.w	r9[0xc],r11
80002f80:	c0 a8       	rjmp	80002f94 <udd_interrupt+0x3c8>
			}else{
				// Save number of data no transfered
				nb_remaining = (udd_endpoint_dma_get_status(ep) &
80002f82:	f0 09 15 04 	lsl	r9,r8,0x4
80002f86:	e0 39 fd 00 	sub	r9,130304
80002f8a:	72 39       	ld.w	r9,r9[0xc]
						AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
						>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
				// Update number of data transfered
				ptr_job->buf_size -= nb_remaining;
80002f8c:	b1 89       	lsr	r9,0x10
80002f8e:	74 2a       	ld.w	r10,r10[0x8]
80002f90:	12 1a       	sub	r10,r9
80002f92:	99 2a       	st.w	r12[0x8],r10
			}

			if (Is_udd_endpoint_in(ep)) {
80002f94:	a3 68       	lsl	r8,0x2
80002f96:	fe 6b 01 00 	mov	r11,-130816
80002f9a:	f0 0b 00 09 	add	r9,r8,r11
80002f9e:	72 09       	ld.w	r9,r9[0x0]
80002fa0:	e2 19 01 00 	andl	r9,0x100,COH
80002fa4:	c2 60       	breq	80002ff0 <udd_interrupt+0x424>
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
80002fa6:	78 09       	ld.w	r9,r12[0x0]
80002fa8:	e6 19 40 00 	andh	r9,0x4000,COH
80002fac:	c2 20       	breq	80002ff0 <udd_interrupt+0x424>
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
80002fae:	fe 6a 01 60 	mov	r10,-130720
80002fb2:	f0 0a 00 09 	add	r9,r8,r10
80002fb6:	30 1a       	mov	r10,1
80002fb8:	93 0a       	st.w	r9[0x0],r10
					if (Is_udd_write_enabled(ep)) {
80002fba:	fe 6b 01 30 	mov	r11,-130768
80002fbe:	f0 0b 00 09 	add	r9,r8,r11
80002fc2:	72 0a       	ld.w	r10,r9[0x0]
						udd_raise_in_send(ep);
80002fc4:	fe 6b 01 90 	mov	r11,-130672
80002fc8:	f0 0b 00 09 	add	r9,r8,r11
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
					if (Is_udd_write_enabled(ep)) {
80002fcc:	e6 1a 00 01 	andh	r10,0x1,COH
						udd_raise_in_send(ep);
80002fd0:	f9 ba 01 01 	movne	r10,1
80002fd4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
					}
					udd_enable_in_send_interrupt(ep);
80002fd8:	e0 38 fe 10 	sub	r8,130576
80002fdc:	30 19       	mov	r9,1
80002fde:	91 09       	st.w	r8[0x0],r9
					udd_enable_endpoint_interrupt(ep);
80002fe0:	e0 68 10 00 	mov	r8,4096
80002fe4:	f0 0e 09 4e 	lsl	lr,r8,lr
80002fe8:	fe 68 00 00 	mov	r8,-131072
80002fec:	91 6e       	st.w	r8[0x18],lr
80002fee:	cc d8       	rjmp	80003188 <udd_interrupt+0x5bc>
					return true;
				}
			}
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
80002ff0:	30 0b       	mov	r11,0
80002ff2:	f0 1f 00 7c 	mcall	800031e0 <udd_interrupt+0x614>
80002ff6:	cc 98       	rjmp	80003188 <udd_interrupt+0x5bc>
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80002ff8:	6c 4b       	ld.w	r11,r6[0x10]
80002ffa:	e6 0e 09 4e 	lsl	lr,r3,lr
80002ffe:	fd eb 00 0b 	and	r11,lr,r11
80003002:	c4 60       	breq	8000308e <udd_interrupt+0x4c2>
80003004:	e0 7b fe d0 	mov	r11,130768
80003008:	f2 0b 00 02 	add	r2,r9,r11
8000300c:	f2 cb ff 70 	sub	r11,r9,-144
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
80003010:	76 05       	ld.w	r5,r11[0x0]
80003012:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
80003016:	c1 50       	breq	80003040 <udd_interrupt+0x474>
80003018:	72 05       	ld.w	r5,r9[0x0]
8000301a:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
8000301e:	c1 10       	breq	80003040 <udd_interrupt+0x474>
				udd_disable_in_send_interrupt(ep);
80003020:	fe 6a 02 20 	mov	r10,-130528
80003024:	e4 0a 00 08 	add	r8,r2,r10
80003028:	30 19       	mov	r9,1
8000302a:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
8000302c:	e0 32 fe a0 	sub	r2,130720
80003030:	85 09       	st.w	r2[0x0],r9
				udd_ack_fifocon(ep);
80003032:	e0 69 40 00 	mov	r9,16384
80003036:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false);
80003038:	30 0b       	mov	r11,0
8000303a:	f0 1f 00 6a 	mcall	800031e0 <udd_interrupt+0x614>
8000303e:	ca 58       	rjmp	80003188 <udd_interrupt+0x5bc>
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0==udd_nb_busy_bank(ep))) {
80003040:	76 0b       	ld.w	r11,r11[0x0]
80003042:	e2 1b 10 00 	andl	r11,0x1000,COH
80003046:	c2 40       	breq	8000308e <udd_interrupt+0x4c2>
80003048:	72 0b       	ld.w	r11,r9[0x0]
8000304a:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
8000304e:	c2 01       	brne	8000308e <udd_interrupt+0x4c2>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
80003050:	fe 69 02 20 	mov	r9,-130528
80003054:	e4 09 00 08 	add	r8,r2,r9
80003058:	e0 69 10 00 	mov	r9,4096
8000305c:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
8000305e:	fe 68 00 00 	mov	r8,-131072
80003062:	91 5e       	st.w	r8[0x14],lr

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
80003064:	78 08       	ld.w	r8,r12[0x0]
80003066:	30 09       	mov	r9,0
80003068:	f1 d9 d3 81 	bfins	r8,r9,0x1c,0x1
8000306c:	99 08       	st.w	r12[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
8000306e:	fe 6b 01 00 	mov	r11,-130816
80003072:	e4 0b 00 08 	add	r8,r2,r11
80003076:	70 09       	ld.w	r9,r8[0x0]
80003078:	a9 d9       	cbr	r9,0x9
8000307a:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
8000307c:	e0 32 fe 10 	sub	r2,130576
80003080:	e8 68 00 00 	mov	r8,524288
80003084:	85 08       	st.w	r2[0x0],r8
				udd_reset_data_toggle(ep);
80003086:	e4 68 00 00 	mov	r8,262144
8000308a:	85 08       	st.w	r2[0x0],r8
8000308c:	c7 e8       	rjmp	80003188 <udd_interrupt+0x5bc>
8000308e:	2f 0a       	sub	r10,-16
80003090:	2f c9       	sub	r9,-4
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80003092:	58 38       	cp.w	r8,3
80003094:	fe 91 ff 5d 	brne	80002f4e <udd_interrupt+0x382>
80003098:	c8 38       	rjmp	8000319e <udd_interrupt+0x5d2>
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
8000309a:	30 89       	mov	r9,8
8000309c:	fe 68 00 00 	mov	r8,-131072
800030a0:	91 29       	st.w	r8[0x8],r9
#if __ICCAVR32__
#if !defined(AVR32_USBB_IRQ_GROUP)
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
800030a2:	ee c6 ff d0 	sub	r6,r7,-48
static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_finish_job(&udd_ep_job[i], true);
800030a6:	30 15       	mov	r5,1
800030a8:	0a 9b       	mov	r11,r5
800030aa:	0e 9c       	mov	r12,r7
800030ac:	f0 1f 00 4d 	mcall	800031e0 <udd_interrupt+0x614>
800030b0:	2f 07       	sub	r7,-16

static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800030b2:	0c 37       	cp.w	r7,r6
800030b4:	cf a1       	brne	800030a8 <udd_interrupt+0x4dc>
		// Abort all jobs on-going
#if (0!=USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
800030b6:	f0 1f 00 4c 	mcall	800031e4 <udd_interrupt+0x618>
		// Reset endpoint control
		udd_reset_ep_ctrl();
800030ba:	f0 1f 00 4c 	mcall	800031e8 <udd_interrupt+0x61c>
		// Reset endpoint control management
		udd_ctrl_init();
800030be:	f0 1f 00 3f 	mcall	800031b8 <udd_interrupt+0x5ec>
		goto udd_interrupt_end;
800030c2:	c6 38       	rjmp	80003188 <udd_interrupt+0x5bc>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
800030c4:	fe 68 00 00 	mov	r8,-131072
800030c8:	70 48       	ld.w	r8,r8[0x10]
800030ca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800030ce:	c1 b0       	breq	80003104 <udd_interrupt+0x538>
800030d0:	fe 68 00 00 	mov	r8,-131072
800030d4:	70 18       	ld.w	r8,r8[0x4]
800030d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800030da:	c1 50       	breq	80003104 <udd_interrupt+0x538>
		otg_unfreeze_clock();
800030dc:	fe 68 00 00 	mov	r8,-131072
800030e0:	f0 f9 08 00 	ld.w	r9,r8[2048]
800030e4:	af c9       	cbr	r9,0xe
800030e6:	f1 49 08 00 	st.w	r8[2048],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
800030ea:	30 19       	mov	r9,1
800030ec:	91 59       	st.w	r8[0x14],r9
		udd_enable_wake_up_interrupt();
800030ee:	31 09       	mov	r9,16
800030f0:	91 69       	st.w	r8[0x18],r9
		otg_freeze_clock();	// Mandatory to exit of sleep mode after a wakeup event
800030f2:	f0 f9 08 00 	ld.w	r9,r8[2048]
800030f6:	af a9       	sbr	r9,0xe
800030f8:	f1 49 08 00 	st.w	r8[2048],r9
		udd_sleep_mode(false);	// Enter in SUSPEND mode
800030fc:	30 0c       	mov	r12,0
800030fe:	f0 1f 00 3c 	mcall	800031ec <udd_interrupt+0x620>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
80003102:	c4 38       	rjmp	80003188 <udd_interrupt+0x5bc>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
80003104:	fe 68 00 00 	mov	r8,-131072
80003108:	70 48       	ld.w	r8,r8[0x10]
8000310a:	e2 18 00 10 	andl	r8,0x10,COH
8000310e:	c2 10       	breq	80003150 <udd_interrupt+0x584>
80003110:	fe 68 00 00 	mov	r8,-131072
80003114:	70 18       	ld.w	r8,r8[0x4]
80003116:	e2 18 00 10 	andl	r8,0x10,COH
8000311a:	c1 b0       	breq	80003150 <udd_interrupt+0x584>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
8000311c:	fe 68 00 00 	mov	r8,-131072
80003120:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003124:	af c9       	cbr	r9,0xe
80003126:	f1 49 08 00 	st.w	r8[2048],r9
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
8000312a:	c0 58       	rjmp	80003134 <udd_interrupt+0x568>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
8000312c:	70 19       	ld.w	r9,r8[0x4]
8000312e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80003132:	c0 61       	brne	8000313e <udd_interrupt+0x572>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
80003134:	f0 f9 08 04 	ld.w	r9,r8[2052]
80003138:	e2 19 40 00 	andl	r9,0x4000,COH
8000313c:	cf 80       	breq	8000312c <udd_interrupt+0x560>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
8000313e:	fe 68 00 00 	mov	r8,-131072
80003142:	31 09       	mov	r9,16
80003144:	91 59       	st.w	r8[0x14],r9
		udd_enable_suspend_interrupt();
80003146:	30 1c       	mov	r12,1
80003148:	91 6c       	st.w	r8[0x18],r12
		udd_sleep_mode(true);	// Enter in IDLE mode
8000314a:	f0 1f 00 29 	mcall	800031ec <udd_interrupt+0x620>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
8000314e:	c1 d8       	rjmp	80003188 <udd_interrupt+0x5bc>
	}

	if (Is_udd_vbus_transition()) {
80003150:	fe 68 00 00 	mov	r8,-131072
80003154:	f0 f8 08 04 	ld.w	r8,r8[2052]
80003158:	e2 18 00 02 	andl	r8,0x2,COH
8000315c:	c1 60       	breq	80003188 <udd_interrupt+0x5bc>
		// Ack VBus transition and send status to high level
		otg_unfreeze_clock();
8000315e:	fe 68 00 00 	mov	r8,-131072
80003162:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003166:	af c9       	cbr	r9,0xe
80003168:	f1 49 08 00 	st.w	r8[2048],r9
		udd_ack_vbus_transition();
8000316c:	30 29       	mov	r9,2
8000316e:	f1 49 08 08 	st.w	r8[2056],r9
		otg_freeze_clock();
80003172:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003176:	af a9       	sbr	r9,0xe
80003178:	f1 49 08 00 	st.w	r8[2048],r9
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_udd_vbus_high());
8000317c:	f0 fc 08 04 	ld.w	r12,r8[2052]
80003180:	f9 dc c1 61 	bfextu	r12,r12,0xb,0x1
80003184:	f0 1f 00 1b 	mcall	800031f0 <udd_interrupt+0x624>
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
80003188:	fe 68 00 00 	mov	r8,-131072
8000318c:	f0 f8 08 18 	ld.w	r8,r8[2072]
	return;
}
80003190:	e3 cd 40 fc 	ldm	sp++,r2-r7,lr
80003194:	d6 03       	rete
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80003196:	48 f9       	lddpc	r9,800031d0 <udd_interrupt+0x604>
80003198:	b2 08       	st.h	r9[0x0],r8
8000319a:	fe 9f fe 40 	bral	80002e1a <udd_interrupt+0x24e>
	if (udd_ep_interrupt())
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
8000319e:	fe 68 00 00 	mov	r8,-131072
800031a2:	70 18       	ld.w	r8,r8[0x4]
800031a4:	e2 18 00 08 	andl	r8,0x8,COH
800031a8:	c8 e0       	breq	800030c4 <udd_interrupt+0x4f8>
800031aa:	c7 8b       	rjmp	8000309a <udd_interrupt+0x4ce>
800031ac:	80 00       	ld.sh	r0,r0[0x0]
800031ae:	37 70       	mov	r0,119
800031b0:	00 00       	add	r0,r0
800031b2:	07 5c       	ld.sh	r12,--r3
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	24 f0       	sub	r0,79
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	27 30       	sub	r0,115
800031bc:	80 00       	ld.sh	r0,r0[0x0]
800031be:	24 d8       	sub	r8,77
800031c0:	00 00       	add	r0,r0
800031c2:	0a 10       	sub	r0,r5
800031c4:	80 00       	ld.sh	r0,r0[0x0]
800031c6:	39 f0       	mov	r0,-97
800031c8:	00 00       	add	r0,r0
800031ca:	07 60       	ld.uh	r0,--r3
800031cc:	00 00       	add	r0,r0
800031ce:	07 24       	ld.uh	r4,r3++
800031d0:	00 00       	add	r0,r0
800031d2:	07 5a       	ld.sh	r10,--r3
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	27 90       	sub	r0,121
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	27 64       	sub	r4,118
800031dc:	00 00       	add	r0,r0
800031de:	07 28       	ld.uh	r8,r3++
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	25 04       	sub	r4,80
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	39 90       	mov	r0,-103
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	29 ee       	sub	lr,-98
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	26 bc       	sub	r12,107
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	3e f0       	mov	r0,-17

800031f4 <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800031f4:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
800031f8:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
800031fa:	fe 78 0c 00 	mov	r8,-62464
800031fe:	71 59       	ld.w	r9,r8[0x54]
80003200:	e2 19 00 40 	andl	r9,0x40,COH
80003204:	cf d0       	breq	800031fe <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80003206:	a3 6c       	lsl	r12,0x2
80003208:	e0 2c f3 f8 	sub	r12,62456
8000320c:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
8000320e:	30 19       	mov	r9,1
80003210:	f2 0b 09 4b 	lsl	r11,r9,r11
80003214:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
80003216:	99 0b       	st.w	r12[0x0],r11
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003218:	e3 ba 00 00 	mtsr	0x0,r10

	cpu_irq_restore(flags);
}
8000321c:	5e fc       	retal	r12
8000321e:	d7 03       	nop

80003220 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
80003220:	eb cd 40 e0 	pushm	r5-r7,lr
80003224:	18 96       	mov	r6,r12
80003226:	58 9c       	cp.w	r12,9
80003228:	5f 07       	sreq	r7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000322a:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
8000322e:	d3 03       	ssrf	0x10
		pbus_id = 1;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_bus_refcount[pbus_id])
80003230:	48 f8       	lddpc	r8,8000326c <sysclk_enable_pbb_module+0x4c>
80003232:	f0 07 07 09 	ld.ub	r9,r8[r7]
80003236:	30 08       	mov	r8,0
80003238:	f0 09 18 00 	cp.b	r9,r8
8000323c:	c0 a1       	brne	80003250 <sysclk_enable_pbb_module+0x30>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
8000323e:	ee 0b 15 01 	lsl	r11,r7,0x1
80003242:	f9 bb 01 06 	movne	r11,6
80003246:	f9 bb 00 02 	moveq	r11,2
8000324a:	30 1c       	mov	r12,1
8000324c:	f0 1f 00 09 	mcall	80003270 <sysclk_enable_pbb_module+0x50>
		sysclk_enable_hsb_module(2 + (4 * pbus_id));
	sysclk_bus_refcount[pbus_id]++;
80003250:	48 78       	lddpc	r8,8000326c <sysclk_enable_pbb_module+0x4c>
80003252:	f0 07 07 09 	ld.ub	r9,r8[r7]
80003256:	2f f9       	sub	r9,-1
80003258:	f0 07 0b 09 	st.b	r8[r7],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000325c:	e3 b5 00 00 	mtsr	0x0,r5

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
80003260:	0c 9b       	mov	r11,r6
80003262:	30 3c       	mov	r12,3
80003264:	f0 1f 00 03 	mcall	80003270 <sysclk_enable_pbb_module+0x50>
}
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000326c:	00 00       	add	r0,r0
8000326e:	07 64       	ld.uh	r4,--r3
80003270:	80 00       	ld.sh	r0,r0[0x0]
80003272:	31 f4       	mov	r4,31

80003274 <sysclk_enable_usb>:
 * \pre The USB generick clock must be configurated to 12MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
80003274:	d4 01       	pushm	lr
	struct genclk_config gcfg;

	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
80003276:	30 1c       	mov	r12,1
80003278:	f0 1f 00 0f 	mcall	800032b4 <sysclk_enable_usb+0x40>
8000327c:	30 3b       	mov	r11,3
8000327e:	30 1c       	mov	r12,1
80003280:	f0 1f 00 0e 	mcall	800032b8 <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003284:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80003288:	d3 03       	ssrf	0x10
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
8000328a:	fe 78 0c 00 	mov	r8,-62464
8000328e:	e0 6a 03 07 	mov	r10,775
80003292:	91 aa       	st.w	r8[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80003294:	70 0a       	ld.w	r10,r8[0x0]
80003296:	a3 aa       	sbr	r10,0x2
80003298:	91 0a       	st.w	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000329a:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_OSC0RDY + id)));
8000329e:	71 59       	ld.w	r9,r8[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
800032a0:	e2 19 00 80 	andl	r9,0x80,COH
800032a4:	cf d0       	breq	8000329e <sysclk_enable_usb+0x2a>
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
800032a6:	30 49       	mov	r9,4
800032a8:	fe 78 0c 00 	mov	r8,-62464
800032ac:	f1 49 00 70 	st.w	r8[112],r9
		break;
	}

	genclk_config_set_divider(&gcfg, CONFIG_USBCLK_DIV);
	genclk_enable(&gcfg, AVR32_PM_GCLK_USBB);
}
800032b0:	d8 02       	popm	pc
800032b2:	00 00       	add	r0,r0
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	32 20       	mov	r0,34
800032b8:	80 00       	ld.sh	r0,r0[0x0]
800032ba:	31 f4       	mov	r4,31

800032bc <udi_cdc_data_disable>:
	UDI_CDC_DISABLE_EXT();
}

void udi_cdc_data_disable(void)
{
}
800032bc:	5e fc       	retal	r12
800032be:	d7 03       	nop

800032c0 <udi_cdc_comm_setup>:


bool udi_cdc_comm_setup(void)
{
	if (Udd_setup_is_in()) {
800032c0:	49 e8       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
800032c2:	11 88       	ld.ub	r8,r8[0x0]
800032c4:	30 09       	mov	r9,0
800032c6:	f2 08 18 00 	cp.b	r8,r9
800032ca:	c1 84       	brge	800032fa <udi_cdc_comm_setup+0x3a>
		// GET Interface Requests 
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
800032cc:	e2 18 00 60 	andl	r8,0x60,COH
800032d0:	e0 48 00 20 	cp.w	r8,32
800032d4:	c3 11       	brne	80003336 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
800032d6:	49 98       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
800032d8:	11 99       	ld.ub	r9,r8[0x1]
800032da:	32 18       	mov	r8,33
800032dc:	f0 09 18 00 	cp.b	r9,r8
800032e0:	c2 b1       	brne	80003336 <udi_cdc_comm_setup+0x76>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
800032e2:	49 68       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
800032e4:	90 39       	ld.sh	r9,r8[0x6]
800032e6:	30 78       	mov	r8,7
800032e8:	f0 09 19 00 	cp.h	r9,r8
800032ec:	c2 51       	brne	80003336 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.payload =
800032ee:	49 38       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
800032f0:	49 39       	lddpc	r9,8000333c <udi_cdc_comm_setup+0x7c>
800032f2:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
800032f4:	30 79       	mov	r9,7
800032f6:	b0 69       	st.h	r8[0xc],r9
800032f8:	5e ff       	retal	1
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests  
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
800032fa:	e2 18 00 60 	andl	r8,0x60,COH
800032fe:	e0 48 00 20 	cp.w	r8,32
80003302:	c1 a1       	brne	80003336 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
80003304:	48 d8       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
80003306:	11 98       	ld.ub	r8,r8[0x1]
80003308:	32 09       	mov	r9,32
8000330a:	f2 08 18 00 	cp.b	r8,r9
8000330e:	c0 60       	breq	8000331a <udi_cdc_comm_setup+0x5a>
80003310:	32 29       	mov	r9,34
80003312:	f2 08 18 00 	cp.b	r8,r9
80003316:	c1 01       	brne	80003336 <udi_cdc_comm_setup+0x76>
80003318:	5e ff       	retal	1
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
8000331a:	48 88       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
8000331c:	90 39       	ld.sh	r9,r8[0x6]
8000331e:	30 78       	mov	r8,7
80003320:	f0 09 19 00 	cp.h	r9,r8
80003324:	c0 91       	brne	80003336 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.callback =
80003326:	48 58       	lddpc	r8,80003338 <udi_cdc_comm_setup+0x78>
80003328:	48 69       	lddpc	r9,80003340 <udi_cdc_comm_setup+0x80>
8000332a:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
8000332c:	48 49       	lddpc	r9,8000333c <udi_cdc_comm_setup+0x7c>
8000332e:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003330:	30 79       	mov	r9,7
80003332:	b0 69       	st.h	r8[0xc],r9
80003334:	5e ff       	retal	1
						sizeof(udi_cdc_line_coding);
				return true;
80003336:	5e fd       	retal	0
80003338:	00 00       	add	r0,r0
8000333a:	0a 10       	sub	r0,r5
8000333c:	00 00       	add	r0,r0
8000333e:	07 68       	ld.uh	r8,--r3
80003340:	80 00       	ld.sh	r0,r0[0x0]
80003342:	33 48       	mov	r8,52

80003344 <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
80003344:	5e fd       	retal	0

80003346 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
80003346:	5e fd       	retal	0

80003348 <udi_cdc_line_coding_received>:

void udi_cdc_line_coding_received(void)
{
	// Send line coding to component associated to CDC
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));
}
80003348:	5e fc       	retal	r12
8000334a:	d7 03       	nop

8000334c <udi_cdc_is_rx_ready>:
}


bool udi_cdc_is_rx_ready(void)
{
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
8000334c:	48 68       	lddpc	r8,80003364 <udi_cdc_is_rx_ready+0x18>
8000334e:	11 8a       	ld.ub	r10,r8[0x0]
80003350:	48 68       	lddpc	r8,80003368 <udi_cdc_is_rx_ready+0x1c>
80003352:	90 08       	ld.sh	r8,r8[0x0]
80003354:	48 69       	lddpc	r9,8000336c <udi_cdc_is_rx_ready+0x20>
80003356:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
8000335a:	f0 09 19 00 	cp.h	r9,r8
}
8000335e:	5f bc       	srhi	r12
80003360:	5e fc       	retal	r12
80003362:	00 00       	add	r0,r0
80003364:	00 00       	add	r0,r0
80003366:	07 fc       	ld.ub	r12,r3[0x7]
80003368:	00 00       	add	r0,r0
8000336a:	07 f8       	ld.ub	r8,r3[0x7]
8000336c:	00 00       	add	r0,r0
8000336e:	07 f4       	ld.ub	r4,r3[0x7]

80003370 <udi_cdc_is_tx_ready>:


bool udi_cdc_is_tx_ready(void)
{
	irqflags_t flags;
	if (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS) {
80003370:	49 58       	lddpc	r8,800033c4 <udi_cdc_is_tx_ready+0x54>
80003372:	11 89       	ld.ub	r9,r8[0x0]
80003374:	49 58       	lddpc	r8,800033c8 <udi_cdc_is_tx_ready+0x58>
80003376:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000337a:	34 08       	mov	r8,64
8000337c:	f0 09 19 00 	cp.h	r9,r8
80003380:	c0 20       	breq	80003384 <udi_cdc_is_tx_ready+0x14>
80003382:	5e ff       	retal	1
		return true;
	}
	if (!udi_cdc_tx_both_buf_to_send) {
80003384:	49 28       	lddpc	r8,800033cc <udi_cdc_is_tx_ready+0x5c>
80003386:	11 88       	ld.ub	r8,r8[0x0]
80003388:	58 08       	cp.w	r8,0
8000338a:	c1 21       	brne	800033ae <udi_cdc_is_tx_ready+0x3e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000338c:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80003390:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
		if (!udi_cdc_tx_trans_ongoing) {
80003392:	49 09       	lddpc	r9,800033d0 <udi_cdc_is_tx_ready+0x60>
80003394:	13 89       	ld.ub	r9,r9[0x0]
80003396:	58 09       	cp.w	r9,0
80003398:	c0 91       	brne	800033aa <udi_cdc_is_tx_ready+0x3a>
			// No transfer on-going
			// then use the other buffer to store data
			udi_cdc_tx_both_buf_to_send = true;
8000339a:	30 1a       	mov	r10,1
8000339c:	48 c9       	lddpc	r9,800033cc <udi_cdc_is_tx_ready+0x5c>
8000339e:	b2 8a       	st.b	r9[0x0],r10
			udi_cdc_tx_buf_sel = (udi_cdc_tx_buf_sel==0)?1:0;
800033a0:	48 99       	lddpc	r9,800033c4 <udi_cdc_is_tx_ready+0x54>
800033a2:	13 8a       	ld.ub	r10,r9[0x0]
800033a4:	58 0a       	cp.w	r10,0
800033a6:	5f 0a       	sreq	r10
800033a8:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800033aa:	e3 b8 00 00 	mtsr	0x0,r8
		}
	  	cpu_irq_restore(flags);
	}
	return (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS);
800033ae:	48 68       	lddpc	r8,800033c4 <udi_cdc_is_tx_ready+0x54>
800033b0:	11 89       	ld.ub	r9,r8[0x0]
800033b2:	48 68       	lddpc	r8,800033c8 <udi_cdc_is_tx_ready+0x58>
800033b4:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033b8:	34 08       	mov	r8,64
800033ba:	f0 09 19 00 	cp.h	r9,r8
800033be:	5f 1c       	srne	r12
}
800033c0:	5e fc       	retal	r12
800033c2:	00 00       	add	r0,r0
800033c4:	00 00       	add	r0,r0
800033c6:	07 6f       	ld.uh	pc,--r3
800033c8:	00 00       	add	r0,r0
800033ca:	07 70       	ld.ub	r0,--r3
800033cc:	00 00       	add	r0,r0
800033ce:	08 81       	andn	r1,r4
800033d0:	00 00       	add	r0,r0
800033d2:	07 fe       	ld.ub	lr,r3[0x7]

800033d4 <udi_cdc_putc>:


int udi_cdc_putc(int value)
{
800033d4:	eb cd 40 fe 	pushm	r1-r7,lr
800033d8:	18 97       	mov	r7,r12
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
800033da:	49 88       	lddpc	r8,80003438 <udi_cdc_putc+0x64>
800033dc:	11 e9       	ld.ub	r9,r8[0x6]
800033de:	30 98       	mov	r8,9
800033e0:	f0 09 18 00 	cp.b	r9,r8
800033e4:	5f 04       	sreq	r4

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
		if (!udi_cdc_running) {
800033e6:	49 66       	lddpc	r6,8000343c <udi_cdc_putc+0x68>
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
800033e8:	49 63       	lddpc	r3,80003440 <udi_cdc_putc+0x6c>
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
800033ea:	49 75       	lddpc	r5,80003444 <udi_cdc_putc+0x70>
800033ec:	49 72       	lddpc	r2,80003448 <udi_cdc_putc+0x74>
	cpu_irq_restore(flags);

	if (b_databit_9) {
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
800033ee:	30 01       	mov	r1,0

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
800033f0:	f0 1f 00 17 	mcall	8000344c <udi_cdc_putc+0x78>
800033f4:	c0 51       	brne	800033fe <udi_cdc_putc+0x2a>
		if (!udi_cdc_running) {
800033f6:	0d 88       	ld.ub	r8,r6[0x0]
800033f8:	58 08       	cp.w	r8,0
800033fa:	cf b1       	brne	800033f0 <udi_cdc_putc+0x1c>
800033fc:	c1 b8       	rjmp	80003432 <udi_cdc_putc+0x5e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800033fe:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003402:	d3 03       	ssrf	0x10
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
80003404:	07 88       	ld.ub	r8,r3[0x0]
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
80003406:	ea 08 04 19 	ld.sh	r9,r5[r8<<0x1]
8000340a:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
8000340e:	f0 0c 15 06 	lsl	r12,r8,0x6
80003412:	f8 0b 00 0b 	add	r11,r12,r11
80003416:	e4 0b 0b 07 	st.b	r2[r11],r7
8000341a:	2f f9       	sub	r9,-1
8000341c:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003420:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);

	if (b_databit_9) {
80003424:	58 04       	cp.w	r4,0
80003426:	c0 31       	brne	8000342c <udi_cdc_putc+0x58>
80003428:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
8000342c:	a9 47       	asr	r7,0x8
8000342e:	02 94       	mov	r4,r1
80003430:	ce 0b       	rjmp	800033f0 <udi_cdc_putc+0x1c>
		goto udi_cdc_putc_process_one_byte;
80003432:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80003436:	00 00       	add	r0,r0
80003438:	00 00       	add	r0,r0
8000343a:	07 68       	ld.uh	r8,--r3
8000343c:	00 00       	add	r0,r0
8000343e:	07 fd       	ld.ub	sp,r3[0x7]
80003440:	00 00       	add	r0,r0
80003442:	07 6f       	ld.uh	pc,--r3
80003444:	00 00       	add	r0,r0
80003446:	07 70       	ld.ub	r0,--r3
80003448:	00 00       	add	r0,r0
8000344a:	07 74       	ld.ub	r4,--r3
8000344c:	80 00       	ld.sh	r0,r0[0x0]
8000344e:	33 70       	mov	r0,55

80003450 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(void)
{
80003450:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003454:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80003458:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint8_t buf_sel_trans;

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel;
8000345a:	49 78       	lddpc	r8,800034b4 <udi_cdc_rx_start+0x64>
8000345c:	11 87       	ld.ub	r7,r8[0x0]
	if (udi_cdc_rx_trans_ongoing ||
8000345e:	49 78       	lddpc	r8,800034b8 <udi_cdc_rx_start+0x68>
80003460:	11 88       	ld.ub	r8,r8[0x0]
80003462:	58 08       	cp.w	r8,0
80003464:	c0 a1       	brne	80003478 <udi_cdc_rx_start+0x28>
		(udi_cdc_rx_pos < udi_cdc_rx_buf_nb[buf_sel_trans])) {
80003466:	49 68       	lddpc	r8,800034bc <udi_cdc_rx_start+0x6c>
80003468:	90 08       	ld.sh	r8,r8[0x0]
8000346a:	49 6a       	lddpc	r10,800034c0 <udi_cdc_rx_start+0x70>
8000346c:	f4 07 04 1a 	ld.sh	r10,r10[r7<<0x1]
80003470:	f0 0a 19 00 	cp.h	r10,r8
80003474:	e0 88 00 06 	brls	80003480 <udi_cdc_rx_start+0x30>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003478:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
8000347c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		cpu_irq_restore(flags);
		return false;
	}

	// Change current buffer
	udi_cdc_rx_pos = 0;
80003480:	30 0a       	mov	r10,0
80003482:	48 f8       	lddpc	r8,800034bc <udi_cdc_rx_start+0x6c>
80003484:	b0 0a       	st.h	r8[0x0],r10
	udi_cdc_rx_buf_sel = (buf_sel_trans==0)?1:0;
80003486:	58 07       	cp.w	r7,0
80003488:	5f 0a       	sreq	r10
8000348a:	48 b8       	lddpc	r8,800034b4 <udi_cdc_rx_start+0x64>
8000348c:	b0 8a       	st.b	r8[0x0],r10

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing = true;
8000348e:	30 1a       	mov	r10,1
80003490:	48 a8       	lddpc	r8,800034b8 <udi_cdc_rx_start+0x68>
80003492:	b0 8a       	st.b	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003494:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
	
	if (udi_cdc_is_rx_ready()) {
80003498:	f0 1f 00 0b 	mcall	800034c4 <udi_cdc_rx_start+0x74>
		UDI_CDC_RX_NOTIFY();
	}

	return udd_ep_run( UDI_CDC_DATA_EP_OUT,
8000349c:	a7 67       	lsl	r7,0x6
8000349e:	48 b8       	lddpc	r8,800034c8 <udi_cdc_rx_start+0x78>
800034a0:	34 09       	mov	r9,64
800034a2:	48 ba       	lddpc	r10,800034cc <udi_cdc_rx_start+0x7c>
800034a4:	0e 0a       	add	r10,r7
800034a6:	30 1b       	mov	r11,1
800034a8:	30 2c       	mov	r12,2
800034aa:	f0 1f 00 0a 	mcall	800034d0 <udi_cdc_rx_start+0x80>
					true,
					udi_cdc_rx_buf[buf_sel_trans],
					UDI_CDC_RX_BUFFERS,
					udi_cdc_data_recevied);
}
800034ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800034b2:	00 00       	add	r0,r0
800034b4:	00 00       	add	r0,r0
800034b6:	07 fc       	ld.ub	r12,r3[0x7]
800034b8:	00 00       	add	r0,r0
800034ba:	08 80       	andn	r0,r4
800034bc:	00 00       	add	r0,r0
800034be:	07 f8       	ld.ub	r8,r3[0x7]
800034c0:	00 00       	add	r0,r0
800034c2:	07 f4       	ld.ub	r4,r3[0x7]
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	33 4c       	mov	r12,52
800034c8:	80 00       	ld.sh	r0,r0[0x0]
800034ca:	35 50       	mov	r0,85
800034cc:	00 00       	add	r0,r0
800034ce:	08 00       	add	r0,r4
800034d0:	80 00       	ld.sh	r0,r0[0x0]
800034d2:	25 74       	sub	r4,87

800034d4 <udi_cdc_getc>:
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
}


int udi_cdc_getc(void)
{
800034d4:	d4 31       	pushm	r0-r7,lr
	int rx_data = 0;
	bool b_databit_9;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
800034d6:	49 88       	lddpc	r8,80003534 <udi_cdc_getc+0x60>
800034d8:	11 e9       	ld.ub	r9,r8[0x6]
800034da:	30 98       	mov	r8,9
800034dc:	f0 09 18 00 	cp.b	r9,r8
800034e0:	5f 02       	sreq	r2
800034e2:	30 03       	mov	r3,0

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
800034e4:	49 56       	lddpc	r6,80003538 <udi_cdc_getc+0x64>
800034e6:	49 67       	lddpc	r7,8000353c <udi_cdc_getc+0x68>
800034e8:	49 65       	lddpc	r5,80003540 <udi_cdc_getc+0x6c>
		if (!udi_cdc_running) {
800034ea:	49 74       	lddpc	r4,80003544 <udi_cdc_getc+0x70>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
800034ec:	49 71       	lddpc	r1,80003548 <udi_cdc_getc+0x74>
	udi_cdc_rx_start();

	if (b_databit_9) {
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
800034ee:	06 90       	mov	r0,r3
800034f0:	c0 48       	rjmp	800034f8 <udi_cdc_getc+0x24>
	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
		if (!udi_cdc_running) {
800034f2:	09 88       	ld.ub	r8,r4[0x0]
800034f4:	58 08       	cp.w	r8,0
800034f6:	c1 b0       	breq	8000352c <udi_cdc_getc+0x58>

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
800034f8:	0d 89       	ld.ub	r9,r6[0x0]
800034fa:	8e 08       	ld.sh	r8,r7[0x0]
800034fc:	ea 09 04 19 	ld.sh	r9,r5[r9<<0x1]
80003500:	f0 09 19 00 	cp.h	r9,r8
80003504:	fe 98 ff f7 	brls	800034f2 <udi_cdc_getc+0x1e>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
80003508:	0d 88       	ld.ub	r8,r6[0x0]
8000350a:	8e 09       	ld.sh	r9,r7[0x0]
8000350c:	5c 79       	castu.h	r9
8000350e:	a7 68       	lsl	r8,0x6
80003510:	12 08       	add	r8,r9
80003512:	e2 08 07 08 	ld.ub	r8,r1[r8]
80003516:	10 43       	or	r3,r8
	udi_cdc_rx_pos++;
80003518:	8e 08       	ld.sh	r8,r7[0x0]
8000351a:	2f f8       	sub	r8,-1
8000351c:	ae 08       	st.h	r7[0x0],r8

	udi_cdc_rx_start();
8000351e:	f0 1f 00 0c 	mcall	8000354c <udi_cdc_getc+0x78>

	if (b_databit_9) {
80003522:	58 02       	cp.w	r2,0
80003524:	c0 50       	breq	8000352e <udi_cdc_getc+0x5a>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
80003526:	a9 63       	lsl	r3,0x8
80003528:	00 92       	mov	r2,r0
8000352a:	ce 7b       	rjmp	800034f8 <udi_cdc_getc+0x24>
		goto udi_cdc_getc_process_one_byte;
8000352c:	30 03       	mov	r3,0
	}
	return rx_data;
}
8000352e:	06 9c       	mov	r12,r3
80003530:	d8 32       	popm	r0-r7,pc
80003532:	00 00       	add	r0,r0
80003534:	00 00       	add	r0,r0
80003536:	07 68       	ld.uh	r8,--r3
80003538:	00 00       	add	r0,r0
8000353a:	07 fc       	ld.ub	r12,r3[0x7]
8000353c:	00 00       	add	r0,r0
8000353e:	07 f8       	ld.ub	r8,r3[0x7]
80003540:	00 00       	add	r0,r0
80003542:	07 f4       	ld.ub	r4,r3[0x7]
80003544:	00 00       	add	r0,r0
80003546:	07 fd       	ld.ub	sp,r3[0x7]
80003548:	00 00       	add	r0,r0
8000354a:	08 00       	add	r0,r4
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	34 50       	mov	r0,69

80003550 <udi_cdc_data_recevied>:
					udi_cdc_data_recevied);
}


void udi_cdc_data_recevied(udd_ep_status_t status, iram_size_t n)
{
80003550:	d4 01       	pushm	lr
	uint8_t buf_sel_trans;

	if (UDD_EP_TRANSFER_OK != status) {
80003552:	58 0c       	cp.w	r12,0
80003554:	c1 01       	brne	80003574 <udi_cdc_data_recevied+0x24>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel==0)?1:0;
80003556:	48 98       	lddpc	r8,80003578 <udi_cdc_data_recevied+0x28>
80003558:	11 88       	ld.ub	r8,r8[0x0]
	udi_cdc_rx_buf_nb[buf_sel_trans] = n;
8000355a:	58 08       	cp.w	r8,0
8000355c:	f9 b8 01 00 	movne	r8,0
80003560:	f9 b8 00 02 	moveq	r8,2
80003564:	48 69       	lddpc	r9,8000357c <udi_cdc_data_recevied+0x2c>
80003566:	f2 08 0a 0b 	st.h	r9[r8],r11
	udi_cdc_rx_trans_ongoing = false;
8000356a:	30 09       	mov	r9,0
8000356c:	48 58       	lddpc	r8,80003580 <udi_cdc_data_recevied+0x30>
8000356e:	b0 89       	st.b	r8[0x0],r9
	udi_cdc_rx_start();
80003570:	f0 1f 00 05 	mcall	80003584 <udi_cdc_data_recevied+0x34>
80003574:	d8 02       	popm	pc
80003576:	00 00       	add	r0,r0
80003578:	00 00       	add	r0,r0
8000357a:	07 fc       	ld.ub	r12,r3[0x7]
8000357c:	00 00       	add	r0,r0
8000357e:	07 f4       	ld.ub	r4,r3[0x7]
80003580:	00 00       	add	r0,r0
80003582:	08 80       	andn	r0,r4
80003584:	80 00       	ld.sh	r0,r0[0x0]
80003586:	34 50       	mov	r0,69

80003588 <udi_cdc_tx_send>:
	udi_cdc_tx_send();
}


static void udi_cdc_tx_send(void)
{
80003588:	eb cd 40 e0 	pushm	r5-r7,lr
	irqflags_t flags;
	uint8_t buf_sel_trans;
	bool b_short_packet;

	if (udi_cdc_tx_trans_ongoing) {
8000358c:	4a a8       	lddpc	r8,80003634 <udi_cdc_tx_send+0xac>
8000358e:	11 88       	ld.ub	r8,r8[0x0]
80003590:	58 08       	cp.w	r8,0
80003592:	c4 f1       	brne	80003630 <udi_cdc_tx_send+0xa8>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
80003594:	f0 1f 00 29 	mcall	80003638 <udi_cdc_tx_send+0xb0>
80003598:	c0 a0       	breq	800035ac <udi_cdc_tx_send+0x24>
		if (udi_cdc_tx_sof_num == udd_get_micro_frame_number()) {
8000359a:	f0 1f 00 29 	mcall	8000363c <udi_cdc_tx_send+0xb4>
8000359e:	4a 98       	lddpc	r8,80003640 <udi_cdc_tx_send+0xb8>
800035a0:	90 08       	ld.sh	r8,r8[0x0]
800035a2:	f8 08 19 00 	cp.h	r8,r12
800035a6:	c0 a1       	brne	800035ba <udi_cdc_tx_send+0x32>
800035a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num == udd_get_frame_number()) {
800035ac:	f0 1f 00 26 	mcall	80003644 <udi_cdc_tx_send+0xbc>
800035b0:	4a 48       	lddpc	r8,80003640 <udi_cdc_tx_send+0xb8>
800035b2:	90 08       	ld.sh	r8,r8[0x0]
800035b4:	f8 08 19 00 	cp.h	r8,r12
800035b8:	c3 c0       	breq	80003630 <udi_cdc_tx_send+0xa8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800035ba:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800035be:	d3 03       	ssrf	0x10
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel;
800035c0:	4a 29       	lddpc	r9,80003648 <udi_cdc_tx_send+0xc0>
800035c2:	13 87       	ld.ub	r7,r9[0x0]
	if (!udi_cdc_tx_both_buf_to_send) {
800035c4:	4a 29       	lddpc	r9,8000364c <udi_cdc_tx_send+0xc4>
800035c6:	13 89       	ld.ub	r9,r9[0x0]
800035c8:	58 09       	cp.w	r9,0
800035ca:	c0 61       	brne	800035d6 <udi_cdc_tx_send+0x4e>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel = (buf_sel_trans==0)?1:0;
800035cc:	58 07       	cp.w	r7,0
800035ce:	5f 0a       	sreq	r10
800035d0:	49 e9       	lddpc	r9,80003648 <udi_cdc_tx_send+0xc0>
800035d2:	b2 8a       	st.b	r9[0x0],r10
800035d4:	c0 38       	rjmp	800035da <udi_cdc_tx_send+0x52>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
800035d6:	58 07       	cp.w	r7,0
800035d8:	5f 07       	sreq	r7
	}
	udi_cdc_tx_trans_ongoing = true;
800035da:	30 1a       	mov	r10,1
800035dc:	49 69       	lddpc	r9,80003634 <udi_cdc_tx_send+0xac>
800035de:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800035e0:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[buf_sel_trans] != UDI_CDC_TX_BUFFERS);
800035e4:	0e 95       	mov	r5,r7
800035e6:	49 b8       	lddpc	r8,80003650 <udi_cdc_tx_send+0xc8>
800035e8:	f0 07 04 19 	ld.sh	r9,r8[r7<<0x1]
800035ec:	34 08       	mov	r8,64
800035ee:	f0 09 19 00 	cp.h	r9,r8
800035f2:	5f 16       	srne	r6
	if (b_short_packet) {
800035f4:	58 06       	cp.w	r6,0
800035f6:	c0 e0       	breq	80003612 <udi_cdc_tx_send+0x8a>
		if (udd_is_high_speed()) {
800035f8:	f0 1f 00 10 	mcall	80003638 <udi_cdc_tx_send+0xb0>
800035fc:	c0 60       	breq	80003608 <udi_cdc_tx_send+0x80>
			udi_cdc_tx_sof_num = udd_get_micro_frame_number();
800035fe:	f0 1f 00 10 	mcall	8000363c <udi_cdc_tx_send+0xb4>
80003602:	49 08       	lddpc	r8,80003640 <udi_cdc_tx_send+0xb8>
80003604:	b0 0c       	st.h	r8[0x0],r12
80003606:	c0 98       	rjmp	80003618 <udi_cdc_tx_send+0x90>
		}else{
			udi_cdc_tx_sof_num = udd_get_frame_number();
80003608:	f0 1f 00 0f 	mcall	80003644 <udi_cdc_tx_send+0xbc>
8000360c:	48 d8       	lddpc	r8,80003640 <udi_cdc_tx_send+0xb8>
8000360e:	b0 0c       	st.h	r8[0x0],r12
80003610:	c0 48       	rjmp	80003618 <udi_cdc_tx_send+0x90>
		}
	}else{
		udi_cdc_tx_sof_num = 0; // Force next transfer without wait SOF
80003612:	30 09       	mov	r9,0
80003614:	48 b8       	lddpc	r8,80003640 <udi_cdc_tx_send+0xb8>
80003616:	b0 09       	st.h	r8[0x0],r9
	}

	// Send the buffer with enable of short packet
	udd_ep_run( UDI_CDC_DATA_EP_IN,
80003618:	a7 67       	lsl	r7,0x6
8000361a:	48 f8       	lddpc	r8,80003654 <udi_cdc_tx_send+0xcc>
8000361c:	48 d9       	lddpc	r9,80003650 <udi_cdc_tx_send+0xc8>
8000361e:	f2 05 05 19 	ld.uh	r9,r9[r5<<0x1]
80003622:	48 ea       	lddpc	r10,80003658 <udi_cdc_tx_send+0xd0>
80003624:	0e 0a       	add	r10,r7
80003626:	0c 9b       	mov	r11,r6
80003628:	e0 6c 00 81 	mov	r12,129
8000362c:	f0 1f 00 0c 	mcall	8000365c <udi_cdc_tx_send+0xd4>
80003630:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003634:	00 00       	add	r0,r0
80003636:	07 fe       	ld.ub	lr,r3[0x7]
80003638:	80 00       	ld.sh	r0,r0[0x0]
8000363a:	23 7e       	sub	lr,55
8000363c:	80 00       	ld.sh	r0,r0[0x0]
8000363e:	23 ba       	sub	r10,59
80003640:	00 00       	add	r0,r0
80003642:	07 fa       	ld.ub	r10,r3[0x7]
80003644:	80 00       	ld.sh	r0,r0[0x0]
80003646:	23 ae       	sub	lr,58
80003648:	00 00       	add	r0,r0
8000364a:	07 6f       	ld.uh	pc,--r3
8000364c:	00 00       	add	r0,r0
8000364e:	08 81       	andn	r1,r4
80003650:	00 00       	add	r0,r0
80003652:	07 70       	ld.ub	r0,--r3
80003654:	80 00       	ld.sh	r0,r0[0x0]
80003656:	36 60       	mov	r0,102
80003658:	00 00       	add	r0,r0
8000365a:	07 74       	ld.ub	r4,--r3
8000365c:	80 00       	ld.sh	r0,r0[0x0]
8000365e:	25 74       	sub	r4,87

80003660 <udi_cdc_data_sent>:
	udi_cdc_rx_start();
}


void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n)
{
80003660:	d4 01       	pushm	lr
	if (UDD_EP_TRANSFER_OK != status) {
80003662:	58 0c       	cp.w	r12,0
80003664:	c1 21       	brne	80003688 <udi_cdc_data_sent+0x28>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[(udi_cdc_tx_buf_sel==0)?1:0] = 0;
80003666:	48 a8       	lddpc	r8,8000368c <udi_cdc_data_sent+0x2c>
80003668:	11 88       	ld.ub	r8,r8[0x0]
8000366a:	58 08       	cp.w	r8,0
8000366c:	f9 b9 01 00 	movne	r9,0
80003670:	f9 b9 00 02 	moveq	r9,2
80003674:	30 08       	mov	r8,0
80003676:	48 7a       	lddpc	r10,80003690 <udi_cdc_data_sent+0x30>
80003678:	f4 09 0a 08 	st.h	r10[r9],r8
	udi_cdc_tx_both_buf_to_send = false;
8000367c:	48 69       	lddpc	r9,80003694 <udi_cdc_data_sent+0x34>
8000367e:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_trans_ongoing = false;
80003680:	48 69       	lddpc	r9,80003698 <udi_cdc_data_sent+0x38>
80003682:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_send();
80003684:	f0 1f 00 06 	mcall	8000369c <udi_cdc_data_sent+0x3c>
80003688:	d8 02       	popm	pc
8000368a:	00 00       	add	r0,r0
8000368c:	00 00       	add	r0,r0
8000368e:	07 6f       	ld.uh	pc,--r3
80003690:	00 00       	add	r0,r0
80003692:	07 70       	ld.ub	r0,--r3
80003694:	00 00       	add	r0,r0
80003696:	08 81       	andn	r1,r4
80003698:	00 00       	add	r0,r0
8000369a:	07 fe       	ld.ub	lr,r3[0x7]
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	35 88       	mov	r8,88

800036a0 <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
800036a0:	d4 01       	pushm	lr
	udi_cdc_tx_send();
800036a2:	f0 1f 00 02 	mcall	800036a8 <udi_cdc_data_sof_notify+0x8>
}
800036a6:	d8 02       	popm	pc
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	35 88       	mov	r8,88

800036ac <udi_cdc_data_enable>:
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
}

bool udi_cdc_data_enable(void)
{
800036ac:	eb cd 40 c0 	pushm	r6-r7,lr
	// Initialize TX management
	udi_cdc_tx_trans_ongoing = false;
800036b0:	30 06       	mov	r6,0
800036b2:	48 f8       	lddpc	r8,800036ec <udi_cdc_data_enable+0x40>
800036b4:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_both_buf_to_send = false;
800036b6:	48 f8       	lddpc	r8,800036f0 <udi_cdc_data_enable+0x44>
800036b8:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_sel = 0;
800036ba:	48 f8       	lddpc	r8,800036f4 <udi_cdc_data_enable+0x48>
800036bc:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_nb[0] = 0;
800036be:	48 f8       	lddpc	r8,800036f8 <udi_cdc_data_enable+0x4c>
800036c0:	30 07       	mov	r7,0
800036c2:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_buf_nb[1] = 0;
800036c4:	b0 17       	st.h	r8[0x2],r7
	udi_cdc_tx_sof_num = 0;
800036c6:	48 e8       	lddpc	r8,800036fc <udi_cdc_data_enable+0x50>
800036c8:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_send();
800036ca:	f0 1f 00 0e 	mcall	80003700 <udi_cdc_data_enable+0x54>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing = false;
800036ce:	48 e8       	lddpc	r8,80003704 <udi_cdc_data_enable+0x58>
800036d0:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_sel = 0;
800036d2:	48 e8       	lddpc	r8,80003708 <udi_cdc_data_enable+0x5c>
800036d4:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_nb[0] = 0;
800036d6:	48 e8       	lddpc	r8,8000370c <udi_cdc_data_enable+0x60>
800036d8:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_rx_pos = 0;
800036da:	48 e8       	lddpc	r8,80003710 <udi_cdc_data_enable+0x64>
800036dc:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_running = udi_cdc_rx_start();
800036de:	f0 1f 00 0e 	mcall	80003714 <udi_cdc_data_enable+0x68>
800036e2:	48 e8       	lddpc	r8,80003718 <udi_cdc_data_enable+0x6c>
800036e4:	b0 8c       	st.b	r8[0x0],r12
	return udi_cdc_running;
800036e6:	11 8c       	ld.ub	r12,r8[0x0]
}
800036e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800036ec:	00 00       	add	r0,r0
800036ee:	07 fe       	ld.ub	lr,r3[0x7]
800036f0:	00 00       	add	r0,r0
800036f2:	08 81       	andn	r1,r4
800036f4:	00 00       	add	r0,r0
800036f6:	07 6f       	ld.uh	pc,--r3
800036f8:	00 00       	add	r0,r0
800036fa:	07 70       	ld.ub	r0,--r3
800036fc:	00 00       	add	r0,r0
800036fe:	07 fa       	ld.ub	r10,r3[0x7]
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	35 88       	mov	r8,88
80003704:	00 00       	add	r0,r0
80003706:	08 80       	andn	r0,r4
80003708:	00 00       	add	r0,r0
8000370a:	07 fc       	ld.ub	r12,r3[0x7]
8000370c:	00 00       	add	r0,r0
8000370e:	07 f4       	ld.ub	r4,r3[0x7]
80003710:	00 00       	add	r0,r0
80003712:	07 f8       	ld.ub	r8,r3[0x7]
80003714:	80 00       	ld.sh	r0,r0[0x0]
80003716:	34 50       	mov	r0,69
80003718:	00 00       	add	r0,r0
8000371a:	07 fd       	ld.ub	sp,r3[0x7]

8000371c <udi_cdc_comm_disable>:


void udi_cdc_comm_disable(void)
{
8000371c:	d4 01       	pushm	lr
	udi_cdc_running = false;
8000371e:	30 09       	mov	r9,0
80003720:	48 38       	lddpc	r8,8000372c <udi_cdc_comm_disable+0x10>
80003722:	b0 89       	st.b	r8[0x0],r9
	UDI_CDC_DISABLE_EXT();
80003724:	f0 1f 00 03 	mcall	80003730 <udi_cdc_comm_disable+0x14>
}
80003728:	d8 02       	popm	pc
8000372a:	00 00       	add	r0,r0
8000372c:	00 00       	add	r0,r0
8000372e:	07 fd       	ld.ub	sp,r3[0x7]
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	3e e4       	mov	r4,-18

80003734 <udi_cdc_comm_enable>:

//@}


bool udi_cdc_comm_enable(void)
{
80003734:	d4 01       	pushm	lr
	// Initialize control signal management
	udi_cdc_state = CPU_TO_LE16(0);
80003736:	30 0a       	mov	r10,0
80003738:	48 a8       	lddpc	r8,80003760 <udi_cdc_comm_enable+0x2c>
8000373a:	b0 0a       	st.h	r8[0x0],r10
	uid_cdc_state_msg.value = CPU_TO_LE16(0);
8000373c:	48 a8       	lddpc	r8,80003764 <udi_cdc_comm_enable+0x30>
8000373e:	b0 4a       	st.h	r8[0x8],r10

	udi_cdc_line_coding.dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
80003740:	48 a8       	lddpc	r8,80003768 <udi_cdc_comm_enable+0x34>
80003742:	30 09       	mov	r9,0
80003744:	b0 8a       	st.b	r8[0x0],r10
80003746:	3c 2a       	mov	r10,-62
80003748:	b0 9a       	st.b	r8[0x1],r10
8000374a:	30 1a       	mov	r10,1
8000374c:	b0 aa       	st.b	r8[0x2],r10
8000374e:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding.bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
80003750:	b0 c9       	st.b	r8[0x4],r9
	udi_cdc_line_coding.bParityType = UDI_CDC_DEFAULT_PARITY;
80003752:	b0 d9       	st.b	r8[0x5],r9
	udi_cdc_line_coding.bDataBits = UDI_CDC_DEFAULT_DATABITS;
80003754:	30 89       	mov	r9,8
80003756:	b0 e9       	st.b	r8[0x6],r9
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));

	// Call application callback
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
80003758:	f0 1f 00 05 	mcall	8000376c <udi_cdc_comm_enable+0x38>
}
8000375c:	d8 02       	popm	pc
8000375e:	00 00       	add	r0,r0
80003760:	00 00       	add	r0,r0
80003762:	08 82       	andn	r2,r4
80003764:	00 00       	add	r0,r0
80003766:	00 44       	or	r4,r0
80003768:	00 00       	add	r0,r0
8000376a:	07 68       	ld.uh	r8,--r3
8000376c:	80 00       	ld.sh	r0,r0[0x0]
8000376e:	3e d8       	mov	r8,-19

80003770 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
80003770:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
80003774:	49 18       	lddpc	r8,800037b8 <udc_sof_notify+0x48>
80003776:	11 89       	ld.ub	r9,r8[0x0]
80003778:	30 08       	mov	r8,0
8000377a:	f0 09 18 00 	cp.b	r9,r8
8000377e:	c1 b0       	breq	800037b4 <udc_sof_notify+0x44>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003780:	48 f8       	lddpc	r8,800037bc <udc_sof_notify+0x4c>
80003782:	70 08       	ld.w	r8,r8[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80003784:	70 09       	ld.w	r9,r8[0x0]
80003786:	13 ca       	ld.ub	r10,r9[0x4]
80003788:	30 09       	mov	r9,0
8000378a:	f2 0a 18 00 	cp.b	r10,r9
8000378e:	c1 30       	breq	800037b4 <udc_sof_notify+0x44>
80003790:	30 07       	mov	r7,0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003792:	48 b6       	lddpc	r6,800037bc <udc_sof_notify+0x4c>
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
80003794:	70 18       	ld.w	r8,r8[0x4]
80003796:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
8000379a:	70 48       	ld.w	r8,r8[0x10]
8000379c:	58 08       	cp.w	r8,0
8000379e:	c0 20       	breq	800037a2 <udc_sof_notify+0x32>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
800037a0:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800037a2:	2f f7       	sub	r7,-1
800037a4:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037a6:	6c 08       	ld.w	r8,r6[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800037a8:	70 09       	ld.w	r9,r8[0x0]
800037aa:	13 c9       	ld.ub	r9,r9[0x4]
800037ac:	ee 09 18 00 	cp.b	r9,r7
800037b0:	fe 9b ff f2 	brhi	80003794 <udc_sof_notify+0x24>
800037b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800037b8:	00 00       	add	r0,r0
800037ba:	08 8e       	andn	lr,r4
800037bc:	00 00       	add	r0,r0
800037be:	08 88       	andn	r8,r4

800037c0 <udc_get_eof_conf>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
800037c0:	48 78       	lddpc	r8,800037dc <udc_get_eof_conf+0x1c>
800037c2:	70 08       	ld.w	r8,r8[0x0]
800037c4:	70 08       	ld.w	r8,r8[0x0]
800037c6:	11 aa       	ld.ub	r10,r8[0x2]
800037c8:	11 b9       	ld.ub	r9,r8[0x3]
800037ca:	f3 ea 10 89 	or	r9,r9,r10<<0x8
800037ce:	5c c9       	swap.bh	r9
800037d0:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
}
800037d4:	f0 0c 00 0c 	add	r12,r8,r12
800037d8:	5e fc       	retal	r12
800037da:	00 00       	add	r0,r0
800037dc:	00 00       	add	r0,r0
800037de:	08 88       	andn	r8,r4

800037e0 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
800037e0:	eb cd 40 e0 	pushm	r5-r7,lr
800037e4:	18 97       	mov	r7,r12
800037e6:	16 96       	mov	r6,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration)
800037e8:	49 b8       	lddpc	r8,80003854 <udc_update_iface_desc+0x74>
800037ea:	11 89       	ld.ub	r9,r8[0x0]
800037ec:	30 08       	mov	r8,0
800037ee:	f0 09 18 00 	cp.b	r9,r8
800037f2:	c2 f0       	breq	80003850 <udc_update_iface_desc+0x70>
		return false;

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
800037f4:	49 98       	lddpc	r8,80003858 <udc_update_iface_desc+0x78>
800037f6:	70 08       	ld.w	r8,r8[0x0]
800037f8:	70 08       	ld.w	r8,r8[0x0]
800037fa:	11 c9       	ld.ub	r9,r8[0x4]
800037fc:	18 9e       	mov	lr,r12
800037fe:	f8 09 18 00 	cp.b	r9,r12
80003802:	e0 88 00 27 	brls	80003850 <udc_update_iface_desc+0x70>
		return false;

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
80003806:	49 65       	lddpc	r5,8000385c <udc_update_iface_desc+0x7c>
80003808:	8b 08       	st.w	r5[0x0],r8
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
8000380a:	f0 1f 00 16 	mcall	80003860 <udc_update_iface_desc+0x80>
	while (ptr_end_desc >
8000380e:	6a 08       	ld.w	r8,r5[0x0]
80003810:	10 3c       	cp.w	r12,r8
80003812:	e0 88 00 1f 	brls	80003850 <udc_update_iface_desc+0x70>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
80003816:	30 4b       	mov	r11,4
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
80003818:	10 99       	mov	r9,r8
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
8000381a:	11 9a       	ld.ub	r10,r8[0x1]
8000381c:	f6 0a 18 00 	cp.b	r10,r11
80003820:	c0 a1       	brne	80003834 <udc_update_iface_desc+0x54>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber)
80003822:	11 aa       	ld.ub	r10,r8[0x2]
80003824:	0e 9e       	mov	lr,r7
80003826:	ee 0a 18 00 	cp.b	r10,r7
8000382a:	c0 51       	brne	80003834 <udc_update_iface_desc+0x54>
					&& (setting_num ==
							udc_ptr_iface->
8000382c:	11 ba       	ld.ub	r10,r8[0x3]
8000382e:	ec 0a 18 00 	cp.b	r10,r6
80003832:	c0 b0       	breq	80003848 <udc_update_iface_desc+0x68>
							bAlternateSetting))
				return true;	// Interface found
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t
80003834:	13 88       	ld.ub	r8,r9[0x0]
80003836:	f2 08 00 08 	add	r8,r9,r8
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
8000383a:	10 3c       	cp.w	r12,r8
8000383c:	fe 9b ff ee 	brhi	80003818 <udc_update_iface_desc+0x38>
80003840:	48 79       	lddpc	r9,8000385c <udc_update_iface_desc+0x7c>
80003842:	93 08       	st.w	r9[0x0],r8
80003844:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003848:	48 59       	lddpc	r9,8000385c <udc_update_iface_desc+0x7c>
8000384a:	93 08       	st.w	r9[0x0],r8
8000384c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003850:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003854:	00 00       	add	r0,r0
80003856:	08 8e       	andn	lr,r4
80003858:	00 00       	add	r0,r0
8000385a:	08 88       	andn	r8,r4
8000385c:	00 00       	add	r0,r0
8000385e:	08 94       	mov	r4,r4
80003860:	80 00       	ld.sh	r0,r0[0x0]
80003862:	37 c0       	mov	r0,124

80003864 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
80003864:	eb cd 40 c0 	pushm	r6-r7,lr
80003868:	18 96       	mov	r6,r12
8000386a:	16 97       	mov	r7,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
8000386c:	f0 1f 00 11 	mcall	800038b0 <udc_next_desc_in_iface+0x4c>
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80003870:	0d 88       	ld.ub	r8,r6[0x0]
80003872:	10 06       	add	r6,r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
80003874:	0c 3c       	cp.w	r12,r6
80003876:	e0 88 00 19 	brls	800038a8 <udc_next_desc_in_iface+0x44>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
8000387a:	0d 98       	ld.ub	r8,r6[0x1]
8000387c:	30 49       	mov	r9,4
8000387e:	f2 08 18 00 	cp.b	r8,r9
80003882:	c1 30       	breq	800038a8 <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
80003884:	ee 08 18 00 	cp.b	r8,r7
80003888:	c0 a1       	brne	8000389c <udc_next_desc_in_iface+0x38>
8000388a:	c1 08       	rjmp	800038aa <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
8000388c:	0d 98       	ld.ub	r8,r6[0x1]
8000388e:	f2 08 18 00 	cp.b	r8,r9
80003892:	c0 b0       	breq	800038a8 <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
80003894:	ee 08 18 00 	cp.b	r8,r7
80003898:	c0 31       	brne	8000389e <udc_next_desc_in_iface+0x3a>
8000389a:	c0 88       	rjmp	800038aa <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
8000389c:	30 49       	mov	r9,4
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
			return desc;	// Specific descriptor found
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
8000389e:	0d 88       	ld.ub	r8,r6[0x0]
800038a0:	10 06       	add	r6,r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800038a2:	0c 3c       	cp.w	r12,r6
800038a4:	fe 9b ff f4 	brhi	8000388c <udc_next_desc_in_iface+0x28>
800038a8:	30 06       	mov	r6,0
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL;	// No specific descriptor found
}
800038aa:	0c 9c       	mov	r12,r6
800038ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800038b0:	80 00       	ld.sh	r0,r0[0x0]
800038b2:	37 c0       	mov	r0,124

800038b4 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
800038b4:	d4 01       	pushm	lr
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
800038b6:	48 48       	lddpc	r8,800038c4 <udc_valid_address+0x10>
800038b8:	11 bc       	ld.ub	r12,r8[0x3]
800038ba:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800038be:	f0 1f 00 03 	mcall	800038c8 <udc_valid_address+0x14>
}
800038c2:	d8 02       	popm	pc
800038c4:	00 00       	add	r0,r0
800038c6:	0a 10       	sub	r0,r5
800038c8:	80 00       	ld.sh	r0,r0[0x0]
800038ca:	23 80       	sub	r0,56

800038cc <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
800038cc:	eb cd 40 e0 	pushm	r5-r7,lr
800038d0:	18 95       	mov	r5,r12
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num))
800038d2:	f0 1f 00 12 	mcall	80003918 <udc_iface_enable+0x4c>
800038d6:	c1 f0       	breq	80003914 <udc_iface_enable+0x48>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
800038d8:	49 18       	lddpc	r8,8000391c <udc_iface_enable+0x50>
800038da:	70 07       	ld.w	r7,r8[0x0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
800038dc:	30 56       	mov	r6,5
800038de:	0c 9b       	mov	r11,r6
800038e0:	0e 9c       	mov	r12,r7
800038e2:	f0 1f 00 10 	mcall	80003920 <udc_iface_enable+0x54>
800038e6:	18 97       	mov	r7,r12
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
800038e8:	c0 d0       	breq	80003902 <udc_iface_enable+0x36>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
						ep_desc->bmAttributes,
						le16_to_cpu
800038ea:	19 ca       	ld.ub	r10,r12[0x4]
800038ec:	19 d8       	ld.ub	r8,r12[0x5]
800038ee:	f1 ea 10 8a 	or	r10,r8,r10<<0x8
800038f2:	5c ca       	swap.bh	r10
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
800038f4:	5c 7a       	castu.h	r10
800038f6:	19 bb       	ld.ub	r11,r12[0x3]
800038f8:	19 ac       	ld.ub	r12,r12[0x2]
800038fa:	f0 1f 00 0b 	mcall	80003924 <udc_iface_enable+0x58>
800038fe:	cf 01       	brne	800038de <udc_iface_enable+0x12>
80003900:	c0 a8       	rjmp	80003914 <udc_iface_enable+0x48>
						(ep_desc->wMaxPacketSize)))
			return false;
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
80003902:	48 a8       	lddpc	r8,80003928 <udc_iface_enable+0x5c>
80003904:	70 08       	ld.w	r8,r8[0x0]
80003906:	70 18       	ld.w	r8,r8[0x4]
80003908:	f0 05 03 28 	ld.w	r8,r8[r5<<0x2]
8000390c:	70 0c       	ld.w	r12,r8[0x0]
8000390e:	5d 1c       	icall	r12
80003910:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003914:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003918:	80 00       	ld.sh	r0,r0[0x0]
8000391a:	37 e0       	mov	r0,126
8000391c:	00 00       	add	r0,r0
8000391e:	08 94       	mov	r4,r4
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	38 64       	mov	r4,-122
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	28 cc       	sub	r12,-116
80003928:	00 00       	add	r0,r0
8000392a:	08 88       	andn	r8,r4

8000392c <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
8000392c:	eb cd 40 e0 	pushm	r5-r7,lr
80003930:	18 96       	mov	r6,r12
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003932:	18 97       	mov	r7,r12
80003934:	30 0b       	mov	r11,0
80003936:	f0 1f 00 12 	mcall	8000397c <udc_iface_disable+0x50>
8000393a:	c1 e0       	breq	80003976 <udc_iface_disable+0x4a>
		return false;

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
8000393c:	49 18       	lddpc	r8,80003980 <udc_iface_disable+0x54>
8000393e:	70 08       	ld.w	r8,r8[0x0]
80003940:	70 18       	ld.w	r8,r8[0x4]
80003942:	f0 06 03 25 	ld.w	r5,r8[r6<<0x2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003946:	6a 3c       	ld.w	r12,r5[0xc]
80003948:	5d 1c       	icall	r12
8000394a:	18 9b       	mov	r11,r12
8000394c:	0c 9c       	mov	r12,r6
8000394e:	f0 1f 00 0c 	mcall	8000397c <udc_iface_disable+0x50>
80003952:	c1 20       	breq	80003976 <udc_iface_disable+0x4a>
		return false;

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80003954:	48 c8       	lddpc	r8,80003984 <udc_iface_disable+0x58>
80003956:	70 07       	ld.w	r7,r8[0x0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80003958:	30 56       	mov	r6,5
8000395a:	0c 9b       	mov	r11,r6
8000395c:	0e 9c       	mov	r12,r7
8000395e:	f0 1f 00 0b 	mcall	80003988 <udc_iface_disable+0x5c>
80003962:	18 97       	mov	r7,r12
					udc_next_desc_in_iface((UDC_DESC_STORAGE
							usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc)
80003964:	c0 50       	breq	8000396e <udc_iface_disable+0x42>
				break;
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
80003966:	19 ac       	ld.ub	r12,r12[0x2]
80003968:	f0 1f 00 09 	mcall	8000398c <udc_iface_disable+0x60>
		}
8000396c:	cf 7b       	rjmp	8000395a <udc_iface_disable+0x2e>
	}
#endif

	// Disable interface
	udi_api->disable();
8000396e:	6a 18       	ld.w	r8,r5[0x4]
80003970:	5d 18       	icall	r8
80003972:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
	return true;
80003976:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000397a:	00 00       	add	r0,r0
8000397c:	80 00       	ld.sh	r0,r0[0x0]
8000397e:	37 e0       	mov	r0,126
80003980:	00 00       	add	r0,r0
80003982:	08 88       	andn	r8,r4
80003984:	00 00       	add	r0,r0
80003986:	08 94       	mov	r4,r4
80003988:	80 00       	ld.sh	r0,r0[0x0]
8000398a:	38 64       	mov	r4,-122
8000398c:	80 00       	ld.sh	r0,r0[0x0]
8000398e:	25 44       	sub	r4,84

80003990 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device, 
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
80003990:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
80003994:	49 38       	lddpc	r8,800039e0 <udc_reset+0x50>
80003996:	11 89       	ld.ub	r9,r8[0x0]
80003998:	30 08       	mov	r8,0
8000399a:	f0 09 18 00 	cp.b	r9,r8
8000399e:	c1 70       	breq	800039cc <udc_reset+0x3c>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800039a0:	49 18       	lddpc	r8,800039e4 <udc_reset+0x54>
800039a2:	70 08       	ld.w	r8,r8[0x0]
800039a4:	70 08       	ld.w	r8,r8[0x0]
800039a6:	11 c9       	ld.ub	r9,r8[0x4]
800039a8:	30 08       	mov	r8,0
800039aa:	f0 09 18 00 	cp.b	r9,r8
800039ae:	c0 f0       	breq	800039cc <udc_reset+0x3c>
800039b0:	30 07       	mov	r7,0
800039b2:	48 d6       	lddpc	r6,800039e4 <udc_reset+0x54>
				iface_num++) {
			udc_iface_disable(iface_num);
800039b4:	0e 9c       	mov	r12,r7
800039b6:	f0 1f 00 0d 	mcall	800039e8 <udc_reset+0x58>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800039ba:	2f f7       	sub	r7,-1
800039bc:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800039be:	6c 08       	ld.w	r8,r6[0x0]
800039c0:	70 08       	ld.w	r8,r8[0x0]
800039c2:	11 c8       	ld.ub	r8,r8[0x4]
800039c4:	ee 08 18 00 	cp.b	r8,r7
800039c8:	fe 9b ff f6 	brhi	800039b4 <udc_reset+0x24>
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
800039cc:	30 09       	mov	r9,0
800039ce:	48 58       	lddpc	r8,800039e0 <udc_reset+0x50>
800039d0:	b0 89       	st.b	r8[0x0],r9
	if (0 != (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status)) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
800039d2:	e0 69 01 00 	mov	r9,256
800039d6:	48 68       	lddpc	r8,800039ec <udc_reset+0x5c>
800039d8:	b0 09       	st.h	r8[0x0],r9
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
800039da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800039de:	00 00       	add	r0,r0
800039e0:	00 00       	add	r0,r0
800039e2:	08 8e       	andn	lr,r4
800039e4:	00 00       	add	r0,r0
800039e6:	08 88       	andn	r8,r4
800039e8:	80 00       	ld.sh	r0,r0[0x0]
800039ea:	39 2c       	mov	r12,-110
800039ec:	00 00       	add	r0,r0
800039ee:	08 8c       	andn	r12,r4

800039f0 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
800039f0:	eb cd 40 e0 	pushm	r5-r7,lr
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
800039f4:	fe f8 04 3c 	ld.w	r8,pc[1084]
800039f8:	30 09       	mov	r9,0
800039fa:	b0 69       	st.h	r8[0xc],r9
	udd_g_ctrlreq.callback = NULL;
800039fc:	30 0a       	mov	r10,0
800039fe:	91 4a       	st.w	r8[0x10],r10
	udd_g_ctrlreq.over_under_run = NULL;
80003a00:	91 5a       	st.w	r8[0x14],r10

	if (Udd_setup_is_in()) {
80003a02:	11 88       	ld.ub	r8,r8[0x0]
80003a04:	10 9a       	mov	r10,r8
80003a06:	f2 08 18 00 	cp.b	r8,r9
80003a0a:	c0 94       	brge	80003a1c <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0)
80003a0c:	fe f9 04 24 	ld.w	r9,pc[1060]
80003a10:	92 3b       	ld.sh	r11,r9[0x6]
80003a12:	30 09       	mov	r9,0
80003a14:	f2 0b 19 00 	cp.h	r11,r9
80003a18:	e0 80 02 0a 	breq	80003e2c <udc_process_setup+0x43c>
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80003a1c:	10 99       	mov	r9,r8
80003a1e:	e2 19 00 60 	andl	r9,0x60,COH
80003a22:	e0 81 01 d9 	brne	80003dd4 <udc_process_setup+0x3e4>
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
	if (Udd_setup_is_in()) {
80003a26:	f2 0a 18 00 	cp.b	r10,r9
80003a2a:	e0 84 01 01 	brge	80003c2c <udc_process_setup+0x23c>
		// GET Standard Requests 
		if (udd_g_ctrlreq.req.wLength == 0)
80003a2e:	fe f9 04 02 	ld.w	r9,pc[1026]
80003a32:	92 39       	ld.sh	r9,r9[0x6]
80003a34:	58 09       	cp.w	r9,0
80003a36:	e0 80 01 cf 	breq	80003dd4 <udc_process_setup+0x3e4>
			return false;	// Error for USB host

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003a3a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003a3e:	e0 81 00 9e 	brne	80003b7a <udc_process_setup+0x18a>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003a42:	fe fa 03 ee 	ld.w	r10,pc[1006]
80003a46:	15 9a       	ld.ub	r10,r10[0x1]
80003a48:	30 6b       	mov	r11,6
80003a4a:	f6 0a 18 00 	cp.b	r10,r11
80003a4e:	c1 a0       	breq	80003a82 <udc_process_setup+0x92>
80003a50:	30 8b       	mov	r11,8
80003a52:	f6 0a 18 00 	cp.b	r10,r11
80003a56:	e0 80 00 85 	breq	80003b60 <udc_process_setup+0x170>
80003a5a:	30 0b       	mov	r11,0
80003a5c:	f6 0a 18 00 	cp.b	r10,r11
80003a60:	e0 81 00 8d 	brne	80003b7a <udc_process_setup+0x18a>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status))
80003a64:	30 28       	mov	r8,2
80003a66:	f0 09 19 00 	cp.h	r9,r8
80003a6a:	c0 40       	breq	80003a72 <udc_process_setup+0x82>
80003a6c:	30 0c       	mov	r12,0
80003a6e:	e0 8f 01 af 	bral	80003dcc <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(
80003a72:	30 2b       	mov	r11,2
80003a74:	fe fc 03 c0 	ld.w	r12,pc[960]
80003a78:	f0 1f 00 f0 	mcall	80003e38 <udc_process_setup+0x448>
80003a7c:	30 1c       	mov	r12,1
80003a7e:	e0 8f 01 a7 	bral	80003dcc <udc_process_setup+0x3dc>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003a82:	fe f8 03 ae 	ld.w	r8,pc[942]
80003a86:	90 19       	ld.sh	r9,r8[0x2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80003a88:	f2 08 16 08 	lsr	r8,r9,0x8
80003a8c:	30 2a       	mov	r10,2
80003a8e:	f4 08 18 00 	cp.b	r8,r10
80003a92:	c1 00       	breq	80003ab2 <udc_process_setup+0xc2>
80003a94:	30 3a       	mov	r10,3
80003a96:	f4 08 18 00 	cp.b	r8,r10
80003a9a:	c2 a0       	breq	80003aee <udc_process_setup+0xfe>
80003a9c:	30 19       	mov	r9,1
80003a9e:	f2 08 18 00 	cp.b	r8,r9
80003aa2:	c5 d1       	brne	80003b5c <udc_process_setup+0x16c>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80003aa4:	fe f8 03 98 	ld.w	r8,pc[920]
80003aa8:	70 0c       	ld.w	r12,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80003aaa:	19 8b       	ld.ub	r11,r12[0x0]
80003aac:	f0 1f 00 e3 	mcall	80003e38 <udc_process_setup+0x448>
80003ab0:	c4 78       	rjmp	80003b3e <udc_process_setup+0x14e>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003ab2:	5c 59       	castu.b	r9
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80003ab4:	fe f8 03 88 	ld.w	r8,pc[904]
80003ab8:	70 08       	ld.w	r8,r8[0x0]
80003aba:	f1 38 00 11 	ld.ub	r8,r8[17]
80003abe:	f2 08 18 00 	cp.b	r8,r9
80003ac2:	e0 88 00 4d 	brls	80003b5c <udc_process_setup+0x16c>
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80003ac6:	fe f8 03 76 	ld.w	r8,pc[886]
80003aca:	70 18       	ld.w	r8,r8[0x4]
80003acc:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80003ad0:	19 a9       	ld.ub	r9,r12[0x2]
80003ad2:	19 b8       	ld.ub	r8,r12[0x3]
80003ad4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003ad8:	5c c8       	swap.bh	r8
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
80003ada:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80003ade:	f0 1f 00 d7 	mcall	80003e38 <udc_process_setup+0x448>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80003ae2:	fe f8 03 4e 	ld.w	r8,pc[846]
80003ae6:	70 28       	ld.w	r8,r8[0x8]
80003ae8:	30 29       	mov	r9,2
80003aea:	b0 99       	st.b	r8[0x1],r9
80003aec:	c2 98       	rjmp	80003b3e <udc_process_setup+0x14e>
	uint8_t i;
	uint8_t *str;
	uint8_t str_lgt=0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80003aee:	5c 59       	castu.b	r9
80003af0:	58 19       	cp.w	r9,1
80003af2:	c1 00       	breq	80003b12 <udc_process_setup+0x122>
80003af4:	58 29       	cp.w	r9,2
80003af6:	c0 40       	breq	80003afe <udc_process_setup+0x10e>
80003af8:	58 09       	cp.w	r9,0
80003afa:	c0 60       	breq	80003b06 <udc_process_setup+0x116>
80003afc:	c3 08       	rjmp	80003b5c <udc_process_setup+0x16c>
80003afe:	fe fc 03 42 	ld.w	r12,pc[834]
80003b02:	30 3b       	mov	r11,3
80003b04:	c0 a8       	rjmp	80003b18 <udc_process_setup+0x128>
	case 0:
		udd_set_setup_payload(
80003b06:	30 4b       	mov	r11,4
80003b08:	fe fc 03 3c 	ld.w	r12,pc[828]
80003b0c:	f0 1f 00 cb 	mcall	80003e38 <udc_process_setup+0x448>
80003b10:	c1 78       	rjmp	80003b3e <udc_process_setup+0x14e>
80003b12:	fe fc 03 36 	ld.w	r12,pc[822]
80003b16:	30 9b       	mov	r11,9
80003b18:	fe fa 03 34 	ld.w	r10,pc[820]
80003b1c:	2f ea       	sub	r10,-2
80003b1e:	18 98       	mov	r8,r12
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80003b20:	11 39       	ld.ub	r9,r8++
80003b22:	5c c9       	swap.bh	r9
80003b24:	14 b9       	st.h	r10++,r9
#endif
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
80003b26:	f0 0c 01 09 	sub	r9,r8,r12
80003b2a:	f6 09 18 00 	cp.b	r9,r11
80003b2e:	cf 93       	brcs	80003b20 <udc_process_setup+0x130>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}
		
		udc_string_desc.header.bLength = 2 + (str_lgt) * 2;
80003b30:	a1 7b       	lsl	r11,0x1
80003b32:	2f eb       	sub	r11,-2
80003b34:	fe fc 03 18 	ld.w	r12,pc[792]
80003b38:	b8 8b       	st.b	r12[0x0],r11
		udd_set_setup_payload(
80003b3a:	f0 1f 00 c0 	mcall	80003e38 <udc_process_setup+0x448>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size)
80003b3e:	fe f8 02 f2 	ld.w	r8,pc[754]
80003b42:	90 39       	ld.sh	r9,r8[0x6]
80003b44:	90 68       	ld.sh	r8,r8[0xc]
80003b46:	f2 08 19 00 	cp.h	r8,r9
80003b4a:	e0 8b 00 04 	brhi	80003b52 <udc_process_setup+0x162>
80003b4e:	30 1c       	mov	r12,1
80003b50:	c3 e9       	rjmp	80003dcc <udc_process_setup+0x3dc>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80003b52:	fe f8 02 de 	ld.w	r8,pc[734]
80003b56:	b0 69       	st.h	r8[0xc],r9
80003b58:	30 1c       	mov	r12,1
80003b5a:	c3 99       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003b5c:	30 0c       	mov	r12,0
80003b5e:	c3 79       	rjmp	80003dcc <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1)
80003b60:	30 18       	mov	r8,1
80003b62:	f0 09 19 00 	cp.h	r9,r8
80003b66:	c0 30       	breq	80003b6c <udc_process_setup+0x17c>
80003b68:	30 0c       	mov	r12,0
80003b6a:	c3 19       	rjmp	80003dcc <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(&udc_num_configuration,1);
80003b6c:	30 1b       	mov	r11,1
80003b6e:	fe fc 02 e2 	ld.w	r12,pc[738]
80003b72:	f0 1f 00 b2 	mcall	80003e38 <udc_process_setup+0x448>
80003b76:	30 1c       	mov	r12,1
80003b78:	c2 a9       	rjmp	80003dcc <udc_process_setup+0x3dc>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003b7a:	58 18       	cp.w	r8,1
80003b7c:	c3 61       	brne	80003be8 <udc_process_setup+0x1f8>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003b7e:	fe fa 02 b2 	ld.w	r10,pc[690]
80003b82:	15 9b       	ld.ub	r11,r10[0x1]
80003b84:	30 aa       	mov	r10,10
80003b86:	f4 0b 18 00 	cp.b	r11,r10
80003b8a:	c2 f1       	brne	80003be8 <udc_process_setup+0x1f8>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1)
80003b8c:	f0 09 19 00 	cp.h	r9,r8
80003b90:	c2 a1       	brne	80003be4 <udc_process_setup+0x1f4>
		return false;	// Error in request
	if (!udc_num_configuration)
80003b92:	fe f8 02 be 	ld.w	r8,pc[702]
80003b96:	11 89       	ld.ub	r9,r8[0x0]
80003b98:	30 08       	mov	r8,0
80003b9a:	f0 09 18 00 	cp.b	r9,r8
80003b9e:	c2 30       	breq	80003be4 <udc_process_setup+0x1f4>
		return false;	// The device is not is configured state yet

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003ba0:	fe f8 02 90 	ld.w	r8,pc[656]
80003ba4:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003ba6:	fe f8 02 ae 	ld.w	r8,pc[686]
80003baa:	70 08       	ld.w	r8,r8[0x0]
80003bac:	70 08       	ld.w	r8,r8[0x0]
80003bae:	11 c8       	ld.ub	r8,r8[0x4]
80003bb0:	ee 08 18 00 	cp.b	r8,r7
80003bb4:	e0 88 00 18 	brls	80003be4 <udc_process_setup+0x1f4>
		return false;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003bb8:	30 0b       	mov	r11,0
80003bba:	0e 9c       	mov	r12,r7
80003bbc:	f0 1f 00 a7 	mcall	80003e58 <udc_process_setup+0x468>
80003bc0:	c1 20       	breq	80003be4 <udc_process_setup+0x1f4>
		return false;
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
	udc_iface_setting = udi_api->getsetting();
80003bc2:	fe f8 02 92 	ld.w	r8,pc[658]
80003bc6:	70 08       	ld.w	r8,r8[0x0]
80003bc8:	70 18       	ld.w	r8,r8[0x4]
80003bca:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003bce:	70 3c       	ld.w	r12,r8[0xc]
80003bd0:	5d 1c       	icall	r12
80003bd2:	fe f8 02 8a 	ld.w	r8,pc[650]
80003bd6:	b0 8c       	st.b	r8[0x0],r12
	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80003bd8:	30 1b       	mov	r11,1
80003bda:	10 9c       	mov	r12,r8
80003bdc:	f0 1f 00 97 	mcall	80003e38 <udc_process_setup+0x448>
80003be0:	30 1c       	mov	r12,1
80003be2:	cf 58       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003be4:	30 0c       	mov	r12,0
80003be6:	cf 38       	rjmp	80003dcc <udc_process_setup+0x3dc>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003be8:	58 28       	cp.w	r8,2
80003bea:	e0 81 00 f5 	brne	80003dd4 <udc_process_setup+0x3e4>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003bee:	fe f8 02 42 	ld.w	r8,pc[578]
80003bf2:	11 9a       	ld.ub	r10,r8[0x1]
80003bf4:	30 08       	mov	r8,0
80003bf6:	f0 0a 18 00 	cp.b	r10,r8
80003bfa:	e0 81 00 e8 	brne	80003dca <udc_process_setup+0x3da>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status))
80003bfe:	30 28       	mov	r8,2
80003c00:	f0 09 19 00 	cp.h	r9,r8
80003c04:	c0 30       	breq	80003c0a <udc_process_setup+0x21a>
80003c06:	30 0c       	mov	r12,0
80003c08:	ce 28       	rjmp	80003dcc <udc_process_setup+0x3dc>
		return false;

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80003c0a:	fe f8 02 26 	ld.w	r8,pc[550]
80003c0e:	11 dc       	ld.ub	r12,r8[0x5]
80003c10:	f0 1f 00 94 	mcall	80003e60 <udc_process_setup+0x470>
80003c14:	e0 68 01 00 	mov	r8,256
80003c18:	f9 b8 00 00 	moveq	r8,0
80003c1c:	fe fc 02 48 	ld.w	r12,pc[584]
80003c20:	b8 08       	st.h	r12[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload(
80003c22:	30 2b       	mov	r11,2
80003c24:	f0 1f 00 85 	mcall	80003e38 <udc_process_setup+0x448>
80003c28:	30 1c       	mov	r12,1
80003c2a:	cd 18       	rjmp	80003dcc <udc_process_setup+0x3dc>
			}
		}
#endif
	} else {
		// SET Standard Requests  
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003c2c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003c30:	c7 71       	brne	80003d1e <udc_process_setup+0x32e>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c32:	fe f9 01 fe 	ld.w	r9,pc[510]
80003c36:	13 99       	ld.ub	r9,r9[0x1]
80003c38:	30 3a       	mov	r10,3
80003c3a:	f4 09 18 00 	cp.b	r9,r10
80003c3e:	e0 80 00 c6 	breq	80003dca <udc_process_setup+0x3da>
80003c42:	e0 8b 00 07 	brhi	80003c50 <udc_process_setup+0x260>
80003c46:	30 1a       	mov	r10,1
80003c48:	f4 09 18 00 	cp.b	r9,r10
80003c4c:	c6 91       	brne	80003d1e <udc_process_setup+0x32e>
80003c4e:	c1 78       	rjmp	80003c7c <udc_process_setup+0x28c>
80003c50:	30 5a       	mov	r10,5
80003c52:	f4 09 18 00 	cp.b	r9,r10
80003c56:	c0 60       	breq	80003c62 <udc_process_setup+0x272>
80003c58:	30 9a       	mov	r10,9
80003c5a:	f4 09 18 00 	cp.b	r9,r10
80003c5e:	c6 01       	brne	80003d1e <udc_process_setup+0x32e>
80003c60:	c2 28       	rjmp	80003ca4 <udc_process_setup+0x2b4>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003c62:	4f 48       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003c64:	90 39       	ld.sh	r9,r8[0x6]
80003c66:	30 08       	mov	r8,0
80003c68:	f0 09 19 00 	cp.h	r9,r8
80003c6c:	c0 30       	breq	80003c72 <udc_process_setup+0x282>
80003c6e:	30 0c       	mov	r12,0
80003c70:	ca e8       	rjmp	80003dcc <udc_process_setup+0x3dc>
		return false;

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80003c72:	4f e9       	lddpc	r9,80003e68 <udc_process_setup+0x478>
80003c74:	4e f8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003c76:	91 49       	st.w	r8[0x10],r9
80003c78:	30 1c       	mov	r12,1
80003c7a:	ca 98       	rjmp	80003dcc <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003c7c:	4e d8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003c7e:	90 39       	ld.sh	r9,r8[0x6]
80003c80:	30 08       	mov	r8,0
80003c82:	f0 09 19 00 	cp.h	r9,r8
80003c86:	c0 d1       	brne	80003ca0 <udc_process_setup+0x2b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80003c88:	4e a8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003c8a:	90 19       	ld.sh	r9,r8[0x2]
80003c8c:	30 18       	mov	r8,1
80003c8e:	f0 09 19 00 	cp.h	r9,r8
80003c92:	c0 71       	brne	80003ca0 <udc_process_setup+0x2b0>
		udc_device_status &= CPU_TO_LE16(~USB_DEV_STATUS_REMOTEWAKEUP);
80003c94:	4e 88       	lddpc	r8,80003e34 <udc_process_setup+0x444>
80003c96:	90 09       	ld.sh	r9,r8[0x0]
80003c98:	a9 d9       	cbr	r9,0x9
80003c9a:	b0 09       	st.h	r8[0x0],r9
80003c9c:	30 1c       	mov	r12,1
80003c9e:	c9 78       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003ca0:	30 0c       	mov	r12,0
80003ca2:	c9 58       	rjmp	80003dcc <udc_process_setup+0x3dc>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength != 0)
80003ca4:	4e 38       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003ca6:	90 39       	ld.sh	r9,r8[0x6]
80003ca8:	30 08       	mov	r8,0
80003caa:	f0 09 19 00 	cp.h	r9,r8
80003cae:	c3 41       	brne	80003d16 <udc_process_setup+0x326>
		return false;
	// Authorize configuration only if the address is valid
	if (!udd_getaddress())
80003cb0:	f0 1f 00 6f 	mcall	80003e6c <udc_process_setup+0x47c>
80003cb4:	c3 10       	breq	80003d16 <udc_process_setup+0x326>
			return false;
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80003cb6:	4d f8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003cb8:	11 b9       	ld.ub	r9,r8[0x3]
80003cba:	4e 18       	lddpc	r8,80003e3c <udc_process_setup+0x44c>
80003cbc:	70 08       	ld.w	r8,r8[0x0]
80003cbe:	f1 38 00 11 	ld.ub	r8,r8[17]
80003cc2:	10 39       	cp.w	r9,r8
80003cc4:	e0 89 00 29 	brgt	80003d16 <udc_process_setup+0x326>
				udc_config.confdev_lsfs->bNumConfigurations)
			return false;
	}

	// Reset current configuration
	udc_reset();
80003cc8:	f0 1f 00 6a 	mcall	80003e70 <udc_process_setup+0x480>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80003ccc:	4d 98       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003cce:	11 b8       	ld.ub	r8,r8[0x3]
80003cd0:	4e 09       	lddpc	r9,80003e50 <udc_process_setup+0x460>
80003cd2:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80003cd4:	58 08       	cp.w	r8,0
80003cd6:	c2 20       	breq	80003d1a <udc_process_setup+0x32a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80003cd8:	20 18       	sub	r8,1
80003cda:	4d 99       	lddpc	r9,80003e3c <udc_process_setup+0x44c>
80003cdc:	72 19       	ld.w	r9,r9[0x4]
80003cde:	f2 08 00 38 	add	r8,r9,r8<<0x3
80003ce2:	4d d9       	lddpc	r9,80003e54 <udc_process_setup+0x464>
80003ce4:	93 08       	st.w	r9[0x0],r8
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003ce6:	70 08       	ld.w	r8,r8[0x0]
80003ce8:	11 c9       	ld.ub	r9,r8[0x4]
80003cea:	30 08       	mov	r8,0
80003cec:	f0 09 18 00 	cp.b	r9,r8
80003cf0:	c1 50       	breq	80003d1a <udc_process_setup+0x32a>
80003cf2:	30 07       	mov	r7,0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003cf4:	0e 95       	mov	r5,r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003cf6:	4d 86       	lddpc	r6,80003e54 <udc_process_setup+0x464>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003cf8:	0a 9b       	mov	r11,r5
80003cfa:	0e 9c       	mov	r12,r7
80003cfc:	f0 1f 00 5e 	mcall	80003e74 <udc_process_setup+0x484>
80003d00:	c0 b0       	breq	80003d16 <udc_process_setup+0x326>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80003d02:	2f f7       	sub	r7,-1
80003d04:	5c 57       	castu.b	r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d06:	6c 08       	ld.w	r8,r6[0x0]
80003d08:	70 08       	ld.w	r8,r8[0x0]
80003d0a:	11 c8       	ld.ub	r8,r8[0x4]
80003d0c:	ee 08 18 00 	cp.b	r8,r7
80003d10:	fe 9b ff f4 	brhi	80003cf8 <udc_process_setup+0x308>
80003d14:	c0 38       	rjmp	80003d1a <udc_process_setup+0x32a>
80003d16:	30 0c       	mov	r12,0
80003d18:	c5 a8       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003d1a:	30 1c       	mov	r12,1
80003d1c:	c5 88       	rjmp	80003dcc <udc_process_setup+0x3dc>
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003d1e:	58 18       	cp.w	r8,1
80003d20:	c2 21       	brne	80003d64 <udc_process_setup+0x374>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003d22:	4c 49       	lddpc	r9,80003e30 <udc_process_setup+0x440>
80003d24:	13 9a       	ld.ub	r10,r9[0x1]
80003d26:	30 b9       	mov	r9,11
80003d28:	f2 0a 18 00 	cp.b	r10,r9
80003d2c:	c1 c1       	brne	80003d64 <udc_process_setup+0x374>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength != 0)
80003d2e:	4c 18       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003d30:	90 39       	ld.sh	r9,r8[0x6]
80003d32:	30 08       	mov	r8,0
80003d34:	f0 09 19 00 	cp.h	r9,r8
80003d38:	c1 41       	brne	80003d60 <udc_process_setup+0x370>
		return false;	// Error in request
	if (!udc_num_configuration)
80003d3a:	4c 68       	lddpc	r8,80003e50 <udc_process_setup+0x460>
80003d3c:	11 89       	ld.ub	r9,r8[0x0]
80003d3e:	30 08       	mov	r8,0
80003d40:	f0 09 18 00 	cp.b	r9,r8
80003d44:	c0 e0       	breq	80003d60 <udc_process_setup+0x370>
		return false;	// The device is not is configured state yet


	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80003d46:	4b b8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003d48:	90 16       	ld.sh	r6,r8[0x2]

	// Disable current setting
	if (!udc_iface_disable(iface_num))
80003d4a:	11 d7       	ld.ub	r7,r8[0x5]
80003d4c:	0e 9c       	mov	r12,r7
80003d4e:	f0 1f 00 4b 	mcall	80003e78 <udc_process_setup+0x488>
80003d52:	c0 70       	breq	80003d60 <udc_process_setup+0x370>
		return false;

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80003d54:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003d58:	0e 9c       	mov	r12,r7
80003d5a:	f0 1f 00 47 	mcall	80003e74 <udc_process_setup+0x484>
80003d5e:	c3 78       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003d60:	30 0c       	mov	r12,0
80003d62:	c3 58       	rjmp	80003dcc <udc_process_setup+0x3dc>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003d64:	58 28       	cp.w	r8,2
80003d66:	c3 71       	brne	80003dd4 <udc_process_setup+0x3e4>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003d68:	4b 28       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003d6a:	11 98       	ld.ub	r8,r8[0x1]
80003d6c:	30 19       	mov	r9,1
80003d6e:	f2 08 18 00 	cp.b	r8,r9
80003d72:	c0 60       	breq	80003d7e <udc_process_setup+0x38e>
80003d74:	30 39       	mov	r9,3
80003d76:	f2 08 18 00 	cp.b	r8,r9
80003d7a:	c2 81       	brne	80003dca <udc_process_setup+0x3da>
80003d7c:	c1 48       	rjmp	80003da4 <udc_process_setup+0x3b4>
 *
 * \return true if success 
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003d7e:	4a d8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003d80:	90 39       	ld.sh	r9,r8[0x6]
80003d82:	30 08       	mov	r8,0
80003d84:	f0 09 19 00 	cp.h	r9,r8
80003d88:	c0 c1       	brne	80003da0 <udc_process_setup+0x3b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003d8a:	4a a8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003d8c:	90 19       	ld.sh	r9,r8[0x2]
80003d8e:	30 08       	mov	r8,0
80003d90:	f0 09 19 00 	cp.h	r9,r8
80003d94:	c0 61       	brne	80003da0 <udc_process_setup+0x3b0>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003d96:	4a 78       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003d98:	11 dc       	ld.ub	r12,r8[0x5]
80003d9a:	f0 1f 00 39 	mcall	80003e7c <udc_process_setup+0x48c>
80003d9e:	c1 78       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003da0:	30 0c       	mov	r12,0
80003da2:	c1 58       	rjmp	80003dcc <udc_process_setup+0x3dc>
 * \return true if success 
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_epset_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003da4:	4a 38       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003da6:	90 39       	ld.sh	r9,r8[0x6]
80003da8:	30 08       	mov	r8,0
80003daa:	f0 09 19 00 	cp.h	r9,r8
80003dae:	c0 c1       	brne	80003dc6 <udc_process_setup+0x3d6>
		return false;
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003db0:	4a 08       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003db2:	90 19       	ld.sh	r9,r8[0x2]
80003db4:	30 08       	mov	r8,0
80003db6:	f0 09 19 00 	cp.h	r9,r8
80003dba:	c0 61       	brne	80003dc6 <udc_process_setup+0x3d6>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003dbc:	49 d8       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003dbe:	11 dc       	ld.ub	r12,r8[0x5]
80003dc0:	f0 1f 00 30 	mcall	80003e80 <udc_process_setup+0x490>
80003dc4:	c0 48       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003dc6:	30 0c       	mov	r12,0
80003dc8:	c0 28       	rjmp	80003dcc <udc_process_setup+0x3dc>
80003dca:	30 0c       	mov	r12,0
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd())
80003dcc:	58 0c       	cp.w	r12,0
80003dce:	c0 30       	breq	80003dd4 <udc_process_setup+0x3e4>
80003dd0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
			return true;
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
80003dd4:	49 78       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003dd6:	11 88       	ld.ub	r8,r8[0x0]
80003dd8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ddc:	58 18       	cp.w	r8,1
80003dde:	c2 71       	brne	80003e2c <udc_process_setup+0x43c>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration)
80003de0:	49 c8       	lddpc	r8,80003e50 <udc_process_setup+0x460>
80003de2:	11 89       	ld.ub	r9,r8[0x0]
80003de4:	30 08       	mov	r8,0
80003de6:	f0 09 18 00 	cp.b	r9,r8
80003dea:	c2 10       	breq	80003e2c <udc_process_setup+0x43c>
		return false;	// The device is not is configured state yet
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003dec:	49 18       	lddpc	r8,80003e30 <udc_process_setup+0x440>
80003dee:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003df0:	49 98       	lddpc	r8,80003e54 <udc_process_setup+0x464>
80003df2:	70 08       	ld.w	r8,r8[0x0]
80003df4:	70 08       	ld.w	r8,r8[0x0]
80003df6:	11 c8       	ld.ub	r8,r8[0x4]
80003df8:	ee 08 18 00 	cp.b	r8,r7
80003dfc:	e0 88 00 18 	brls	80003e2c <udc_process_setup+0x43c>
		return false;

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003e00:	0e 96       	mov	r6,r7
80003e02:	30 0b       	mov	r11,0
80003e04:	0e 9c       	mov	r12,r7
80003e06:	f0 1f 00 15 	mcall	80003e58 <udc_process_setup+0x468>
80003e0a:	c1 10       	breq	80003e2c <udc_process_setup+0x43c>
		return false;
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003e0c:	49 28       	lddpc	r8,80003e54 <udc_process_setup+0x464>
80003e0e:	70 08       	ld.w	r8,r8[0x0]
80003e10:	70 18       	ld.w	r8,r8[0x4]
80003e12:	f0 07 03 27 	ld.w	r7,r8[r7<<0x2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003e16:	6e 3c       	ld.w	r12,r7[0xc]
80003e18:	5d 1c       	icall	r12
80003e1a:	18 9b       	mov	r11,r12
80003e1c:	0c 9c       	mov	r12,r6
80003e1e:	f0 1f 00 0f 	mcall	80003e58 <udc_process_setup+0x468>
80003e22:	c0 50       	breq	80003e2c <udc_process_setup+0x43c>
		return false;

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80003e24:	6e 2c       	ld.w	r12,r7[0x8]
80003e26:	5d 1c       	icall	r12
80003e28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e2c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003e30:	00 00       	add	r0,r0
80003e32:	0a 10       	sub	r0,r5
80003e34:	00 00       	add	r0,r0
80003e36:	08 8c       	andn	r12,r4
80003e38:	80 00       	ld.sh	r0,r0[0x0]
80003e3a:	23 c8       	sub	r8,60
80003e3c:	00 00       	add	r0,r0
80003e3e:	00 a4       	st.w	r0++,r4
80003e40:	00 00       	add	r0,r0
80003e42:	00 c0       	st.b	r0++,r0
80003e44:	00 00       	add	r0,r0
80003e46:	00 e4       	st.h	--r0,r4
80003e48:	00 00       	add	r0,r0
80003e4a:	00 c4       	st.b	r0++,r4
80003e4c:	00 00       	add	r0,r0
80003e4e:	00 d0       	st.w	--r0,r0
80003e50:	00 00       	add	r0,r0
80003e52:	08 8e       	andn	lr,r4
80003e54:	00 00       	add	r0,r0
80003e56:	08 88       	andn	r8,r4
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	37 e0       	mov	r0,126
80003e5c:	00 00       	add	r0,r0
80003e5e:	08 84       	andn	r4,r4
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	23 d4       	sub	r4,61
80003e64:	00 00       	add	r0,r0
80003e66:	08 90       	mov	r0,r4
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	38 b4       	mov	r4,-117
80003e6c:	80 00       	ld.sh	r0,r0[0x0]
80003e6e:	23 a2       	sub	r2,58
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	39 90       	mov	r0,-103
80003e74:	80 00       	ld.sh	r0,r0[0x0]
80003e76:	38 cc       	mov	r12,-116
80003e78:	80 00       	ld.sh	r0,r0[0x0]
80003e7a:	39 2c       	mov	r12,-110
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	24 64       	sub	r4,70
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	23 e8       	sub	r8,62

80003e84 <_read>:
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80003e84:	eb cd 40 fc 	pushm	r2-r7,lr
80003e88:	20 1d       	sub	sp,4
80003e8a:	16 94       	mov	r4,r11
80003e8c:	14 95       	mov	r5,r10
	int nChars = 0;

	if (file != 0)
80003e8e:	58 0c       	cp.w	r12,0
80003e90:	c0 30       	breq	80003e96 <_read+0x12>
80003e92:	3f f7       	mov	r7,-1
80003e94:	c1 98       	rjmp	80003ec6 <_read+0x42>
		return -1;

	for (; len > 0; --len) {
80003e96:	58 0a       	cp.w	r10,0
80003e98:	e0 89 00 04 	brgt	80003ea0 <_read+0x1c>
80003e9c:	30 07       	mov	r7,0
80003e9e:	c1 48       	rjmp	80003ec6 <_read+0x42>
80003ea0:	30 07       	mov	r7,0
		int c;
		ptr_get(stdio_base,&c);
80003ea2:	48 c3       	lddpc	r3,80003ed0 <_read+0x4c>
80003ea4:	48 c6       	lddpc	r6,80003ed4 <_read+0x50>
80003ea6:	1a 92       	mov	r2,sp
80003ea8:	66 0c       	ld.w	r12,r3[0x0]
80003eaa:	6c 08       	ld.w	r8,r6[0x0]
80003eac:	1a 9b       	mov	r11,sp
80003eae:	5d 18       	icall	r8
		if (c < 0)
80003eb0:	40 08       	lddsp	r8,sp[0x0]
80003eb2:	58 08       	cp.w	r8,0
80003eb4:	c0 95       	brlt	80003ec6 <_read+0x42>
		break;
		*ptr++ = c;
80003eb6:	e8 07 0b 08 	st.b	r4[r7],r8
		++nChars;
80003eba:	2f f7       	sub	r7,-1
// GCC AVR32 implementation
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
80003ebc:	ea 07 01 08 	sub	r8,r5,r7
	int nChars = 0;

	if (file != 0)
		return -1;

	for (; len > 0; --len) {
80003ec0:	58 08       	cp.w	r8,0
80003ec2:	fe 99 ff f3 	brgt	80003ea8 <_read+0x24>
		break;
		*ptr++ = c;
		++nChars;
	}
	return nChars;
}
80003ec6:	0e 9c       	mov	r12,r7
80003ec8:	2f fd       	sub	sp,-4
80003eca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003ece:	00 00       	add	r0,r0
80003ed0:	00 00       	add	r0,r0
80003ed2:	0a 38       	cp.w	r8,r5
80003ed4:	00 00       	add	r0,r0
80003ed6:	0a 30       	cp.w	r0,r5

80003ed8 <stdio_usb_enable>:
	}
}

bool stdio_usb_enable(void)
{
	stdio_usb_interface_enable = true;
80003ed8:	30 19       	mov	r9,1
80003eda:	48 28       	lddpc	r8,80003ee0 <stdio_usb_enable+0x8>
80003edc:	b0 89       	st.b	r8[0x0],r9
	return true;
}
80003ede:	5e ff       	retal	1
80003ee0:	00 00       	add	r0,r0
80003ee2:	08 98       	mov	r8,r4

80003ee4 <stdio_usb_disable>:

void stdio_usb_disable(void)
{
	stdio_usb_interface_enable = false;
80003ee4:	30 09       	mov	r9,0
80003ee6:	48 28       	lddpc	r8,80003eec <stdio_usb_disable+0x8>
80003ee8:	b0 89       	st.b	r8[0x0],r9
}
80003eea:	5e fc       	retal	r12
80003eec:	00 00       	add	r0,r0
80003eee:	08 98       	mov	r8,r4

80003ef0 <stdio_usb_vbus_event>:
	
	*data = udi_cdc_getc ();
}

void stdio_usb_vbus_event(bool b_high)
{
80003ef0:	d4 01       	pushm	lr
	if (b_high) {
80003ef2:	58 0c       	cp.w	r12,0
80003ef4:	c0 40       	breq	80003efc <stdio_usb_vbus_event+0xc>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
80003ef6:	f0 1f 00 04 	mcall	80003f04 <stdio_usb_vbus_event+0x14>
80003efa:	d8 02       	popm	pc
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
80003efc:	f0 1f 00 03 	mcall	80003f08 <stdio_usb_vbus_event+0x18>
80003f00:	d8 02       	popm	pc
80003f02:	00 00       	add	r0,r0
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	2a 5c       	sub	r12,-91
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	27 0c       	sub	r12,112

80003f0c <stdio_usb_init>:
{
	stdio_usb_interface_enable = false;
}

void stdio_usb_init (volatile void * usart)
{
80003f0c:	d4 01       	pushm	lr
	stdio_base = usart;
80003f0e:	48 98       	lddpc	r8,80003f30 <stdio_usb_init+0x24>
80003f10:	91 0c       	st.w	r8[0x0],r12
	ptr_put = stdio_usb_putchar;
80003f12:	48 99       	lddpc	r9,80003f34 <stdio_usb_init+0x28>
80003f14:	48 98       	lddpc	r8,80003f38 <stdio_usb_init+0x2c>
80003f16:	91 09       	st.w	r8[0x0],r9
	ptr_get = stdio_usb_getchar;
80003f18:	48 99       	lddpc	r9,80003f3c <stdio_usb_init+0x30>
80003f1a:	48 a8       	lddpc	r8,80003f40 <stdio_usb_init+0x34>
80003f1c:	91 09       	st.w	r8[0x0],r9

/*! \brief Start the USB Device stack
 */
static inline void udc_start(void)
{
	udd_enable();
80003f1e:	f0 1f 00 0a 	mcall	80003f44 <stdio_usb_init+0x38>
 *        udc_attach(); \n
 *     }  \n
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
80003f22:	f0 1f 00 0a 	mcall	80003f48 <stdio_usb_init+0x3c>
	 * integrated USB interfaces.  Assume the VBUS is present if
	 * VBUS monitoring is not available.
	 */
	udc_start ();

	if (! udc_include_vbus_monitoring ()) {
80003f26:	c0 41       	brne	80003f2e <stdio_usb_init+0x22>
		stdio_usb_vbus_event (true);
80003f28:	30 1c       	mov	r12,1
80003f2a:	f0 1f 00 09 	mcall	80003f4c <stdio_usb_init+0x40>
80003f2e:	d8 02       	popm	pc
80003f30:	00 00       	add	r0,r0
80003f32:	0a 38       	cp.w	r8,r5
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	3f 7c       	mov	r12,-9
80003f38:	00 00       	add	r0,r0
80003f3a:	0a 34       	cp.w	r4,r5
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3f 50       	mov	r0,-11
80003f40:	00 00       	add	r0,r0
80003f42:	0a 30       	cp.w	r0,r5
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	2a cc       	sub	r12,-84
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	23 7c       	sub	r12,55
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	3e f0       	mov	r0,-17

80003f50 <stdio_usb_getchar>:

	return udi_cdc_putc (data) ? 0 : -1;
}

void stdio_usb_getchar (void volatile * usart, int * data)
{
80003f50:	eb cd 40 80 	pushm	r7,lr
80003f54:	16 97       	mov	r7,r11
	/* A negative return value should be used to indicate that data
	 * was not read, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003f56:	48 88       	lddpc	r8,80003f74 <stdio_usb_getchar+0x24>
80003f58:	11 89       	ld.ub	r9,r8[0x0]
80003f5a:	30 08       	mov	r8,0
80003f5c:	f0 09 18 00 	cp.b	r9,r8
80003f60:	c0 51       	brne	80003f6a <stdio_usb_getchar+0x1a>
		*data = 0;  // -1
80003f62:	30 08       	mov	r8,0
80003f64:	97 08       	st.w	r11[0x0],r8
		return;
80003f66:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	
	*data = udi_cdc_getc ();
80003f6a:	f0 1f 00 04 	mcall	80003f78 <stdio_usb_getchar+0x28>
80003f6e:	8f 0c       	st.w	r7[0x0],r12
80003f70:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f74:	00 00       	add	r0,r0
80003f76:	08 98       	mov	r8,r4
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	34 d4       	mov	r4,77

80003f7c <stdio_usb_putchar>:
#include "stdio_usb.h"

static bool stdio_usb_interface_enable = false;

int stdio_usb_putchar (volatile void * usart, int data)
{
80003f7c:	d4 01       	pushm	lr
	/* A negative return value should be used to indicate that data
	 * was not written, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003f7e:	48 78       	lddpc	r8,80003f98 <stdio_usb_putchar+0x1c>
80003f80:	11 89       	ld.ub	r9,r8[0x0]
80003f82:	30 08       	mov	r8,0
80003f84:	f0 09 18 00 	cp.b	r9,r8
80003f88:	c0 60       	breq	80003f94 <stdio_usb_putchar+0x18>
		return 0;  // -1
	}

	return udi_cdc_putc (data) ? 0 : -1;
80003f8a:	16 9c       	mov	r12,r11
80003f8c:	f0 1f 00 04 	mcall	80003f9c <stdio_usb_putchar+0x20>
80003f90:	c0 21       	brne	80003f94 <stdio_usb_putchar+0x18>
80003f92:	dc 0a       	popm	pc,r12=-1
80003f94:	d8 0a       	popm	pc,r12=0
80003f96:	00 00       	add	r0,r0
80003f98:	00 00       	add	r0,r0
80003f9a:	08 98       	mov	r8,r4
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	33 d4       	mov	r4,61

80003fa0 <_write>:

#elif (defined(__GNUC__) && !defined(XMEGA))

	int __attribute__((weak))
	_write (int file, char * ptr, int len)
	{
80003fa0:	eb cd 40 f8 	pushm	r3-r7,lr
80003fa4:	16 94       	mov	r4,r11
80003fa6:	14 95       	mov	r5,r10
		int nChars = 0;
	
		if ( (file != 1)
80003fa8:	20 1c       	sub	r12,1
80003faa:	58 2c       	cp.w	r12,2
80003fac:	e0 8b 00 13 	brhi	80003fd2 <_write+0x32>
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80003fb0:	58 0a       	cp.w	r10,0
80003fb2:	c0 31       	brne	80003fb8 <_write+0x18>
80003fb4:	30 07       	mov	r7,0
80003fb6:	c0 f8       	rjmp	80003fd4 <_write+0x34>
80003fb8:	30 07       	mov	r7,0
			if (ptr_put(stdio_base, *ptr++) < 0) {
80003fba:	48 93       	lddpc	r3,80003fdc <_write+0x3c>
80003fbc:	48 96       	lddpc	r6,80003fe0 <_write+0x40>
80003fbe:	66 0c       	ld.w	r12,r3[0x0]
80003fc0:	6c 08       	ld.w	r8,r6[0x0]
80003fc2:	e8 07 07 0b 	ld.ub	r11,r4[r7]
80003fc6:	5d 18       	icall	r8
80003fc8:	c0 55       	brlt	80003fd2 <_write+0x32>
				return -1;
			}
			++nChars;
80003fca:	2f f7       	sub	r7,-1
	
		if ( (file != 1)
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80003fcc:	0e 35       	cp.w	r5,r7
80003fce:	cf 81       	brne	80003fbe <_write+0x1e>
80003fd0:	c0 28       	rjmp	80003fd4 <_write+0x34>
80003fd2:	3f f7       	mov	r7,-1
				return -1;
			}
			++nChars;
		}
		return nChars;
	}
80003fd4:	0e 9c       	mov	r12,r7
80003fd6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003fda:	00 00       	add	r0,r0
80003fdc:	00 00       	add	r0,r0
80003fde:	0a 38       	cp.w	r8,r5
80003fe0:	00 00       	add	r0,r0
80003fe2:	0a 34       	cp.w	r4,r5

80003fe4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80003fe4:	f8 c8 ff f8 	sub	r8,r12,-8
80003fe8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80003fea:	3f f9       	mov	r9,-1
80003fec:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80003fee:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80003ff0:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80003ff2:	30 08       	mov	r8,0
80003ff4:	99 08       	st.w	r12[0x0],r8
}
80003ff6:	5e fc       	retal	r12

80003ff8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80003ff8:	30 08       	mov	r8,0
80003ffa:	99 48       	st.w	r12[0x10],r8
}
80003ffc:	5e fc       	retal	r12

80003ffe <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80003ffe:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004000:	70 19       	ld.w	r9,r8[0x4]
80004002:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004004:	78 19       	ld.w	r9,r12[0x4]
80004006:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004008:	70 19       	ld.w	r9,r8[0x4]
8000400a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000400c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000400e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004010:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004012:	78 08       	ld.w	r8,r12[0x0]
80004014:	2f f8       	sub	r8,-1
80004016:	99 08       	st.w	r12[0x0],r8
}
80004018:	5e fc       	retal	r12

8000401a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000401a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8000401c:	5b fa       	cp.w	r10,-1
8000401e:	c0 31       	brne	80004024 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004020:	78 48       	ld.w	r8,r12[0x10]
80004022:	c0 c8       	rjmp	8000403a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004024:	f8 c8 ff f8 	sub	r8,r12,-8
80004028:	70 19       	ld.w	r9,r8[0x4]
8000402a:	72 09       	ld.w	r9,r9[0x0]
8000402c:	12 3a       	cp.w	r10,r9
8000402e:	c0 63       	brcs	8000403a <vListInsert+0x20>
80004030:	70 18       	ld.w	r8,r8[0x4]
80004032:	70 19       	ld.w	r9,r8[0x4]
80004034:	72 09       	ld.w	r9,r9[0x0]
80004036:	12 3a       	cp.w	r10,r9
80004038:	cf c2       	brcc	80004030 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000403a:	70 19       	ld.w	r9,r8[0x4]
8000403c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000403e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004040:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004042:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004044:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004046:	78 08       	ld.w	r8,r12[0x0]
80004048:	2f f8       	sub	r8,-1
8000404a:	99 08       	st.w	r12[0x0],r8
}
8000404c:	5e fc       	retal	r12

8000404e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000404e:	78 18       	ld.w	r8,r12[0x4]
80004050:	78 29       	ld.w	r9,r12[0x8]
80004052:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004054:	78 28       	ld.w	r8,r12[0x8]
80004056:	78 19       	ld.w	r9,r12[0x4]
80004058:	91 19       	st.w	r8[0x4],r9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000405a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
8000405c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000405e:	18 39       	cp.w	r9,r12
80004060:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004064:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004068:	30 09       	mov	r9,0
8000406a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
8000406c:	70 09       	ld.w	r9,r8[0x0]
8000406e:	20 19       	sub	r9,1
80004070:	91 09       	st.w	r8[0x0],r9
}
80004072:	5e fc       	retal	r12

80004074 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004074:	e0 68 08 08 	mov	r8,2056
80004078:	ea 18 08 08 	orh	r8,0x808
8000407c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000407e:	e0 68 09 09 	mov	r8,2313
80004082:	ea 18 09 09 	orh	r8,0x909
80004086:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004088:	e0 68 0a 0a 	mov	r8,2570
8000408c:	ea 18 0a 0a 	orh	r8,0xa0a
80004090:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004092:	e0 68 0b 0b 	mov	r8,2827
80004096:	ea 18 0b 0b 	orh	r8,0xb0b
8000409a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000409c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000409e:	e0 68 be ef 	mov	r8,48879
800040a2:	ea 18 de ad 	orh	r8,0xdead
800040a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800040a8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800040aa:	fc 18 00 40 	movh	r8,0x40
800040ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800040b0:	e0 68 00 ff 	mov	r8,255
800040b4:	ea 18 ff 00 	orh	r8,0xff00
800040b8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800040ba:	e0 68 01 01 	mov	r8,257
800040be:	ea 18 01 01 	orh	r8,0x101
800040c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800040c4:	e0 68 02 02 	mov	r8,514
800040c8:	ea 18 02 02 	orh	r8,0x202
800040cc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800040ce:	e0 68 03 03 	mov	r8,771
800040d2:	ea 18 03 03 	orh	r8,0x303
800040d6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800040d8:	e0 68 04 04 	mov	r8,1028
800040dc:	ea 18 04 04 	orh	r8,0x404
800040e0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800040e2:	e0 68 05 05 	mov	r8,1285
800040e6:	ea 18 05 05 	orh	r8,0x505
800040ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800040ec:	e0 68 06 06 	mov	r8,1542
800040f0:	ea 18 06 06 	orh	r8,0x606
800040f4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800040f6:	e0 68 07 07 	mov	r8,1799
800040fa:	ea 18 07 07 	orh	r8,0x707
800040fe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004100:	30 08       	mov	r8,0
80004102:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004104:	5e fc       	retal	r12
80004106:	d7 03       	nop

80004108 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004108:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000410a:	48 38       	lddpc	r8,80004114 <vPortEnterCritical+0xc>
8000410c:	70 09       	ld.w	r9,r8[0x0]
8000410e:	2f f9       	sub	r9,-1
80004110:	91 09       	st.w	r8[0x0],r9
}
80004112:	5e fc       	retal	r12
80004114:	00 00       	add	r0,r0
80004116:	00 e8       	st.h	--r0,r8

80004118 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004118:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000411a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000411c:	30 0a       	mov	r10,0
8000411e:	14 9b       	mov	r11,r10
80004120:	49 2c       	lddpc	r12,80004168 <xPortStartScheduler+0x50>
80004122:	f0 1f 00 13 	mcall	8000416c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80004126:	e0 68 2e e0 	mov	r8,12000
8000412a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000412e:	30 08       	mov	r8,0
80004130:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004134:	e0 68 09 6c 	mov	r8,2412
80004138:	ea 18 00 00 	orh	r8,0x0
8000413c:	70 00       	ld.w	r0,r8[0x0]
8000413e:	60 0d       	ld.w	sp,r0[0x0]
80004140:	1b 00       	ld.w	r0,sp++
80004142:	e0 68 00 e8 	mov	r8,232
80004146:	ea 18 00 00 	orh	r8,0x0
8000414a:	91 00       	st.w	r8[0x0],r0
8000414c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004150:	2f ed       	sub	sp,-8
80004152:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004156:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000415a:	e3 b0 00 00 	mtsr	0x0,r0
8000415e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004162:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004166:	d8 0a       	popm	pc,r12=0
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	42 34       	lddsp	r4,sp[0x8c]
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	21 ec       	sub	r12,30

80004170 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004170:	20 6d       	sub	sp,24
80004172:	eb cd 00 ff 	pushm	r0-r7
80004176:	fa c7 ff c0 	sub	r7,sp,-64
8000417a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000417e:	ef 40 ff e0 	st.w	r7[-32],r0
80004182:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004186:	ef 40 ff e4 	st.w	r7[-28],r0
8000418a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000418e:	e0 68 00 e8 	mov	r8,232
80004192:	ea 18 00 00 	orh	r8,0x0
80004196:	70 00       	ld.w	r0,r8[0x0]
80004198:	1a d0       	st.w	--sp,r0
8000419a:	f0 1f 00 1a 	mcall	80004200 <LABEL_RET_SCALL_266+0x14>
8000419e:	e0 68 09 6c 	mov	r8,2412
800041a2:	ea 18 00 00 	orh	r8,0x0
800041a6:	70 00       	ld.w	r0,r8[0x0]
800041a8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800041aa:	f0 1f 00 17 	mcall	80004204 <LABEL_RET_SCALL_266+0x18>
	portRESTORE_CONTEXT_SCALL();
800041ae:	e0 68 09 6c 	mov	r8,2412
800041b2:	ea 18 00 00 	orh	r8,0x0
800041b6:	70 00       	ld.w	r0,r8[0x0]
800041b8:	60 0d       	ld.w	sp,r0[0x0]
800041ba:	1b 00       	ld.w	r0,sp++
800041bc:	e0 68 00 e8 	mov	r8,232
800041c0:	ea 18 00 00 	orh	r8,0x0
800041c4:	91 00       	st.w	r8[0x0],r0
800041c6:	fa c7 ff d8 	sub	r7,sp,-40
800041ca:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800041ce:	ee f0 ff e0 	ld.w	r0,r7[-32]
800041d2:	e0 61 00 e8 	mov	r1,232
800041d6:	ea 11 00 00 	orh	r1,0x0
800041da:	62 02       	ld.w	r2,r1[0x0]
800041dc:	58 02       	cp.w	r2,0
800041de:	c0 70       	breq	800041ec <LABEL_RET_SCALL_266>
800041e0:	e4 c2 00 01 	sub	r2,r2,1
800041e4:	83 02       	st.w	r1[0x0],r2
800041e6:	58 02       	cp.w	r2,0
800041e8:	c0 21       	brne	800041ec <LABEL_RET_SCALL_266>
800041ea:	b1 c0       	cbr	r0,0x10

800041ec <LABEL_RET_SCALL_266>:
800041ec:	ef 40 ff f8 	st.w	r7[-8],r0
800041f0:	ee f0 ff e4 	ld.w	r0,r7[-28]
800041f4:	ef 40 ff fc 	st.w	r7[-4],r0
800041f8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800041fc:	2f ad       	sub	sp,-24
800041fe:	d6 13       	rets
80004200:	80 00       	ld.sh	r0,r0[0x0]
80004202:	41 08       	lddsp	r8,sp[0x40]
80004204:	80 00       	ld.sh	r0,r0[0x0]
80004206:	43 48       	lddsp	r8,sp[0xd0]

80004208 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004208:	e1 b8 00 43 	mfsr	r8,0x10c
8000420c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004210:	5e fc       	retal	r12
80004212:	d7 03       	nop

80004214 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004214:	48 78       	lddpc	r8,80004230 <vPortExitCritical+0x1c>
80004216:	70 08       	ld.w	r8,r8[0x0]
80004218:	58 08       	cp.w	r8,0
8000421a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000421c:	48 58       	lddpc	r8,80004230 <vPortExitCritical+0x1c>
8000421e:	70 09       	ld.w	r9,r8[0x0]
80004220:	20 19       	sub	r9,1
80004222:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004224:	70 08       	ld.w	r8,r8[0x0]
80004226:	58 08       	cp.w	r8,0
80004228:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000422a:	d5 03       	csrf	0x10
8000422c:	5e fc       	retal	r12
8000422e:	00 00       	add	r0,r0
80004230:	00 00       	add	r0,r0
80004232:	00 e8       	st.h	--r0,r8

80004234 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004234:	eb cd 00 ff 	pushm	r0-r7
80004238:	e0 68 00 e8 	mov	r8,232
8000423c:	ea 18 00 00 	orh	r8,0x0
80004240:	70 00       	ld.w	r0,r8[0x0]
80004242:	1a d0       	st.w	--sp,r0
80004244:	7a 90       	ld.w	r0,sp[0x24]
80004246:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000424a:	58 10       	cp.w	r0,1
8000424c:	e0 8b 00 08 	brhi	8000425c <LABEL_INT_SKIP_SAVE_CONTEXT_240>
80004250:	e0 68 09 6c 	mov	r8,2412
80004254:	ea 18 00 00 	orh	r8,0x0
80004258:	70 00       	ld.w	r0,r8[0x0]
8000425a:	81 0d       	st.w	r0[0x0],sp

8000425c <LABEL_INT_SKIP_SAVE_CONTEXT_240>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000425c:	f0 1f 00 12 	mcall	800042a4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004260:	f0 1f 00 12 	mcall	800042a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
		vTaskIncrementTick();
80004264:	f0 1f 00 12 	mcall	800042ac <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x1c>
	portEXIT_CRITICAL();
80004268:	f0 1f 00 12 	mcall	800042b0 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000426c:	7a 90       	ld.w	r0,sp[0x24]
8000426e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004272:	58 10       	cp.w	r0,1
80004274:	e0 8b 00 0e 	brhi	80004290 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>
80004278:	f0 1f 00 0c 	mcall	800042a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
8000427c:	f0 1f 00 0e 	mcall	800042b4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x24>
80004280:	f0 1f 00 0c 	mcall	800042b0 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>
80004284:	e0 68 09 6c 	mov	r8,2412
80004288:	ea 18 00 00 	orh	r8,0x0
8000428c:	70 00       	ld.w	r0,r8[0x0]
8000428e:	60 0d       	ld.w	sp,r0[0x0]

80004290 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>:
80004290:	1b 00       	ld.w	r0,sp++
80004292:	e0 68 00 e8 	mov	r8,232
80004296:	ea 18 00 00 	orh	r8,0x0
8000429a:	91 00       	st.w	r8[0x0],r0
8000429c:	e3 cd 00 ff 	ldm	sp++,r0-r7
800042a0:	d6 03       	rete
800042a2:	00 00       	add	r0,r0
800042a4:	80 00       	ld.sh	r0,r0[0x0]
800042a6:	42 08       	lddsp	r8,sp[0x80]
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	41 08       	lddsp	r8,sp[0x40]
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	43 c4       	lddsp	r4,sp[0xf0]
800042b0:	80 00       	ld.sh	r0,r0[0x0]
800042b2:	42 14       	lddsp	r4,sp[0x84]
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	43 48       	lddsp	r8,sp[0xd0]

800042b8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800042b8:	d4 01       	pushm	lr
	vTaskSuspendAll();
800042ba:	f0 1f 00 02 	mcall	800042c0 <__malloc_lock+0x8>
}
800042be:	d8 02       	popm	pc
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	43 38       	lddsp	r8,sp[0xcc]

800042c4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800042c4:	d4 01       	pushm	lr
	xTaskResumeAll();
800042c6:	f0 1f 00 02 	mcall	800042cc <__malloc_unlock+0x8>
}
800042ca:	d8 02       	popm	pc
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	44 dc       	lddsp	r12,sp[0x134]

800042d0 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
800042d0:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
800042d2:	48 48       	lddpc	r8,800042e0 <_init_startup+0x10>
800042d4:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
800042d8:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
800042da:	f0 1f 00 03 	mcall	800042e4 <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
800042de:	da 0a       	popm	pc,r12=1
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	5a 00       	cp.w	r0,-32
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	22 1c       	sub	r12,33

800042e8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800042e8:	eb cd 40 80 	pushm	r7,lr
800042ec:	18 97       	mov	r7,r12
	if( pv )
800042ee:	58 0c       	cp.w	r12,0
800042f0:	c0 80       	breq	80004300 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800042f2:	f0 1f 00 05 	mcall	80004304 <vPortFree+0x1c>
		{
			free( pv );
800042f6:	0e 9c       	mov	r12,r7
800042f8:	f0 1f 00 04 	mcall	80004308 <vPortFree+0x20>
		}
		xTaskResumeAll();
800042fc:	f0 1f 00 04 	mcall	8000430c <vPortFree+0x24>
80004300:	e3 cd 80 80 	ldm	sp++,r7,pc
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	43 38       	lddsp	r8,sp[0xcc]
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	4a 30       	lddpc	r0,80004394 <vTaskSwitchContext+0x4c>
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	44 dc       	lddsp	r12,sp[0x134]

80004310 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004310:	eb cd 40 80 	pushm	r7,lr
80004314:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004316:	f0 1f 00 06 	mcall	8000432c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000431a:	0e 9c       	mov	r12,r7
8000431c:	f0 1f 00 05 	mcall	80004330 <pvPortMalloc+0x20>
80004320:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004322:	f0 1f 00 05 	mcall	80004334 <pvPortMalloc+0x24>
		}
	}
	#endif
	
	return pvReturn;
}
80004326:	0e 9c       	mov	r12,r7
80004328:	e3 cd 80 80 	ldm	sp++,r7,pc
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	43 38       	lddsp	r8,sp[0xcc]
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	4a 44       	lddpc	r4,800043c0 <vTaskSwitchContext+0x78>
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	44 dc       	lddsp	r12,sp[0x134]

80004338 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80004338:	48 38       	lddpc	r8,80004344 <vTaskSuspendAll+0xc>
8000433a:	70 09       	ld.w	r9,r8[0x0]
8000433c:	2f f9       	sub	r9,-1
8000433e:	91 09       	st.w	r8[0x0],r9
}
80004340:	5e fc       	retal	r12
80004342:	00 00       	add	r0,r0
80004344:	00 00       	add	r0,r0
80004346:	09 9c       	ld.ub	r12,r4[0x1]

80004348 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80004348:	49 a8       	lddpc	r8,800043b0 <vTaskSwitchContext+0x68>
8000434a:	70 08       	ld.w	r8,r8[0x0]
8000434c:	58 08       	cp.w	r8,0
8000434e:	c0 b1       	brne	80004364 <vTaskSwitchContext+0x1c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004350:	49 98       	lddpc	r8,800043b4 <vTaskSwitchContext+0x6c>
80004352:	70 08       	ld.w	r8,r8[0x0]
80004354:	f0 08 00 28 	add	r8,r8,r8<<0x2
80004358:	49 89       	lddpc	r9,800043b8 <vTaskSwitchContext+0x70>
8000435a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000435e:	58 08       	cp.w	r8,0
80004360:	c0 60       	breq	8000436c <vTaskSwitchContext+0x24>
80004362:	c1 18       	rjmp	80004384 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80004364:	30 19       	mov	r9,1
80004366:	49 68       	lddpc	r8,800043bc <vTaskSwitchContext+0x74>
80004368:	91 09       	st.w	r8[0x0],r9
8000436a:	5e fc       	retal	r12
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000436c:	49 28       	lddpc	r8,800043b4 <vTaskSwitchContext+0x6c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000436e:	49 3a       	lddpc	r10,800043b8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004370:	70 09       	ld.w	r9,r8[0x0]
80004372:	20 19       	sub	r9,1
80004374:	91 09       	st.w	r8[0x0],r9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004376:	70 09       	ld.w	r9,r8[0x0]
80004378:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000437c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80004380:	58 09       	cp.w	r9,0
80004382:	cf 70       	breq	80004370 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80004384:	48 c8       	lddpc	r8,800043b4 <vTaskSwitchContext+0x6c>
80004386:	70 08       	ld.w	r8,r8[0x0]
80004388:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000438c:	48 b9       	lddpc	r9,800043b8 <vTaskSwitchContext+0x70>
8000438e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004392:	70 19       	ld.w	r9,r8[0x4]
80004394:	72 19       	ld.w	r9,r9[0x4]
80004396:	91 19       	st.w	r8[0x4],r9
80004398:	f0 ca ff f8 	sub	r10,r8,-8
8000439c:	14 39       	cp.w	r9,r10
8000439e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800043a2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800043a6:	70 18       	ld.w	r8,r8[0x4]
800043a8:	70 39       	ld.w	r9,r8[0xc]
800043aa:	48 68       	lddpc	r8,800043c0 <vTaskSwitchContext+0x78>
800043ac:	91 09       	st.w	r8[0x0],r9
800043ae:	5e fc       	retal	r12
800043b0:	00 00       	add	r0,r0
800043b2:	09 9c       	ld.ub	r12,r4[0x1]
800043b4:	00 00       	add	r0,r0
800043b6:	09 d4       	ld.ub	r4,r4[0x5]
800043b8:	00 00       	add	r0,r0
800043ba:	08 b8       	st.h	r4++,r8
800043bc:	00 00       	add	r0,r0
800043be:	09 bc       	ld.ub	r12,r4[0x3]
800043c0:	00 00       	add	r0,r0
800043c2:	09 6c       	ld.uh	r12,--r4

800043c4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800043c4:	eb cd 40 fe 	pushm	r1-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800043c8:	4b a8       	lddpc	r8,800044b0 <vTaskIncrementTick+0xec>
800043ca:	70 08       	ld.w	r8,r8[0x0]
800043cc:	58 08       	cp.w	r8,0
800043ce:	c6 a1       	brne	800044a2 <vTaskIncrementTick+0xde>
	{
		++xTickCount;
800043d0:	4b 98       	lddpc	r8,800044b4 <vTaskIncrementTick+0xf0>
800043d2:	70 09       	ld.w	r9,r8[0x0]
800043d4:	2f f9       	sub	r9,-1
800043d6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800043d8:	70 08       	ld.w	r8,r8[0x0]
800043da:	58 08       	cp.w	r8,0
800043dc:	c1 a1       	brne	80004410 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
800043de:	4b 78       	lddpc	r8,800044b8 <vTaskIncrementTick+0xf4>
800043e0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800043e2:	4b 79       	lddpc	r9,800044bc <vTaskIncrementTick+0xf8>
800043e4:	72 0b       	ld.w	r11,r9[0x0]
800043e6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800043e8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800043ea:	4b 69       	lddpc	r9,800044c0 <vTaskIncrementTick+0xfc>
800043ec:	72 0a       	ld.w	r10,r9[0x0]
800043ee:	2f fa       	sub	r10,-1
800043f0:	93 0a       	st.w	r9[0x0],r10
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800043f2:	70 08       	ld.w	r8,r8[0x0]
800043f4:	70 08       	ld.w	r8,r8[0x0]
800043f6:	58 08       	cp.w	r8,0
800043f8:	c0 51       	brne	80004402 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set 
				xNextTaskUnblockTime to the maximum possible value so it is 
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until 
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800043fa:	3f f9       	mov	r9,-1
800043fc:	4b 28       	lddpc	r8,800044c4 <vTaskIncrementTick+0x100>
800043fe:	91 09       	st.w	r8[0x0],r9
80004400:	c0 88       	rjmp	80004410 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of 
				the item at the head of the delayed list.  This is the time at 
				which the task at the head of the delayed list should be removed 
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80004402:	4a e8       	lddpc	r8,800044b8 <vTaskIncrementTick+0xf4>
80004404:	70 08       	ld.w	r8,r8[0x0]
80004406:	70 38       	ld.w	r8,r8[0xc]
80004408:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000440a:	70 19       	ld.w	r9,r8[0x4]
8000440c:	4a e8       	lddpc	r8,800044c4 <vTaskIncrementTick+0x100>
8000440e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80004410:	4a 98       	lddpc	r8,800044b4 <vTaskIncrementTick+0xf0>
80004412:	70 09       	ld.w	r9,r8[0x0]
80004414:	4a c8       	lddpc	r8,800044c4 <vTaskIncrementTick+0x100>
80004416:	70 08       	ld.w	r8,r8[0x0]
80004418:	10 39       	cp.w	r9,r8
8000441a:	c4 83       	brcs	800044aa <vTaskIncrementTick+0xe6>
8000441c:	4a 78       	lddpc	r8,800044b8 <vTaskIncrementTick+0xf4>
8000441e:	70 08       	ld.w	r8,r8[0x0]
80004420:	70 08       	ld.w	r8,r8[0x0]
80004422:	58 08       	cp.w	r8,0
80004424:	c0 c0       	breq	8000443c <vTaskIncrementTick+0x78>
80004426:	4a 58       	lddpc	r8,800044b8 <vTaskIncrementTick+0xf4>
80004428:	70 08       	ld.w	r8,r8[0x0]
8000442a:	70 38       	ld.w	r8,r8[0xc]
8000442c:	70 37       	ld.w	r7,r8[0xc]
8000442e:	6e 18       	ld.w	r8,r7[0x4]
80004430:	4a 19       	lddpc	r9,800044b4 <vTaskIncrementTick+0xf0>
80004432:	72 09       	ld.w	r9,r9[0x0]
80004434:	12 38       	cp.w	r8,r9
80004436:	e0 88 00 14 	brls	8000445e <vTaskIncrementTick+0x9a>
8000443a:	c0 e8       	rjmp	80004456 <vTaskIncrementTick+0x92>
8000443c:	3f f9       	mov	r9,-1
8000443e:	4a 28       	lddpc	r8,800044c4 <vTaskIncrementTick+0x100>
80004440:	91 09       	st.w	r8[0x0],r9
80004442:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004446:	6a 08       	ld.w	r8,r5[0x0]
80004448:	70 38       	ld.w	r8,r8[0xc]
8000444a:	70 37       	ld.w	r7,r8[0xc]
8000444c:	6e 18       	ld.w	r8,r7[0x4]
8000444e:	64 09       	ld.w	r9,r2[0x0]
80004450:	12 38       	cp.w	r8,r9
80004452:	e0 88 00 0b 	brls	80004468 <vTaskIncrementTick+0xa4>
80004456:	49 c9       	lddpc	r9,800044c4 <vTaskIncrementTick+0x100>
80004458:	93 08       	st.w	r9[0x0],r8
8000445a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000445e:	49 b4       	lddpc	r4,800044c8 <vTaskIncrementTick+0x104>
80004460:	08 91       	mov	r1,r4
80004462:	49 b3       	lddpc	r3,800044cc <vTaskIncrementTick+0x108>
80004464:	49 55       	lddpc	r5,800044b8 <vTaskIncrementTick+0xf4>
80004466:	49 42       	lddpc	r2,800044b4 <vTaskIncrementTick+0xf0>
80004468:	ee c6 ff fc 	sub	r6,r7,-4
8000446c:	0c 9c       	mov	r12,r6
8000446e:	f0 1f 00 19 	mcall	800044d0 <vTaskIncrementTick+0x10c>
80004472:	6e a8       	ld.w	r8,r7[0x28]
80004474:	58 08       	cp.w	r8,0
80004476:	c0 50       	breq	80004480 <vTaskIncrementTick+0xbc>
80004478:	ee cc ff e8 	sub	r12,r7,-24
8000447c:	f0 1f 00 15 	mcall	800044d0 <vTaskIncrementTick+0x10c>
80004480:	6e bc       	ld.w	r12,r7[0x2c]
80004482:	68 08       	ld.w	r8,r4[0x0]
80004484:	10 3c       	cp.w	r12,r8
80004486:	e3 fc ba 00 	st.whi	r1[0x0],r12
8000448a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000448e:	0c 9b       	mov	r11,r6
80004490:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80004494:	f0 1f 00 10 	mcall	800044d4 <vTaskIncrementTick+0x110>
80004498:	6a 08       	ld.w	r8,r5[0x0]
8000449a:	70 08       	ld.w	r8,r8[0x0]
8000449c:	58 08       	cp.w	r8,0
8000449e:	cd 41       	brne	80004446 <vTaskIncrementTick+0x82>
800044a0:	cc eb       	rjmp	8000443c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800044a2:	48 e8       	lddpc	r8,800044d8 <vTaskIncrementTick+0x114>
800044a4:	70 09       	ld.w	r9,r8[0x0]
800044a6:	2f f9       	sub	r9,-1
800044a8:	91 09       	st.w	r8[0x0],r9
800044aa:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	09 9c       	ld.ub	r12,r4[0x1]
800044b4:	00 00       	add	r0,r0
800044b6:	09 98       	ld.ub	r8,r4[0x1]
800044b8:	00 00       	add	r0,r0
800044ba:	08 a4       	st.w	r4++,r4
800044bc:	00 00       	add	r0,r0
800044be:	08 b4       	st.h	r4++,r4
800044c0:	00 00       	add	r0,r0
800044c2:	08 b0       	st.h	r4++,r0
800044c4:	00 00       	add	r0,r0
800044c6:	00 ec       	st.h	--r0,r12
800044c8:	00 00       	add	r0,r0
800044ca:	09 d4       	ld.ub	r4,r4[0x5]
800044cc:	00 00       	add	r0,r0
800044ce:	08 b8       	st.h	r4++,r8
800044d0:	80 00       	ld.sh	r0,r0[0x0]
800044d2:	40 4e       	lddsp	lr,sp[0x10]
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	3f fe       	mov	lr,-1
800044d8:	00 00       	add	r0,r0
800044da:	08 9c       	mov	r12,r4

800044dc <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800044dc:	d4 31       	pushm	r0-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800044de:	f0 1f 00 2c 	mcall	8000458c <xTaskResumeAll+0xb0>
	{
		--uxSchedulerSuspended;
800044e2:	4a c8       	lddpc	r8,80004590 <xTaskResumeAll+0xb4>
800044e4:	70 09       	ld.w	r9,r8[0x0]
800044e6:	20 19       	sub	r9,1
800044e8:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800044ea:	70 08       	ld.w	r8,r8[0x0]
800044ec:	58 08       	cp.w	r8,0
800044ee:	c4 a1       	brne	80004582 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800044f0:	4a 98       	lddpc	r8,80004594 <xTaskResumeAll+0xb8>
800044f2:	70 08       	ld.w	r8,r8[0x0]
800044f4:	58 08       	cp.w	r8,0
800044f6:	c4 60       	breq	80004582 <xTaskResumeAll+0xa6>
800044f8:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800044fa:	4a 85       	lddpc	r5,80004598 <xTaskResumeAll+0xbc>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800044fc:	4a 83       	lddpc	r3,8000459c <xTaskResumeAll+0xc0>
800044fe:	06 90       	mov	r0,r3
80004500:	4a 82       	lddpc	r2,800045a0 <xTaskResumeAll+0xc4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004502:	4a 91       	lddpc	r1,800045a4 <xTaskResumeAll+0xc8>
80004504:	c1 e8       	rjmp	80004540 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80004506:	6a 38       	ld.w	r8,r5[0xc]
80004508:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000450a:	ee cc ff e8 	sub	r12,r7,-24
8000450e:	f0 1f 00 27 	mcall	800045a8 <xTaskResumeAll+0xcc>
					vListRemove( &( pxTCB->xGenericListItem ) );
80004512:	ee c6 ff fc 	sub	r6,r7,-4
80004516:	0c 9c       	mov	r12,r6
80004518:	f0 1f 00 24 	mcall	800045a8 <xTaskResumeAll+0xcc>
					prvAddTaskToReadyQueue( pxTCB );
8000451c:	6e bc       	ld.w	r12,r7[0x2c]
8000451e:	66 08       	ld.w	r8,r3[0x0]
80004520:	10 3c       	cp.w	r12,r8
80004522:	e1 fc ba 00 	st.whi	r0[0x0],r12
80004526:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000452a:	0c 9b       	mov	r11,r6
8000452c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80004530:	f0 1f 00 1f 	mcall	800045ac <xTaskResumeAll+0xd0>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004534:	62 08       	ld.w	r8,r1[0x0]
80004536:	6e b9       	ld.w	r9,r7[0x2c]
80004538:	70 b8       	ld.w	r8,r8[0x2c]
8000453a:	10 39       	cp.w	r9,r8
8000453c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004540:	6a 08       	ld.w	r8,r5[0x0]
80004542:	58 08       	cp.w	r8,0
80004544:	ce 11       	brne	80004506 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004546:	49 b8       	lddpc	r8,800045b0 <xTaskResumeAll+0xd4>
80004548:	70 08       	ld.w	r8,r8[0x0]
8000454a:	58 08       	cp.w	r8,0
8000454c:	c0 f0       	breq	8000456a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000454e:	49 98       	lddpc	r8,800045b0 <xTaskResumeAll+0xd4>
80004550:	70 08       	ld.w	r8,r8[0x0]
80004552:	58 08       	cp.w	r8,0
80004554:	c1 10       	breq	80004576 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80004556:	49 77       	lddpc	r7,800045b0 <xTaskResumeAll+0xd4>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80004558:	f0 1f 00 17 	mcall	800045b4 <xTaskResumeAll+0xd8>
						--uxMissedTicks;
8000455c:	6e 08       	ld.w	r8,r7[0x0]
8000455e:	20 18       	sub	r8,1
80004560:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004562:	6e 08       	ld.w	r8,r7[0x0]
80004564:	58 08       	cp.w	r8,0
80004566:	cf 91       	brne	80004558 <xTaskResumeAll+0x7c>
80004568:	c0 78       	rjmp	80004576 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000456a:	58 14       	cp.w	r4,1
8000456c:	c0 50       	breq	80004576 <xTaskResumeAll+0x9a>
8000456e:	49 38       	lddpc	r8,800045b8 <xTaskResumeAll+0xdc>
80004570:	70 08       	ld.w	r8,r8[0x0]
80004572:	58 18       	cp.w	r8,1
80004574:	c0 71       	brne	80004582 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80004576:	30 09       	mov	r9,0
80004578:	49 08       	lddpc	r8,800045b8 <xTaskResumeAll+0xdc>
8000457a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000457c:	d7 33       	scall
8000457e:	30 17       	mov	r7,1
80004580:	c0 28       	rjmp	80004584 <xTaskResumeAll+0xa8>
80004582:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80004584:	f0 1f 00 0e 	mcall	800045bc <xTaskResumeAll+0xe0>

	return xAlreadyYielded;
}
80004588:	0e 9c       	mov	r12,r7
8000458a:	d8 32       	popm	r0-r7,pc
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	41 08       	lddsp	r8,sp[0x40]
80004590:	00 00       	add	r0,r0
80004592:	09 9c       	ld.ub	r12,r4[0x1]
80004594:	00 00       	add	r0,r0
80004596:	09 b8       	ld.ub	r8,r4[0x3]
80004598:	00 00       	add	r0,r0
8000459a:	09 70       	ld.ub	r0,--r4
8000459c:	00 00       	add	r0,r0
8000459e:	09 d4       	ld.ub	r4,r4[0x5]
800045a0:	00 00       	add	r0,r0
800045a2:	08 b8       	st.h	r4++,r8
800045a4:	00 00       	add	r0,r0
800045a6:	09 6c       	ld.uh	r12,--r4
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	40 4e       	lddsp	lr,sp[0x10]
800045ac:	80 00       	ld.sh	r0,r0[0x0]
800045ae:	3f fe       	mov	lr,-1
800045b0:	00 00       	add	r0,r0
800045b2:	08 9c       	mov	r12,r4
800045b4:	80 00       	ld.sh	r0,r0[0x0]
800045b6:	43 c4       	lddsp	r4,sp[0xf0]
800045b8:	00 00       	add	r0,r0
800045ba:	09 bc       	ld.ub	r12,r4[0x3]
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	42 14       	lddsp	r4,sp[0x84]

800045c0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800045c0:	eb cd 40 80 	pushm	r7,lr
800045c4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800045c6:	49 08       	lddpc	r8,80004604 <prvAddCurrentTaskToDelayedList+0x44>
800045c8:	70 08       	ld.w	r8,r8[0x0]
800045ca:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800045cc:	48 f8       	lddpc	r8,80004608 <prvAddCurrentTaskToDelayedList+0x48>
800045ce:	70 08       	ld.w	r8,r8[0x0]
800045d0:	10 3c       	cp.w	r12,r8
800045d2:	c0 a2       	brcc	800045e6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800045d4:	48 c8       	lddpc	r8,80004604 <prvAddCurrentTaskToDelayedList+0x44>
800045d6:	70 0b       	ld.w	r11,r8[0x0]
800045d8:	48 d8       	lddpc	r8,8000460c <prvAddCurrentTaskToDelayedList+0x4c>
800045da:	70 0c       	ld.w	r12,r8[0x0]
800045dc:	2f cb       	sub	r11,-4
800045de:	f0 1f 00 0d 	mcall	80004610 <prvAddCurrentTaskToDelayedList+0x50>
800045e2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800045e6:	48 88       	lddpc	r8,80004604 <prvAddCurrentTaskToDelayedList+0x44>
800045e8:	70 0b       	ld.w	r11,r8[0x0]
800045ea:	48 b8       	lddpc	r8,80004614 <prvAddCurrentTaskToDelayedList+0x54>
800045ec:	70 0c       	ld.w	r12,r8[0x0]
800045ee:	2f cb       	sub	r11,-4
800045f0:	f0 1f 00 08 	mcall	80004610 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800045f4:	48 98       	lddpc	r8,80004618 <prvAddCurrentTaskToDelayedList+0x58>
800045f6:	70 08       	ld.w	r8,r8[0x0]
800045f8:	10 37       	cp.w	r7,r8
800045fa:	c0 32       	brcc	80004600 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800045fc:	48 78       	lddpc	r8,80004618 <prvAddCurrentTaskToDelayedList+0x58>
800045fe:	91 07       	st.w	r8[0x0],r7
80004600:	e3 cd 80 80 	ldm	sp++,r7,pc
80004604:	00 00       	add	r0,r0
80004606:	09 6c       	ld.uh	r12,--r4
80004608:	00 00       	add	r0,r0
8000460a:	09 98       	ld.ub	r8,r4[0x1]
8000460c:	00 00       	add	r0,r0
8000460e:	08 b4       	st.h	r4++,r4
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	40 1a       	lddsp	r10,sp[0x4]
80004614:	00 00       	add	r0,r0
80004616:	08 a4       	st.w	r4++,r4
80004618:	00 00       	add	r0,r0
8000461a:	00 ec       	st.h	--r0,r12

8000461c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
8000461c:	eb cd 40 c0 	pushm	r6-r7,lr
80004620:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80004622:	58 0c       	cp.w	r12,0
80004624:	c1 10       	breq	80004646 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80004626:	f0 1f 00 0a 	mcall	8000464c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000462a:	48 a8       	lddpc	r8,80004650 <vTaskDelay+0x34>
8000462c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000462e:	48 a8       	lddpc	r8,80004654 <vTaskDelay+0x38>
80004630:	70 0c       	ld.w	r12,r8[0x0]
80004632:	2f cc       	sub	r12,-4
80004634:	f0 1f 00 09 	mcall	80004658 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80004638:	ee 06 00 0c 	add	r12,r7,r6
8000463c:	f0 1f 00 08 	mcall	8000465c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80004640:	f0 1f 00 08 	mcall	80004660 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004644:	c0 21       	brne	80004648 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80004646:	d7 33       	scall
80004648:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000464c:	80 00       	ld.sh	r0,r0[0x0]
8000464e:	43 38       	lddsp	r8,sp[0xcc]
80004650:	00 00       	add	r0,r0
80004652:	09 98       	ld.ub	r8,r4[0x1]
80004654:	00 00       	add	r0,r0
80004656:	09 6c       	ld.uh	r12,--r4
80004658:	80 00       	ld.sh	r0,r0[0x0]
8000465a:	40 4e       	lddsp	lr,sp[0x10]
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	45 c0       	lddsp	r0,sp[0x170]
80004660:	80 00       	ld.sh	r0,r0[0x0]
80004662:	44 dc       	lddsp	r12,sp[0x134]

80004664 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80004664:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004668:	49 57       	lddpc	r7,800046bc <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000466a:	49 64       	lddpc	r4,800046c0 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000466c:	49 63       	lddpc	r3,800046c4 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000466e:	49 75       	lddpc	r5,800046c8 <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80004670:	6e 08       	ld.w	r8,r7[0x0]
80004672:	58 08       	cp.w	r8,0
80004674:	c1 e0       	breq	800046b0 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80004676:	f0 1f 00 16 	mcall	800046cc <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000467a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000467c:	f0 1f 00 15 	mcall	800046d0 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
80004680:	58 06       	cp.w	r6,0
80004682:	c1 70       	breq	800046b0 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80004684:	f0 1f 00 14 	mcall	800046d4 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80004688:	68 38       	ld.w	r8,r4[0xc]
8000468a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000468c:	ec cc ff fc 	sub	r12,r6,-4
80004690:	f0 1f 00 12 	mcall	800046d8 <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80004694:	66 08       	ld.w	r8,r3[0x0]
80004696:	20 18       	sub	r8,1
80004698:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000469a:	6e 08       	ld.w	r8,r7[0x0]
8000469c:	20 18       	sub	r8,1
8000469e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800046a0:	f0 1f 00 0f 	mcall	800046dc <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800046a4:	6c cc       	ld.w	r12,r6[0x30]
800046a6:	f0 1f 00 0f 	mcall	800046e0 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
800046aa:	0c 9c       	mov	r12,r6
800046ac:	f0 1f 00 0d 	mcall	800046e0 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800046b0:	6a 08       	ld.w	r8,r5[0x0]
800046b2:	58 18       	cp.w	r8,1
800046b4:	fe 98 ff de 	brls	80004670 <prvIdleTask+0xc>
			{
				taskYIELD();
800046b8:	d7 33       	scall
800046ba:	cd bb       	rjmp	80004670 <prvIdleTask+0xc>
800046bc:	00 00       	add	r0,r0
800046be:	08 ac       	st.w	r4++,r12
800046c0:	00 00       	add	r0,r0
800046c2:	09 58       	ld.sh	r8,--r4
800046c4:	00 00       	add	r0,r0
800046c6:	09 b8       	ld.ub	r8,r4[0x3]
800046c8:	00 00       	add	r0,r0
800046ca:	08 b8       	st.h	r4++,r8
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	43 38       	lddsp	r8,sp[0xcc]
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	44 dc       	lddsp	r12,sp[0x134]
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	41 08       	lddsp	r8,sp[0x40]
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	40 4e       	lddsp	lr,sp[0x10]
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	42 14       	lddsp	r4,sp[0x84]
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	42 e8       	lddsp	r8,sp[0xb8]

800046e4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800046e4:	d4 31       	pushm	r0-r7,lr
800046e6:	20 1d       	sub	sp,4
800046e8:	fa c4 ff d8 	sub	r4,sp,-40
800046ec:	50 0c       	stdsp	sp[0x0],r12
800046ee:	16 91       	mov	r1,r11
800046f0:	14 97       	mov	r7,r10
800046f2:	12 90       	mov	r0,r9
800046f4:	10 93       	mov	r3,r8
800046f6:	68 02       	ld.w	r2,r4[0x0]
800046f8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800046fa:	34 4c       	mov	r12,68
800046fc:	f0 1f 00 5b 	mcall	80004868 <xTaskGenericCreate+0x184>
80004700:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004702:	c0 31       	brne	80004708 <xTaskGenericCreate+0x24>
80004704:	3f fc       	mov	r12,-1
80004706:	ca d8       	rjmp	80004860 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004708:	58 06       	cp.w	r6,0
8000470a:	e0 81 00 ad 	brne	80004864 <xTaskGenericCreate+0x180>
8000470e:	0e 9c       	mov	r12,r7
80004710:	5c 7c       	castu.h	r12
80004712:	a3 6c       	lsl	r12,0x2
80004714:	f0 1f 00 55 	mcall	80004868 <xTaskGenericCreate+0x184>
80004718:	18 96       	mov	r6,r12
8000471a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
8000471c:	c0 61       	brne	80004728 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000471e:	0a 9c       	mov	r12,r5
80004720:	f0 1f 00 53 	mcall	8000486c <xTaskGenericCreate+0x188>
80004724:	3f fc       	mov	r12,-1
80004726:	c9 d8       	rjmp	80004860 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80004728:	5c 77       	castu.h	r7
8000472a:	ee 0a 15 02 	lsl	r10,r7,0x2
8000472e:	e0 6b 00 a5 	mov	r11,165
80004732:	0c 9c       	mov	r12,r6
80004734:	f0 1f 00 4f 	mcall	80004870 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80004738:	ee c6 00 01 	sub	r6,r7,1
8000473c:	6a c8       	ld.w	r8,r5[0x30]
8000473e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004742:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80004746:	31 0a       	mov	r10,16
80004748:	02 9b       	mov	r11,r1
8000474a:	ea cc ff cc 	sub	r12,r5,-52
8000474e:	f0 1f 00 4a 	mcall	80004874 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004752:	30 08       	mov	r8,0
80004754:	eb 68 00 43 	st.b	r5[67],r8
80004758:	58 73       	cp.w	r3,7
8000475a:	e6 07 17 80 	movls	r7,r3
8000475e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80004762:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80004764:	ea c4 ff fc 	sub	r4,r5,-4
80004768:	08 9c       	mov	r12,r4
8000476a:	f0 1f 00 44 	mcall	80004878 <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000476e:	ea cc ff e8 	sub	r12,r5,-24
80004772:	f0 1f 00 42 	mcall	80004878 <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80004776:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80004778:	ee 07 11 08 	rsub	r7,r7,8
8000477c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000477e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80004780:	00 9a       	mov	r10,r0
80004782:	40 0b       	lddsp	r11,sp[0x0]
80004784:	0c 9c       	mov	r12,r6
80004786:	f0 1f 00 3e 	mcall	8000487c <xTaskGenericCreate+0x198>
8000478a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000478c:	58 02       	cp.w	r2,0
8000478e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80004792:	f0 1f 00 3c 	mcall	80004880 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80004796:	4b c8       	lddpc	r8,80004884 <xTaskGenericCreate+0x1a0>
80004798:	70 09       	ld.w	r9,r8[0x0]
8000479a:	2f f9       	sub	r9,-1
8000479c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000479e:	4b b8       	lddpc	r8,80004888 <xTaskGenericCreate+0x1a4>
800047a0:	70 08       	ld.w	r8,r8[0x0]
800047a2:	58 08       	cp.w	r8,0
800047a4:	c2 61       	brne	800047f0 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800047a6:	4b 98       	lddpc	r8,80004888 <xTaskGenericCreate+0x1a4>
800047a8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800047aa:	4b 78       	lddpc	r8,80004884 <xTaskGenericCreate+0x1a0>
800047ac:	70 08       	ld.w	r8,r8[0x0]
800047ae:	58 18       	cp.w	r8,1
800047b0:	c2 b1       	brne	80004806 <xTaskGenericCreate+0x122>
800047b2:	4b 77       	lddpc	r7,8000488c <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800047b4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800047b8:	0e 9c       	mov	r12,r7
800047ba:	f0 1f 00 36 	mcall	80004890 <xTaskGenericCreate+0x1ac>
800047be:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800047c0:	0c 37       	cp.w	r7,r6
800047c2:	cf b1       	brne	800047b8 <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800047c4:	4b 47       	lddpc	r7,80004894 <xTaskGenericCreate+0x1b0>
800047c6:	0e 9c       	mov	r12,r7
800047c8:	f0 1f 00 32 	mcall	80004890 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800047cc:	4b 36       	lddpc	r6,80004898 <xTaskGenericCreate+0x1b4>
800047ce:	0c 9c       	mov	r12,r6
800047d0:	f0 1f 00 30 	mcall	80004890 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
800047d4:	4b 2c       	lddpc	r12,8000489c <xTaskGenericCreate+0x1b8>
800047d6:	f0 1f 00 2f 	mcall	80004890 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800047da:	4b 2c       	lddpc	r12,800048a0 <xTaskGenericCreate+0x1bc>
800047dc:	f0 1f 00 2d 	mcall	80004890 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800047e0:	4b 1c       	lddpc	r12,800048a4 <xTaskGenericCreate+0x1c0>
800047e2:	f0 1f 00 2c 	mcall	80004890 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800047e6:	4b 18       	lddpc	r8,800048a8 <xTaskGenericCreate+0x1c4>
800047e8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800047ea:	4b 18       	lddpc	r8,800048ac <xTaskGenericCreate+0x1c8>
800047ec:	91 06       	st.w	r8[0x0],r6
800047ee:	c0 c8       	rjmp	80004806 <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800047f0:	4b 08       	lddpc	r8,800048b0 <xTaskGenericCreate+0x1cc>
800047f2:	70 08       	ld.w	r8,r8[0x0]
800047f4:	58 08       	cp.w	r8,0
800047f6:	c0 81       	brne	80004806 <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800047f8:	4a 48       	lddpc	r8,80004888 <xTaskGenericCreate+0x1a4>
800047fa:	70 08       	ld.w	r8,r8[0x0]
800047fc:	70 b8       	ld.w	r8,r8[0x2c]
800047fe:	10 33       	cp.w	r3,r8
80004800:	c0 33       	brcs	80004806 <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80004802:	4a 28       	lddpc	r8,80004888 <xTaskGenericCreate+0x1a4>
80004804:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80004806:	6a b8       	ld.w	r8,r5[0x2c]
80004808:	4a b9       	lddpc	r9,800048b4 <xTaskGenericCreate+0x1d0>
8000480a:	72 09       	ld.w	r9,r9[0x0]
8000480c:	12 38       	cp.w	r8,r9
8000480e:	e0 88 00 04 	brls	80004816 <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004812:	4a 99       	lddpc	r9,800048b4 <xTaskGenericCreate+0x1d0>
80004814:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80004816:	4a 98       	lddpc	r8,800048b8 <xTaskGenericCreate+0x1d4>
80004818:	70 09       	ld.w	r9,r8[0x0]
8000481a:	2f f9       	sub	r9,-1
8000481c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000481e:	6a b8       	ld.w	r8,r5[0x2c]
80004820:	4a 79       	lddpc	r9,800048bc <xTaskGenericCreate+0x1d8>
80004822:	72 09       	ld.w	r9,r9[0x0]
80004824:	12 38       	cp.w	r8,r9
80004826:	e0 88 00 04 	brls	8000482e <xTaskGenericCreate+0x14a>
8000482a:	4a 59       	lddpc	r9,800048bc <xTaskGenericCreate+0x1d8>
8000482c:	93 08       	st.w	r9[0x0],r8
8000482e:	6a bc       	ld.w	r12,r5[0x2c]
80004830:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004834:	08 9b       	mov	r11,r4
80004836:	49 68       	lddpc	r8,8000488c <xTaskGenericCreate+0x1a8>
80004838:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000483c:	f0 1f 00 21 	mcall	800048c0 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80004840:	f0 1f 00 21 	mcall	800048c4 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80004844:	49 b8       	lddpc	r8,800048b0 <xTaskGenericCreate+0x1cc>
80004846:	70 08       	ld.w	r8,r8[0x0]
80004848:	58 08       	cp.w	r8,0
8000484a:	c0 a0       	breq	8000485e <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000484c:	48 f8       	lddpc	r8,80004888 <xTaskGenericCreate+0x1a4>
8000484e:	70 08       	ld.w	r8,r8[0x0]
80004850:	70 b8       	ld.w	r8,r8[0x2c]
80004852:	10 33       	cp.w	r3,r8
80004854:	e0 88 00 05 	brls	8000485e <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
80004858:	d7 33       	scall
8000485a:	30 1c       	mov	r12,1
8000485c:	c0 28       	rjmp	80004860 <xTaskGenericCreate+0x17c>
8000485e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80004860:	2f fd       	sub	sp,-4
80004862:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80004864:	99 c6       	st.w	r12[0x30],r6
80004866:	c6 1b       	rjmp	80004728 <xTaskGenericCreate+0x44>
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	43 10       	lddsp	r0,sp[0xc4]
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	42 e8       	lddsp	r8,sp[0xb8]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	4e 88       	lddpc	r8,80004a10 <exit>
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	4f d8       	lddpc	r8,80004a68 <_malloc_r+0x14>
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	3f f8       	mov	r8,-1
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	40 74       	lddsp	r4,sp[0x1c]
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	41 08       	lddsp	r8,sp[0x40]
80004884:	00 00       	add	r0,r0
80004886:	09 b8       	ld.ub	r8,r4[0x3]
80004888:	00 00       	add	r0,r0
8000488a:	09 6c       	ld.uh	r12,--r4
8000488c:	00 00       	add	r0,r0
8000488e:	08 b8       	st.h	r4++,r8
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	3f e4       	mov	r4,-2
80004894:	00 00       	add	r0,r0
80004896:	09 84       	ld.ub	r4,r4[0x0]
80004898:	00 00       	add	r0,r0
8000489a:	09 a0       	ld.ub	r0,r4[0x2]
8000489c:	00 00       	add	r0,r0
8000489e:	09 70       	ld.ub	r0,--r4
800048a0:	00 00       	add	r0,r0
800048a2:	09 58       	ld.sh	r8,--r4
800048a4:	00 00       	add	r0,r0
800048a6:	09 c0       	ld.ub	r0,r4[0x4]
800048a8:	00 00       	add	r0,r0
800048aa:	08 a4       	st.w	r4++,r4
800048ac:	00 00       	add	r0,r0
800048ae:	08 b4       	st.h	r4++,r4
800048b0:	00 00       	add	r0,r0
800048b2:	08 a8       	st.w	r4++,r8
800048b4:	00 00       	add	r0,r0
800048b6:	08 a0       	st.w	r4++,r0
800048b8:	00 00       	add	r0,r0
800048ba:	09 b4       	ld.ub	r4,r4[0x3]
800048bc:	00 00       	add	r0,r0
800048be:	09 d4       	ld.ub	r4,r4[0x5]
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	3f fe       	mov	lr,-1
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	42 14       	lddsp	r4,sp[0x84]

800048c8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800048c8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800048ca:	30 09       	mov	r9,0
800048cc:	1a d9       	st.w	--sp,r9
800048ce:	1a d9       	st.w	--sp,r9
800048d0:	1a d9       	st.w	--sp,r9
800048d2:	12 98       	mov	r8,r9
800048d4:	e0 6a 01 00 	mov	r10,256
800048d8:	48 9b       	lddpc	r11,800048fc <vTaskStartScheduler+0x34>
800048da:	48 ac       	lddpc	r12,80004900 <vTaskStartScheduler+0x38>
800048dc:	f0 1f 00 0a 	mcall	80004904 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800048e0:	2f dd       	sub	sp,-12
800048e2:	58 1c       	cp.w	r12,1
800048e4:	c0 a1       	brne	800048f8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800048e6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800048e8:	30 19       	mov	r9,1
800048ea:	48 88       	lddpc	r8,80004908 <vTaskStartScheduler+0x40>
800048ec:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800048ee:	30 09       	mov	r9,0
800048f0:	48 78       	lddpc	r8,8000490c <vTaskStartScheduler+0x44>
800048f2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800048f4:	f0 1f 00 07 	mcall	80004910 <vTaskStartScheduler+0x48>
800048f8:	d8 02       	popm	pc
800048fa:	00 00       	add	r0,r0
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	5d 08       	ror	r8
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	46 64       	lddsp	r4,sp[0x198]
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	46 e4       	lddsp	r4,sp[0x1b8]
80004908:	00 00       	add	r0,r0
8000490a:	08 a8       	st.w	r4++,r8
8000490c:	00 00       	add	r0,r0
8000490e:	09 98       	ld.ub	r8,r4[0x1]
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	41 18       	lddsp	r8,sp[0x44]

80004914 <vTaskB>:
		vTaskDelay(aDelay);
	}
}

static void vTaskB()
{
80004914:	eb cd 40 c0 	pushm	r6-r7,lr
	const portTickType bDelay=500/portTICK_RATE_MS;
	while(1){
		gpio_toggle_pin(LED1_GPIO);
80004918:	34 96       	mov	r6,73
		vTaskDelay(bDelay);
8000491a:	e0 67 01 f4 	mov	r7,500

static void vTaskB()
{
	const portTickType bDelay=500/portTICK_RATE_MS;
	while(1){
		gpio_toggle_pin(LED1_GPIO);
8000491e:	0c 9c       	mov	r12,r6
80004920:	f0 1f 00 03 	mcall	8000492c <vTaskB+0x18>
		vTaskDelay(bDelay);
80004924:	0e 9c       	mov	r12,r7
80004926:	f0 1f 00 03 	mcall	80004930 <vTaskB+0x1c>
8000492a:	cf ab       	rjmp	8000491e <vTaskB+0xa>
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	21 d4       	sub	r4,29
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	46 1c       	lddsp	r12,sp[0x184]

80004934 <vTaskA>:
		vTaskDelay(xDelay);
	}
}

static void vTaskA()
{
80004934:	eb cd 40 c0 	pushm	r6-r7,lr
	const portTickType aDelay=200/portTICK_RATE_MS;
	while(1){
		gpio_toggle_pin(LED0_GPIO);
80004938:	32 36       	mov	r6,35
	//	_delay_ms(200);
		vTaskDelay(aDelay);
8000493a:	e0 67 00 c8 	mov	r7,200

static void vTaskA()
{
	const portTickType aDelay=200/portTICK_RATE_MS;
	while(1){
		gpio_toggle_pin(LED0_GPIO);
8000493e:	0c 9c       	mov	r12,r6
80004940:	f0 1f 00 03 	mcall	8000494c <vTaskA+0x18>
	//	_delay_ms(200);
		vTaskDelay(aDelay);
80004944:	0e 9c       	mov	r12,r7
80004946:	f0 1f 00 03 	mcall	80004950 <vTaskA+0x1c>
8000494a:	cf ab       	rjmp	8000493e <vTaskA+0xa>
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	21 d4       	sub	r4,29
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	46 1c       	lddsp	r12,sp[0x184]

80004954 <init>:
#define RESPONSE_B AVR32_PIN_PA28
#define TEST_C AVR32_PIN_PA27
#define RESPONSE_C AVR32_PIN_PB00

void init()
{
80004954:	eb cd 40 80 	pushm	r7,lr
	// board init
	board_init();
80004958:	f0 1f 00 0e 	mcall	80004990 <init+0x3c>
		.dfll_f       = EXAMPLE_TARGET_DFLL_FREQ_HZ,
		.pextra_params = &gc_dfllif_ref_opt
	};
	pcl_configure_clocks(&pcl_dfll_freq_param);
#else
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
8000495c:	30 3a       	mov	r10,3
8000495e:	e0 6b 1b 00 	mov	r11,6912
80004962:	ea 1b 00 b7 	orh	r11,0xb7
80004966:	30 0c       	mov	r12,0
80004968:	f0 1f 00 0b 	mcall	80004994 <init+0x40>
#endif	
	
	// stdio init
	stdio_usb_init(&CONFIG_USART_IF);
8000496c:	fe 7c 1c 00 	mov	r12,-58368
80004970:	f0 1f 00 0a 	mcall	80004998 <init+0x44>

	// Specify that stdout and stdin should not be buffered.

#if defined(__GNUC__) && defined(__AVR32__)
	setbuf(stdout, NULL);
80004974:	48 a7       	lddpc	r7,8000499c <init+0x48>
80004976:	6e 08       	ld.w	r8,r7[0x0]
80004978:	30 0b       	mov	r11,0
8000497a:	70 1c       	ld.w	r12,r8[0x4]
8000497c:	f0 1f 00 09 	mcall	800049a0 <init+0x4c>
	setbuf(stdin,  NULL);
80004980:	6e 08       	ld.w	r8,r7[0x0]
80004982:	30 0b       	mov	r11,0
80004984:	70 0c       	ld.w	r12,r8[0x0]
80004986:	f0 1f 00 07 	mcall	800049a0 <init+0x4c>
#endif
}
8000498a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000498e:	00 00       	add	r0,r0
80004990:	80 00       	ld.sh	r0,r0[0x0]
80004992:	20 ec       	sub	r12,14
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	23 60       	sub	r0,54
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	3f 0c       	mov	r12,-16
8000499c:	00 00       	add	r0,r0
8000499e:	01 e0       	ld.ub	r0,r0[0x6]
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	4e b8       	lddpc	r8,80004b4c <_malloc_r+0xf8>

800049a4 <main>:
static void vTaskB();
/*********************************************************************
Functions
*********************************************************************/
int main()
{
800049a4:	eb cd 40 c0 	pushm	r6-r7,lr
	// initialize
	init();
800049a8:	f0 1f 00 10 	mcall	800049e8 <main+0x44>
	
	// start code from here
	
	// start basic task
	xTaskCreate( vTaskA, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
800049ac:	49 06       	lddpc	r6,800049ec <main+0x48>
800049ae:	30 07       	mov	r7,0
800049b0:	1a d7       	st.w	--sp,r7
800049b2:	1a d7       	st.w	--sp,r7
800049b4:	1a d7       	st.w	--sp,r7
800049b6:	30 18       	mov	r8,1
800049b8:	0e 99       	mov	r9,r7
800049ba:	e0 6a 01 00 	mov	r10,256
800049be:	0c 9b       	mov	r11,r6
800049c0:	48 cc       	lddpc	r12,800049f0 <main+0x4c>
800049c2:	f0 1f 00 0d 	mcall	800049f4 <main+0x50>
	xTaskCreate( vTaskB, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
800049c6:	1a d7       	st.w	--sp,r7
800049c8:	1a d7       	st.w	--sp,r7
800049ca:	1a d7       	st.w	--sp,r7
800049cc:	30 18       	mov	r8,1
800049ce:	0e 99       	mov	r9,r7
800049d0:	e0 6a 01 00 	mov	r10,256
800049d4:	0c 9b       	mov	r11,r6
800049d6:	48 9c       	lddpc	r12,800049f8 <main+0x54>
800049d8:	f0 1f 00 07 	mcall	800049f4 <main+0x50>

	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
800049dc:	f0 1f 00 08 	mcall	800049fc <main+0x58>
800049e0:	2f ad       	sub	sp,-24
}
800049e2:	0e 9c       	mov	r12,r7
800049e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	49 54       	lddpc	r4,80004a3c <free+0xc>
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	5d 10       	icall	r0
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	49 34       	lddpc	r4,80004a3c <free+0xc>
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	46 e4       	lddsp	r4,sp[0x1b8]
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 14       	lddpc	r4,80004a3c <free+0xc>
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	48 c8       	lddpc	r8,80004a2c <exit+0x1c>

80004a00 <atexit>:
80004a00:	d4 01       	pushm	lr
80004a02:	30 09       	mov	r9,0
80004a04:	18 9b       	mov	r11,r12
80004a06:	12 9a       	mov	r10,r9
80004a08:	12 9c       	mov	r12,r9
80004a0a:	e0 a0 03 37 	rcall	80005078 <__register_exitproc>
80004a0e:	d8 02       	popm	pc

80004a10 <exit>:
80004a10:	d4 21       	pushm	r4-r7,lr
80004a12:	30 0b       	mov	r11,0
80004a14:	18 97       	mov	r7,r12
80004a16:	e0 a0 03 85 	rcall	80005120 <__call_exitprocs>
80004a1a:	48 58       	lddpc	r8,80004a2c <exit+0x1c>
80004a1c:	70 0c       	ld.w	r12,r8[0x0]
80004a1e:	78 a8       	ld.w	r8,r12[0x28]
80004a20:	58 08       	cp.w	r8,0
80004a22:	c0 20       	breq	80004a26 <exit+0x16>
80004a24:	5d 18       	icall	r8
80004a26:	0e 9c       	mov	r12,r7
80004a28:	e0 a0 02 ed 	rcall	80005002 <_exit>
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	5d 18       	icall	r8

80004a30 <free>:
80004a30:	d4 01       	pushm	lr
80004a32:	48 48       	lddpc	r8,80004a40 <free+0x10>
80004a34:	18 9b       	mov	r11,r12
80004a36:	70 0c       	ld.w	r12,r8[0x0]
80004a38:	e0 a0 05 5a 	rcall	800054ec <_free_r>
80004a3c:	d8 02       	popm	pc
80004a3e:	d7 03       	nop
80004a40:	00 00       	add	r0,r0
80004a42:	01 e0       	ld.ub	r0,r0[0x6]

80004a44 <malloc>:
80004a44:	d4 01       	pushm	lr
80004a46:	48 38       	lddpc	r8,80004a50 <malloc+0xc>
80004a48:	18 9b       	mov	r11,r12
80004a4a:	70 0c       	ld.w	r12,r8[0x0]
80004a4c:	c0 4c       	rcall	80004a54 <_malloc_r>
80004a4e:	d8 02       	popm	pc
80004a50:	00 00       	add	r0,r0
80004a52:	01 e0       	ld.ub	r0,r0[0x6]

80004a54 <_malloc_r>:
80004a54:	d4 31       	pushm	r0-r7,lr
80004a56:	f6 c8 ff f5 	sub	r8,r11,-11
80004a5a:	18 95       	mov	r5,r12
80004a5c:	10 97       	mov	r7,r8
80004a5e:	e0 17 ff f8 	andl	r7,0xfff8
80004a62:	59 68       	cp.w	r8,22
80004a64:	f9 b7 08 10 	movls	r7,16
80004a68:	16 37       	cp.w	r7,r11
80004a6a:	5f 38       	srlo	r8
80004a6c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004a70:	c0 50       	breq	80004a7a <_malloc_r+0x26>
80004a72:	30 c8       	mov	r8,12
80004a74:	99 38       	st.w	r12[0xc],r8
80004a76:	e0 8f 01 ed 	bral	80004e50 <_malloc_r+0x3fc>
80004a7a:	fe b0 fc 1f 	rcall	800042b8 <__malloc_lock>
80004a7e:	e0 47 01 f7 	cp.w	r7,503
80004a82:	e0 8b 00 1c 	brhi	80004aba <_malloc_r+0x66>
80004a86:	ee 03 16 03 	lsr	r3,r7,0x3
80004a8a:	4c c8       	lddpc	r8,80004bb8 <_malloc_r+0x164>
80004a8c:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004a90:	70 36       	ld.w	r6,r8[0xc]
80004a92:	10 36       	cp.w	r6,r8
80004a94:	c0 61       	brne	80004aa0 <_malloc_r+0x4c>
80004a96:	ec c8 ff f8 	sub	r8,r6,-8
80004a9a:	70 36       	ld.w	r6,r8[0xc]
80004a9c:	10 36       	cp.w	r6,r8
80004a9e:	c0 c0       	breq	80004ab6 <_malloc_r+0x62>
80004aa0:	6c 18       	ld.w	r8,r6[0x4]
80004aa2:	e0 18 ff fc 	andl	r8,0xfffc
80004aa6:	6c 3a       	ld.w	r10,r6[0xc]
80004aa8:	ec 08 00 09 	add	r9,r6,r8
80004aac:	0a 9c       	mov	r12,r5
80004aae:	6c 28       	ld.w	r8,r6[0x8]
80004ab0:	95 28       	st.w	r10[0x8],r8
80004ab2:	91 3a       	st.w	r8[0xc],r10
80004ab4:	c4 68       	rjmp	80004b40 <_malloc_r+0xec>
80004ab6:	2f e3       	sub	r3,-2
80004ab8:	c4 c8       	rjmp	80004b50 <_malloc_r+0xfc>
80004aba:	ee 03 16 09 	lsr	r3,r7,0x9
80004abe:	c0 41       	brne	80004ac6 <_malloc_r+0x72>
80004ac0:	ee 03 16 03 	lsr	r3,r7,0x3
80004ac4:	c2 68       	rjmp	80004b10 <_malloc_r+0xbc>
80004ac6:	58 43       	cp.w	r3,4
80004ac8:	e0 8b 00 06 	brhi	80004ad4 <_malloc_r+0x80>
80004acc:	ee 03 16 06 	lsr	r3,r7,0x6
80004ad0:	2c 83       	sub	r3,-56
80004ad2:	c1 f8       	rjmp	80004b10 <_malloc_r+0xbc>
80004ad4:	59 43       	cp.w	r3,20
80004ad6:	e0 8b 00 04 	brhi	80004ade <_malloc_r+0x8a>
80004ada:	2a 53       	sub	r3,-91
80004adc:	c1 a8       	rjmp	80004b10 <_malloc_r+0xbc>
80004ade:	e0 43 00 54 	cp.w	r3,84
80004ae2:	e0 8b 00 06 	brhi	80004aee <_malloc_r+0x9a>
80004ae6:	ee 03 16 0c 	lsr	r3,r7,0xc
80004aea:	29 23       	sub	r3,-110
80004aec:	c1 28       	rjmp	80004b10 <_malloc_r+0xbc>
80004aee:	e0 43 01 54 	cp.w	r3,340
80004af2:	e0 8b 00 06 	brhi	80004afe <_malloc_r+0xaa>
80004af6:	ee 03 16 0f 	lsr	r3,r7,0xf
80004afa:	28 93       	sub	r3,-119
80004afc:	c0 a8       	rjmp	80004b10 <_malloc_r+0xbc>
80004afe:	e0 43 05 54 	cp.w	r3,1364
80004b02:	e0 88 00 04 	brls	80004b0a <_malloc_r+0xb6>
80004b06:	37 e3       	mov	r3,126
80004b08:	c0 48       	rjmp	80004b10 <_malloc_r+0xbc>
80004b0a:	ee 03 16 12 	lsr	r3,r7,0x12
80004b0e:	28 43       	sub	r3,-124
80004b10:	4a aa       	lddpc	r10,80004bb8 <_malloc_r+0x164>
80004b12:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004b16:	74 36       	ld.w	r6,r10[0xc]
80004b18:	c1 98       	rjmp	80004b4a <_malloc_r+0xf6>
80004b1a:	6c 19       	ld.w	r9,r6[0x4]
80004b1c:	e0 19 ff fc 	andl	r9,0xfffc
80004b20:	f2 07 01 0b 	sub	r11,r9,r7
80004b24:	58 fb       	cp.w	r11,15
80004b26:	e0 8a 00 04 	brle	80004b2e <_malloc_r+0xda>
80004b2a:	20 13       	sub	r3,1
80004b2c:	c1 18       	rjmp	80004b4e <_malloc_r+0xfa>
80004b2e:	6c 38       	ld.w	r8,r6[0xc]
80004b30:	58 0b       	cp.w	r11,0
80004b32:	c0 b5       	brlt	80004b48 <_malloc_r+0xf4>
80004b34:	6c 2a       	ld.w	r10,r6[0x8]
80004b36:	ec 09 00 09 	add	r9,r6,r9
80004b3a:	0a 9c       	mov	r12,r5
80004b3c:	91 2a       	st.w	r8[0x8],r10
80004b3e:	95 38       	st.w	r10[0xc],r8
80004b40:	72 18       	ld.w	r8,r9[0x4]
80004b42:	a1 a8       	sbr	r8,0x0
80004b44:	93 18       	st.w	r9[0x4],r8
80004b46:	cb a8       	rjmp	80004cba <_malloc_r+0x266>
80004b48:	10 96       	mov	r6,r8
80004b4a:	14 36       	cp.w	r6,r10
80004b4c:	ce 71       	brne	80004b1a <_malloc_r+0xc6>
80004b4e:	2f f3       	sub	r3,-1
80004b50:	49 aa       	lddpc	r10,80004bb8 <_malloc_r+0x164>
80004b52:	f4 cc ff f8 	sub	r12,r10,-8
80004b56:	78 26       	ld.w	r6,r12[0x8]
80004b58:	18 36       	cp.w	r6,r12
80004b5a:	c6 c0       	breq	80004c32 <_malloc_r+0x1de>
80004b5c:	6c 19       	ld.w	r9,r6[0x4]
80004b5e:	e0 19 ff fc 	andl	r9,0xfffc
80004b62:	f2 07 01 08 	sub	r8,r9,r7
80004b66:	58 f8       	cp.w	r8,15
80004b68:	e0 89 00 8e 	brgt	80004c84 <_malloc_r+0x230>
80004b6c:	99 3c       	st.w	r12[0xc],r12
80004b6e:	99 2c       	st.w	r12[0x8],r12
80004b70:	58 08       	cp.w	r8,0
80004b72:	c0 55       	brlt	80004b7c <_malloc_r+0x128>
80004b74:	ec 09 00 09 	add	r9,r6,r9
80004b78:	0a 9c       	mov	r12,r5
80004b7a:	ce 3b       	rjmp	80004b40 <_malloc_r+0xec>
80004b7c:	e0 49 01 ff 	cp.w	r9,511
80004b80:	e0 8b 00 13 	brhi	80004ba6 <_malloc_r+0x152>
80004b84:	a3 99       	lsr	r9,0x3
80004b86:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004b8a:	70 2b       	ld.w	r11,r8[0x8]
80004b8c:	8d 38       	st.w	r6[0xc],r8
80004b8e:	8d 2b       	st.w	r6[0x8],r11
80004b90:	97 36       	st.w	r11[0xc],r6
80004b92:	91 26       	st.w	r8[0x8],r6
80004b94:	a3 49       	asr	r9,0x2
80004b96:	74 18       	ld.w	r8,r10[0x4]
80004b98:	30 1b       	mov	r11,1
80004b9a:	f6 09 09 49 	lsl	r9,r11,r9
80004b9e:	f1 e9 10 09 	or	r9,r8,r9
80004ba2:	95 19       	st.w	r10[0x4],r9
80004ba4:	c4 78       	rjmp	80004c32 <_malloc_r+0x1de>
80004ba6:	f2 0a 16 09 	lsr	r10,r9,0x9
80004baa:	58 4a       	cp.w	r10,4
80004bac:	e0 8b 00 08 	brhi	80004bbc <_malloc_r+0x168>
80004bb0:	f2 0a 16 06 	lsr	r10,r9,0x6
80004bb4:	2c 8a       	sub	r10,-56
80004bb6:	c2 18       	rjmp	80004bf8 <_malloc_r+0x1a4>
80004bb8:	00 00       	add	r0,r0
80004bba:	01 e4       	ld.ub	r4,r0[0x6]
80004bbc:	59 4a       	cp.w	r10,20
80004bbe:	e0 8b 00 04 	brhi	80004bc6 <_malloc_r+0x172>
80004bc2:	2a 5a       	sub	r10,-91
80004bc4:	c1 a8       	rjmp	80004bf8 <_malloc_r+0x1a4>
80004bc6:	e0 4a 00 54 	cp.w	r10,84
80004bca:	e0 8b 00 06 	brhi	80004bd6 <_malloc_r+0x182>
80004bce:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004bd2:	29 2a       	sub	r10,-110
80004bd4:	c1 28       	rjmp	80004bf8 <_malloc_r+0x1a4>
80004bd6:	e0 4a 01 54 	cp.w	r10,340
80004bda:	e0 8b 00 06 	brhi	80004be6 <_malloc_r+0x192>
80004bde:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004be2:	28 9a       	sub	r10,-119
80004be4:	c0 a8       	rjmp	80004bf8 <_malloc_r+0x1a4>
80004be6:	e0 4a 05 54 	cp.w	r10,1364
80004bea:	e0 88 00 04 	brls	80004bf2 <_malloc_r+0x19e>
80004bee:	37 ea       	mov	r10,126
80004bf0:	c0 48       	rjmp	80004bf8 <_malloc_r+0x1a4>
80004bf2:	f2 0a 16 12 	lsr	r10,r9,0x12
80004bf6:	28 4a       	sub	r10,-124
80004bf8:	4c 8b       	lddpc	r11,80004d18 <_malloc_r+0x2c4>
80004bfa:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004bfe:	68 28       	ld.w	r8,r4[0x8]
80004c00:	08 38       	cp.w	r8,r4
80004c02:	c0 e1       	brne	80004c1e <_malloc_r+0x1ca>
80004c04:	76 19       	ld.w	r9,r11[0x4]
80004c06:	a3 4a       	asr	r10,0x2
80004c08:	30 1e       	mov	lr,1
80004c0a:	fc 0a 09 4a 	lsl	r10,lr,r10
80004c0e:	f3 ea 10 0a 	or	r10,r9,r10
80004c12:	10 99       	mov	r9,r8
80004c14:	97 1a       	st.w	r11[0x4],r10
80004c16:	c0 a8       	rjmp	80004c2a <_malloc_r+0x1d6>
80004c18:	70 28       	ld.w	r8,r8[0x8]
80004c1a:	08 38       	cp.w	r8,r4
80004c1c:	c0 60       	breq	80004c28 <_malloc_r+0x1d4>
80004c1e:	70 1a       	ld.w	r10,r8[0x4]
80004c20:	e0 1a ff fc 	andl	r10,0xfffc
80004c24:	14 39       	cp.w	r9,r10
80004c26:	cf 93       	brcs	80004c18 <_malloc_r+0x1c4>
80004c28:	70 39       	ld.w	r9,r8[0xc]
80004c2a:	8d 39       	st.w	r6[0xc],r9
80004c2c:	8d 28       	st.w	r6[0x8],r8
80004c2e:	91 36       	st.w	r8[0xc],r6
80004c30:	93 26       	st.w	r9[0x8],r6
80004c32:	e6 08 14 02 	asr	r8,r3,0x2
80004c36:	30 1b       	mov	r11,1
80004c38:	4b 84       	lddpc	r4,80004d18 <_malloc_r+0x2c4>
80004c3a:	f6 08 09 4b 	lsl	r11,r11,r8
80004c3e:	68 18       	ld.w	r8,r4[0x4]
80004c40:	10 3b       	cp.w	r11,r8
80004c42:	e0 8b 00 6d 	brhi	80004d1c <_malloc_r+0x2c8>
80004c46:	f7 e8 00 09 	and	r9,r11,r8
80004c4a:	c0 b1       	brne	80004c60 <_malloc_r+0x20c>
80004c4c:	e0 13 ff fc 	andl	r3,0xfffc
80004c50:	a1 7b       	lsl	r11,0x1
80004c52:	2f c3       	sub	r3,-4
80004c54:	c0 38       	rjmp	80004c5a <_malloc_r+0x206>
80004c56:	2f c3       	sub	r3,-4
80004c58:	a1 7b       	lsl	r11,0x1
80004c5a:	f7 e8 00 09 	and	r9,r11,r8
80004c5e:	cf c0       	breq	80004c56 <_malloc_r+0x202>
80004c60:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004c64:	06 92       	mov	r2,r3
80004c66:	1c 91       	mov	r1,lr
80004c68:	62 36       	ld.w	r6,r1[0xc]
80004c6a:	c2 e8       	rjmp	80004cc6 <_malloc_r+0x272>
80004c6c:	6c 1a       	ld.w	r10,r6[0x4]
80004c6e:	e0 1a ff fc 	andl	r10,0xfffc
80004c72:	f4 07 01 08 	sub	r8,r10,r7
80004c76:	58 f8       	cp.w	r8,15
80004c78:	e0 8a 00 15 	brle	80004ca2 <_malloc_r+0x24e>
80004c7c:	6c 3a       	ld.w	r10,r6[0xc]
80004c7e:	6c 29       	ld.w	r9,r6[0x8]
80004c80:	95 29       	st.w	r10[0x8],r9
80004c82:	93 3a       	st.w	r9[0xc],r10
80004c84:	0e 99       	mov	r9,r7
80004c86:	ec 07 00 07 	add	r7,r6,r7
80004c8a:	a1 a9       	sbr	r9,0x0
80004c8c:	99 37       	st.w	r12[0xc],r7
80004c8e:	99 27       	st.w	r12[0x8],r7
80004c90:	8d 19       	st.w	r6[0x4],r9
80004c92:	ee 08 09 08 	st.w	r7[r8],r8
80004c96:	8f 2c       	st.w	r7[0x8],r12
80004c98:	8f 3c       	st.w	r7[0xc],r12
80004c9a:	a1 a8       	sbr	r8,0x0
80004c9c:	0a 9c       	mov	r12,r5
80004c9e:	8f 18       	st.w	r7[0x4],r8
80004ca0:	c0 d8       	rjmp	80004cba <_malloc_r+0x266>
80004ca2:	6c 39       	ld.w	r9,r6[0xc]
80004ca4:	58 08       	cp.w	r8,0
80004ca6:	c0 f5       	brlt	80004cc4 <_malloc_r+0x270>
80004ca8:	ec 0a 00 0a 	add	r10,r6,r10
80004cac:	74 18       	ld.w	r8,r10[0x4]
80004cae:	a1 a8       	sbr	r8,0x0
80004cb0:	0a 9c       	mov	r12,r5
80004cb2:	95 18       	st.w	r10[0x4],r8
80004cb4:	6c 28       	ld.w	r8,r6[0x8]
80004cb6:	93 28       	st.w	r9[0x8],r8
80004cb8:	91 39       	st.w	r8[0xc],r9
80004cba:	fe b0 fb 05 	rcall	800042c4 <__malloc_unlock>
80004cbe:	ec cc ff f8 	sub	r12,r6,-8
80004cc2:	d8 32       	popm	r0-r7,pc
80004cc4:	12 96       	mov	r6,r9
80004cc6:	02 36       	cp.w	r6,r1
80004cc8:	cd 21       	brne	80004c6c <_malloc_r+0x218>
80004cca:	2f f2       	sub	r2,-1
80004ccc:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004cd0:	c0 30       	breq	80004cd6 <_malloc_r+0x282>
80004cd2:	2f 81       	sub	r1,-8
80004cd4:	cc ab       	rjmp	80004c68 <_malloc_r+0x214>
80004cd6:	1c 98       	mov	r8,lr
80004cd8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004cdc:	c0 81       	brne	80004cec <_malloc_r+0x298>
80004cde:	68 19       	ld.w	r9,r4[0x4]
80004ce0:	f6 08 11 ff 	rsub	r8,r11,-1
80004ce4:	f3 e8 00 08 	and	r8,r9,r8
80004ce8:	89 18       	st.w	r4[0x4],r8
80004cea:	c0 78       	rjmp	80004cf8 <_malloc_r+0x2a4>
80004cec:	f0 c9 00 08 	sub	r9,r8,8
80004cf0:	20 13       	sub	r3,1
80004cf2:	70 08       	ld.w	r8,r8[0x0]
80004cf4:	12 38       	cp.w	r8,r9
80004cf6:	cf 10       	breq	80004cd8 <_malloc_r+0x284>
80004cf8:	a1 7b       	lsl	r11,0x1
80004cfa:	68 18       	ld.w	r8,r4[0x4]
80004cfc:	10 3b       	cp.w	r11,r8
80004cfe:	e0 8b 00 0f 	brhi	80004d1c <_malloc_r+0x2c8>
80004d02:	58 0b       	cp.w	r11,0
80004d04:	c0 c0       	breq	80004d1c <_malloc_r+0x2c8>
80004d06:	04 93       	mov	r3,r2
80004d08:	c0 38       	rjmp	80004d0e <_malloc_r+0x2ba>
80004d0a:	2f c3       	sub	r3,-4
80004d0c:	a1 7b       	lsl	r11,0x1
80004d0e:	f7 e8 00 09 	and	r9,r11,r8
80004d12:	ca 71       	brne	80004c60 <_malloc_r+0x20c>
80004d14:	cf bb       	rjmp	80004d0a <_malloc_r+0x2b6>
80004d16:	d7 03       	nop
80004d18:	00 00       	add	r0,r0
80004d1a:	01 e4       	ld.ub	r4,r0[0x6]
80004d1c:	68 23       	ld.w	r3,r4[0x8]
80004d1e:	66 12       	ld.w	r2,r3[0x4]
80004d20:	e0 12 ff fc 	andl	r2,0xfffc
80004d24:	0e 32       	cp.w	r2,r7
80004d26:	5f 39       	srlo	r9
80004d28:	e4 07 01 08 	sub	r8,r2,r7
80004d2c:	58 f8       	cp.w	r8,15
80004d2e:	5f aa       	srle	r10
80004d30:	f5 e9 10 09 	or	r9,r10,r9
80004d34:	e0 80 00 9a 	breq	80004e68 <_malloc_r+0x414>
80004d38:	4c 78       	lddpc	r8,80004e54 <_malloc_r+0x400>
80004d3a:	70 01       	ld.w	r1,r8[0x0]
80004d3c:	4c 78       	lddpc	r8,80004e58 <_malloc_r+0x404>
80004d3e:	2f 01       	sub	r1,-16
80004d40:	70 08       	ld.w	r8,r8[0x0]
80004d42:	0e 01       	add	r1,r7
80004d44:	5b f8       	cp.w	r8,-1
80004d46:	c0 40       	breq	80004d4e <_malloc_r+0x2fa>
80004d48:	28 11       	sub	r1,-127
80004d4a:	e0 11 ff 80 	andl	r1,0xff80
80004d4e:	02 9b       	mov	r11,r1
80004d50:	0a 9c       	mov	r12,r5
80004d52:	ca 3c       	rcall	80004e98 <_sbrk_r>
80004d54:	18 96       	mov	r6,r12
80004d56:	5b fc       	cp.w	r12,-1
80004d58:	c6 d0       	breq	80004e32 <_malloc_r+0x3de>
80004d5a:	e6 02 00 08 	add	r8,r3,r2
80004d5e:	10 3c       	cp.w	r12,r8
80004d60:	c0 32       	brcc	80004d66 <_malloc_r+0x312>
80004d62:	08 33       	cp.w	r3,r4
80004d64:	c6 71       	brne	80004e32 <_malloc_r+0x3de>
80004d66:	4b ea       	lddpc	r10,80004e5c <_malloc_r+0x408>
80004d68:	74 09       	ld.w	r9,r10[0x0]
80004d6a:	e2 09 00 09 	add	r9,r1,r9
80004d6e:	95 09       	st.w	r10[0x0],r9
80004d70:	10 36       	cp.w	r6,r8
80004d72:	c0 a1       	brne	80004d86 <_malloc_r+0x332>
80004d74:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004d78:	c0 71       	brne	80004d86 <_malloc_r+0x332>
80004d7a:	e2 02 00 02 	add	r2,r1,r2
80004d7e:	68 28       	ld.w	r8,r4[0x8]
80004d80:	a1 a2       	sbr	r2,0x0
80004d82:	91 12       	st.w	r8[0x4],r2
80004d84:	c4 b8       	rjmp	80004e1a <_malloc_r+0x3c6>
80004d86:	4b 5a       	lddpc	r10,80004e58 <_malloc_r+0x404>
80004d88:	74 0b       	ld.w	r11,r10[0x0]
80004d8a:	5b fb       	cp.w	r11,-1
80004d8c:	c0 31       	brne	80004d92 <_malloc_r+0x33e>
80004d8e:	95 06       	st.w	r10[0x0],r6
80004d90:	c0 68       	rjmp	80004d9c <_malloc_r+0x348>
80004d92:	ec 09 00 09 	add	r9,r6,r9
80004d96:	4b 2a       	lddpc	r10,80004e5c <_malloc_r+0x408>
80004d98:	10 19       	sub	r9,r8
80004d9a:	95 09       	st.w	r10[0x0],r9
80004d9c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004da0:	f0 09 11 08 	rsub	r9,r8,8
80004da4:	58 08       	cp.w	r8,0
80004da6:	f2 08 17 10 	movne	r8,r9
80004daa:	ed d8 e1 06 	addne	r6,r6,r8
80004dae:	28 08       	sub	r8,-128
80004db0:	ec 01 00 01 	add	r1,r6,r1
80004db4:	0a 9c       	mov	r12,r5
80004db6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004dba:	f0 01 01 01 	sub	r1,r8,r1
80004dbe:	02 9b       	mov	r11,r1
80004dc0:	c6 cc       	rcall	80004e98 <_sbrk_r>
80004dc2:	4a 78       	lddpc	r8,80004e5c <_malloc_r+0x408>
80004dc4:	5b fc       	cp.w	r12,-1
80004dc6:	ec 0c 17 00 	moveq	r12,r6
80004dca:	f9 b1 00 00 	moveq	r1,0
80004dce:	70 09       	ld.w	r9,r8[0x0]
80004dd0:	0c 1c       	sub	r12,r6
80004dd2:	89 26       	st.w	r4[0x8],r6
80004dd4:	02 0c       	add	r12,r1
80004dd6:	12 01       	add	r1,r9
80004dd8:	a1 ac       	sbr	r12,0x0
80004dda:	91 01       	st.w	r8[0x0],r1
80004ddc:	8d 1c       	st.w	r6[0x4],r12
80004dde:	08 33       	cp.w	r3,r4
80004de0:	c1 d0       	breq	80004e1a <_malloc_r+0x3c6>
80004de2:	58 f2       	cp.w	r2,15
80004de4:	e0 8b 00 05 	brhi	80004dee <_malloc_r+0x39a>
80004de8:	30 18       	mov	r8,1
80004dea:	8d 18       	st.w	r6[0x4],r8
80004dec:	c2 38       	rjmp	80004e32 <_malloc_r+0x3de>
80004dee:	30 59       	mov	r9,5
80004df0:	20 c2       	sub	r2,12
80004df2:	e0 12 ff f8 	andl	r2,0xfff8
80004df6:	e6 02 00 08 	add	r8,r3,r2
80004dfa:	91 29       	st.w	r8[0x8],r9
80004dfc:	91 19       	st.w	r8[0x4],r9
80004dfe:	66 18       	ld.w	r8,r3[0x4]
80004e00:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e04:	e5 e8 10 08 	or	r8,r2,r8
80004e08:	87 18       	st.w	r3[0x4],r8
80004e0a:	58 f2       	cp.w	r2,15
80004e0c:	e0 88 00 07 	brls	80004e1a <_malloc_r+0x3c6>
80004e10:	e6 cb ff f8 	sub	r11,r3,-8
80004e14:	0a 9c       	mov	r12,r5
80004e16:	e0 a0 03 6b 	rcall	800054ec <_free_r>
80004e1a:	49 29       	lddpc	r9,80004e60 <_malloc_r+0x40c>
80004e1c:	72 0a       	ld.w	r10,r9[0x0]
80004e1e:	49 08       	lddpc	r8,80004e5c <_malloc_r+0x408>
80004e20:	70 08       	ld.w	r8,r8[0x0]
80004e22:	14 38       	cp.w	r8,r10
80004e24:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004e28:	48 f9       	lddpc	r9,80004e64 <_malloc_r+0x410>
80004e2a:	72 0a       	ld.w	r10,r9[0x0]
80004e2c:	14 38       	cp.w	r8,r10
80004e2e:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004e32:	68 28       	ld.w	r8,r4[0x8]
80004e34:	70 18       	ld.w	r8,r8[0x4]
80004e36:	e0 18 ff fc 	andl	r8,0xfffc
80004e3a:	0e 38       	cp.w	r8,r7
80004e3c:	5f 39       	srlo	r9
80004e3e:	0e 18       	sub	r8,r7
80004e40:	58 f8       	cp.w	r8,15
80004e42:	5f aa       	srle	r10
80004e44:	f5 e9 10 09 	or	r9,r10,r9
80004e48:	c1 00       	breq	80004e68 <_malloc_r+0x414>
80004e4a:	0a 9c       	mov	r12,r5
80004e4c:	fe b0 fa 3c 	rcall	800042c4 <__malloc_unlock>
80004e50:	d8 3a       	popm	r0-r7,pc,r12=0
80004e52:	d7 03       	nop
80004e54:	00 00       	add	r0,r0
80004e56:	09 e0       	ld.ub	r0,r4[0x6]
80004e58:	00 00       	add	r0,r0
80004e5a:	05 f0       	ld.ub	r0,r2[0x7]
80004e5c:	00 00       	add	r0,r0
80004e5e:	09 e4       	ld.ub	r4,r4[0x6]
80004e60:	00 00       	add	r0,r0
80004e62:	09 dc       	ld.ub	r12,r4[0x5]
80004e64:	00 00       	add	r0,r0
80004e66:	09 d8       	ld.ub	r8,r4[0x5]
80004e68:	68 26       	ld.w	r6,r4[0x8]
80004e6a:	a1 a8       	sbr	r8,0x0
80004e6c:	0e 99       	mov	r9,r7
80004e6e:	a1 a9       	sbr	r9,0x0
80004e70:	8d 19       	st.w	r6[0x4],r9
80004e72:	ec 07 00 07 	add	r7,r6,r7
80004e76:	0a 9c       	mov	r12,r5
80004e78:	89 27       	st.w	r4[0x8],r7
80004e7a:	8f 18       	st.w	r7[0x4],r8
80004e7c:	fe b0 fa 24 	rcall	800042c4 <__malloc_unlock>
80004e80:	ec cc ff f8 	sub	r12,r6,-8
80004e84:	d8 32       	popm	r0-r7,pc
80004e86:	d7 03       	nop

80004e88 <memset>:
80004e88:	18 98       	mov	r8,r12
80004e8a:	c0 38       	rjmp	80004e90 <memset+0x8>
80004e8c:	10 cb       	st.b	r8++,r11
80004e8e:	20 1a       	sub	r10,1
80004e90:	58 0a       	cp.w	r10,0
80004e92:	cf d1       	brne	80004e8c <memset+0x4>
80004e94:	5e fc       	retal	r12
80004e96:	d7 03       	nop

80004e98 <_sbrk_r>:
80004e98:	d4 21       	pushm	r4-r7,lr
80004e9a:	30 08       	mov	r8,0
80004e9c:	18 97       	mov	r7,r12
80004e9e:	48 66       	lddpc	r6,80004eb4 <_sbrk_r+0x1c>
80004ea0:	16 9c       	mov	r12,r11
80004ea2:	8d 08       	st.w	r6[0x0],r8
80004ea4:	cc cc       	rcall	8000503c <_sbrk>
80004ea6:	5b fc       	cp.w	r12,-1
80004ea8:	c0 51       	brne	80004eb2 <_sbrk_r+0x1a>
80004eaa:	6c 08       	ld.w	r8,r6[0x0]
80004eac:	58 08       	cp.w	r8,0
80004eae:	ef f8 1a 03 	st.wne	r7[0xc],r8
80004eb2:	d8 22       	popm	r4-r7,pc
80004eb4:	00 00       	add	r0,r0
80004eb6:	0a 3c       	cp.w	r12,r5

80004eb8 <setbuf>:
80004eb8:	d4 01       	pushm	lr
80004eba:	e0 69 04 00 	mov	r9,1024
80004ebe:	58 0b       	cp.w	r11,0
80004ec0:	f9 ba 00 02 	moveq	r10,2
80004ec4:	f9 ba 01 00 	movne	r10,0
80004ec8:	c0 2c       	rcall	80004ecc <setvbuf>
80004eca:	d8 02       	popm	pc

80004ecc <setvbuf>:
80004ecc:	d4 31       	pushm	r0-r7,lr
80004ece:	4b f8       	lddpc	r8,80004fc8 <setvbuf+0xfc>
80004ed0:	18 97       	mov	r7,r12
80004ed2:	16 96       	mov	r6,r11
80004ed4:	14 95       	mov	r5,r10
80004ed6:	12 94       	mov	r4,r9
80004ed8:	70 0c       	ld.w	r12,r8[0x0]
80004eda:	58 0c       	cp.w	r12,0
80004edc:	c0 60       	breq	80004ee8 <setvbuf+0x1c>
80004ede:	78 68       	ld.w	r8,r12[0x18]
80004ee0:	58 08       	cp.w	r8,0
80004ee2:	c0 31       	brne	80004ee8 <setvbuf+0x1c>
80004ee4:	e0 a0 02 68 	rcall	800053b4 <__sinit>
80004ee8:	4b 98       	lddpc	r8,80004fcc <setvbuf+0x100>
80004eea:	10 37       	cp.w	r7,r8
80004eec:	c0 51       	brne	80004ef6 <setvbuf+0x2a>
80004eee:	4b 78       	lddpc	r8,80004fc8 <setvbuf+0xfc>
80004ef0:	70 08       	ld.w	r8,r8[0x0]
80004ef2:	70 07       	ld.w	r7,r8[0x0]
80004ef4:	c0 e8       	rjmp	80004f10 <setvbuf+0x44>
80004ef6:	4b 78       	lddpc	r8,80004fd0 <setvbuf+0x104>
80004ef8:	10 37       	cp.w	r7,r8
80004efa:	c0 51       	brne	80004f04 <setvbuf+0x38>
80004efc:	4b 38       	lddpc	r8,80004fc8 <setvbuf+0xfc>
80004efe:	70 08       	ld.w	r8,r8[0x0]
80004f00:	70 17       	ld.w	r7,r8[0x4]
80004f02:	c0 78       	rjmp	80004f10 <setvbuf+0x44>
80004f04:	4b 48       	lddpc	r8,80004fd4 <setvbuf+0x108>
80004f06:	10 37       	cp.w	r7,r8
80004f08:	c0 41       	brne	80004f10 <setvbuf+0x44>
80004f0a:	4b 08       	lddpc	r8,80004fc8 <setvbuf+0xfc>
80004f0c:	70 08       	ld.w	r8,r8[0x0]
80004f0e:	70 27       	ld.w	r7,r8[0x8]
80004f10:	58 25       	cp.w	r5,2
80004f12:	5f b8       	srhi	r8
80004f14:	f1 e4 13 f8 	or	r8,r8,r4>>0x1f
80004f18:	c0 20       	breq	80004f1c <setvbuf+0x50>
80004f1a:	dc 3a       	popm	r0-r7,pc,r12=-1
80004f1c:	4a b3       	lddpc	r3,80004fc8 <setvbuf+0xfc>
80004f1e:	0e 9b       	mov	r11,r7
80004f20:	66 0c       	ld.w	r12,r3[0x0]
80004f22:	c6 dd       	rcall	800051fc <_fflush_r>
80004f24:	30 08       	mov	r8,0
80004f26:	8f 68       	st.w	r7[0x18],r8
80004f28:	8f 18       	st.w	r7[0x4],r8
80004f2a:	8e 68       	ld.sh	r8,r7[0xc]
80004f2c:	ed b8 00 07 	bld	r8,0x7
80004f30:	c0 51       	brne	80004f3a <setvbuf+0x6e>
80004f32:	66 0c       	ld.w	r12,r3[0x0]
80004f34:	6e 4b       	ld.w	r11,r7[0x10]
80004f36:	e0 a0 02 db 	rcall	800054ec <_free_r>
80004f3a:	8e 68       	ld.sh	r8,r7[0xc]
80004f3c:	e0 18 ff 7c 	andl	r8,0xff7c
80004f40:	ae 68       	st.h	r7[0xc],r8
80004f42:	58 25       	cp.w	r5,2
80004f44:	c0 31       	brne	80004f4a <setvbuf+0x7e>
80004f46:	30 0c       	mov	r12,0
80004f48:	c1 38       	rjmp	80004f6e <setvbuf+0xa2>
80004f4a:	58 06       	cp.w	r6,0
80004f4c:	c2 11       	brne	80004f8e <setvbuf+0xc2>
80004f4e:	e0 63 04 00 	mov	r3,1024
80004f52:	58 04       	cp.w	r4,0
80004f54:	e6 04 17 00 	moveq	r4,r3
80004f58:	08 9c       	mov	r12,r4
80004f5a:	fe b0 fd 75 	rcall	80004a44 <malloc>
80004f5e:	18 96       	mov	r6,r12
80004f60:	c1 41       	brne	80004f88 <setvbuf+0xbc>
80004f62:	06 9c       	mov	r12,r3
80004f64:	fe b0 fd 70 	rcall	80004a44 <malloc>
80004f68:	18 96       	mov	r6,r12
80004f6a:	c0 e1       	brne	80004f86 <setvbuf+0xba>
80004f6c:	3f fc       	mov	r12,-1
80004f6e:	8e 68       	ld.sh	r8,r7[0xc]
80004f70:	a1 b8       	sbr	r8,0x1
80004f72:	ae 68       	st.h	r7[0xc],r8
80004f74:	ee c8 ff b9 	sub	r8,r7,-71
80004f78:	8f 48       	st.w	r7[0x10],r8
80004f7a:	8f 08       	st.w	r7[0x0],r8
80004f7c:	30 08       	mov	r8,0
80004f7e:	8f 28       	st.w	r7[0x8],r8
80004f80:	30 18       	mov	r8,1
80004f82:	8f 58       	st.w	r7[0x14],r8
80004f84:	d8 32       	popm	r0-r7,pc
80004f86:	06 94       	mov	r4,r3
80004f88:	8e 68       	ld.sh	r8,r7[0xc]
80004f8a:	a7 b8       	sbr	r8,0x7
80004f8c:	ae 68       	st.h	r7[0xc],r8
80004f8e:	58 15       	cp.w	r5,1
80004f90:	c0 71       	brne	80004f9e <setvbuf+0xd2>
80004f92:	8e 68       	ld.sh	r8,r7[0xc]
80004f94:	a1 a8       	sbr	r8,0x0
80004f96:	ae 68       	st.h	r7[0xc],r8
80004f98:	e8 08 11 00 	rsub	r8,r4,0
80004f9c:	8f 68       	st.w	r7[0x18],r8
80004f9e:	48 b8       	lddpc	r8,80004fc8 <setvbuf+0xfc>
80004fa0:	fe c9 fc 90 	sub	r9,pc,-880
80004fa4:	70 08       	ld.w	r8,r8[0x0]
80004fa6:	8f 46       	st.w	r7[0x10],r6
80004fa8:	91 a9       	st.w	r8[0x28],r9
80004faa:	8f 06       	st.w	r7[0x0],r6
80004fac:	8f 54       	st.w	r7[0x14],r4
80004fae:	8e 68       	ld.sh	r8,r7[0xc]
80004fb0:	10 9c       	mov	r12,r8
80004fb2:	e2 1c 00 08 	andl	r12,0x8,COH
80004fb6:	c0 70       	breq	80004fc4 <setvbuf+0xf8>
80004fb8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80004fbc:	30 0c       	mov	r12,0
80004fbe:	f9 b4 01 00 	movne	r4,0
80004fc2:	8f 24       	st.w	r7[0x8],r4
80004fc4:	d8 32       	popm	r0-r7,pc
80004fc6:	d7 03       	nop
80004fc8:	00 00       	add	r0,r0
80004fca:	01 e0       	ld.ub	r0,r0[0x6]
80004fcc:	80 00       	ld.sh	r0,r0[0x0]
80004fce:	5d 1c       	icall	r12
80004fd0:	80 00       	ld.sh	r0,r0[0x0]
80004fd2:	5d 3c       	musfr	r12
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	5d 5c       	*unknown*

80004fd8 <strncpy>:
80004fd8:	30 08       	mov	r8,0
80004fda:	10 3a       	cp.w	r10,r8
80004fdc:	5e 0c       	reteq	r12
80004fde:	f6 08 07 09 	ld.ub	r9,r11[r8]
80004fe2:	f8 08 0b 09 	st.b	r12[r8],r9
80004fe6:	2f f8       	sub	r8,-1
80004fe8:	58 09       	cp.w	r9,0
80004fea:	cf 81       	brne	80004fda <strncpy+0x2>
80004fec:	10 3a       	cp.w	r10,r8
80004fee:	5e 0c       	reteq	r12
80004ff0:	f8 08 0b 09 	st.b	r12[r8],r9
80004ff4:	2f f8       	sub	r8,-1
80004ff6:	cf bb       	rjmp	80004fec <strncpy+0x14>

80004ff8 <_init_argv>:
80004ff8:	30 e8       	mov	r8,14
80004ffa:	d6 73       	breakpoint
80004ffc:	3f fc       	mov	r12,-1
80004ffe:	35 8b       	mov	r11,88
80005000:	5e fc       	retal	r12

80005002 <_exit>:
80005002:	30 d8       	mov	r8,13
80005004:	d6 73       	breakpoint
80005006:	3f fc       	mov	r12,-1
80005008:	35 8b       	mov	r11,88
8000500a:	c0 08       	rjmp	8000500a <_exit+0x8>

8000500c <_close>:
8000500c:	30 28       	mov	r8,2
8000500e:	d6 73       	breakpoint
80005010:	3f fc       	mov	r12,-1
80005012:	35 8b       	mov	r11,88
80005014:	58 0c       	cp.w	r12,0
80005016:	5e 4c       	retge	r12
80005018:	48 2a       	lddpc	r10,80005020 <_close+0x14>
8000501a:	95 0b       	st.w	r10[0x0],r11
8000501c:	5e fc       	retal	r12
8000501e:	d7 03       	nop
80005020:	00 00       	add	r0,r0
80005022:	0a 3c       	cp.w	r12,r5

80005024 <_lseek>:
80005024:	30 58       	mov	r8,5
80005026:	d6 73       	breakpoint
80005028:	3f fc       	mov	r12,-1
8000502a:	35 8b       	mov	r11,88
8000502c:	58 0c       	cp.w	r12,0
8000502e:	5e 4c       	retge	r12
80005030:	48 2a       	lddpc	r10,80005038 <_lseek+0x14>
80005032:	95 0b       	st.w	r10[0x0],r11
80005034:	5e fc       	retal	r12
80005036:	d7 03       	nop
80005038:	00 00       	add	r0,r0
8000503a:	0a 3c       	cp.w	r12,r5

8000503c <_sbrk>:
8000503c:	d4 01       	pushm	lr
8000503e:	48 c8       	lddpc	r8,8000506c <_sbrk+0x30>
80005040:	70 09       	ld.w	r9,r8[0x0]
80005042:	58 09       	cp.w	r9,0
80005044:	c0 31       	brne	8000504a <_sbrk+0xe>
80005046:	48 b9       	lddpc	r9,80005070 <_sbrk+0x34>
80005048:	91 09       	st.w	r8[0x0],r9
8000504a:	48 99       	lddpc	r9,8000506c <_sbrk+0x30>
8000504c:	48 aa       	lddpc	r10,80005074 <_sbrk+0x38>
8000504e:	72 08       	ld.w	r8,r9[0x0]
80005050:	f0 0c 00 0c 	add	r12,r8,r12
80005054:	14 3c       	cp.w	r12,r10
80005056:	e0 8b 00 04 	brhi	8000505e <_sbrk+0x22>
8000505a:	93 0c       	st.w	r9[0x0],r12
8000505c:	c0 58       	rjmp	80005066 <_sbrk+0x2a>
8000505e:	cc 9c       	rcall	800051f0 <__errno>
80005060:	30 c8       	mov	r8,12
80005062:	99 08       	st.w	r12[0x0],r8
80005064:	3f f8       	mov	r8,-1
80005066:	10 9c       	mov	r12,r8
80005068:	d8 02       	popm	pc
8000506a:	d7 03       	nop
8000506c:	00 00       	add	r0,r0
8000506e:	0a 0c       	add	r12,r5
80005070:	00 00       	add	r0,r0
80005072:	0a 40       	or	r0,r5
80005074:	00 00       	add	r0,r0
80005076:	f0 00       	*unknown*

80005078 <__register_exitproc>:
80005078:	d4 31       	pushm	r0-r7,lr
8000507a:	4a 98       	lddpc	r8,8000511c <__register_exitproc+0xa4>
8000507c:	70 03       	ld.w	r3,r8[0x0]
8000507e:	67 24       	ld.w	r4,r3[0x48]
80005080:	e6 c8 ff b4 	sub	r8,r3,-76
80005084:	58 04       	cp.w	r4,0
80005086:	f0 04 17 00 	moveq	r4,r8
8000508a:	e7 f4 0a 12 	st.weq	r3[0x48],r4
8000508e:	18 97       	mov	r7,r12
80005090:	16 96       	mov	r6,r11
80005092:	14 95       	mov	r5,r10
80005094:	12 92       	mov	r2,r9
80005096:	68 18       	ld.w	r8,r4[0x4]
80005098:	59 f8       	cp.w	r8,31
8000509a:	e0 8a 00 0e 	brle	800050b6 <__register_exitproc+0x3e>
8000509e:	e0 6c 00 8c 	mov	r12,140
800050a2:	fe b0 fc d1 	rcall	80004a44 <malloc>
800050a6:	18 94       	mov	r4,r12
800050a8:	c3 80       	breq	80005118 <__register_exitproc+0xa0>
800050aa:	67 28       	ld.w	r8,r3[0x48]
800050ac:	99 08       	st.w	r12[0x0],r8
800050ae:	e7 4c 00 48 	st.w	r3[72],r12
800050b2:	30 08       	mov	r8,0
800050b4:	99 18       	st.w	r12[0x4],r8
800050b6:	58 07       	cp.w	r7,0
800050b8:	c2 70       	breq	80005106 <__register_exitproc+0x8e>
800050ba:	e8 fc 00 88 	ld.w	r12,r4[136]
800050be:	58 0c       	cp.w	r12,0
800050c0:	c0 d1       	brne	800050da <__register_exitproc+0x62>
800050c2:	e0 6c 01 08 	mov	r12,264
800050c6:	fe b0 fc bf 	rcall	80004a44 <malloc>
800050ca:	c2 70       	breq	80005118 <__register_exitproc+0xa0>
800050cc:	30 08       	mov	r8,0
800050ce:	e9 4c 00 88 	st.w	r4[136],r12
800050d2:	f9 48 01 04 	st.w	r12[260],r8
800050d6:	f9 48 01 00 	st.w	r12[256],r8
800050da:	68 18       	ld.w	r8,r4[0x4]
800050dc:	f0 c9 ff e0 	sub	r9,r8,-32
800050e0:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
800050e4:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
800050e8:	30 1a       	mov	r10,1
800050ea:	f8 f9 01 00 	ld.w	r9,r12[256]
800050ee:	f4 08 09 48 	lsl	r8,r10,r8
800050f2:	10 49       	or	r9,r8
800050f4:	f9 49 01 00 	st.w	r12[256],r9
800050f8:	58 27       	cp.w	r7,2
800050fa:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
800050fe:	f3 d8 e0 38 	oreq	r8,r9,r8
80005102:	f9 f8 0a 41 	st.weq	r12[0x104],r8
80005106:	68 18       	ld.w	r8,r4[0x4]
80005108:	30 0c       	mov	r12,0
8000510a:	f0 c9 ff ff 	sub	r9,r8,-1
8000510e:	2f e8       	sub	r8,-2
80005110:	89 19       	st.w	r4[0x4],r9
80005112:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
80005116:	d8 32       	popm	r0-r7,pc
80005118:	dc 3a       	popm	r0-r7,pc,r12=-1
8000511a:	d7 03       	nop
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	5d 18       	icall	r8

80005120 <__call_exitprocs>:
80005120:	d4 31       	pushm	r0-r7,lr
80005122:	20 3d       	sub	sp,12
80005124:	4b 28       	lddpc	r8,800051ec <__call_exitprocs+0xcc>
80005126:	50 2c       	stdsp	sp[0x8],r12
80005128:	70 08       	ld.w	r8,r8[0x0]
8000512a:	16 91       	mov	r1,r11
8000512c:	50 08       	stdsp	sp[0x0],r8
8000512e:	2b 88       	sub	r8,-72
80005130:	50 18       	stdsp	sp[0x4],r8
80005132:	40 0a       	lddsp	r10,sp[0x0]
80005134:	40 14       	lddsp	r4,sp[0x4]
80005136:	75 27       	ld.w	r7,r10[0x48]
80005138:	c5 58       	rjmp	800051e2 <__call_exitprocs+0xc2>
8000513a:	6e 15       	ld.w	r5,r7[0x4]
8000513c:	ee f6 00 88 	ld.w	r6,r7[136]
80005140:	ea c2 ff ff 	sub	r2,r5,-1
80005144:	20 15       	sub	r5,1
80005146:	ee 02 00 22 	add	r2,r7,r2<<0x2
8000514a:	ec 05 00 23 	add	r3,r6,r5<<0x2
8000514e:	c3 58       	rjmp	800051b8 <__call_exitprocs+0x98>
80005150:	58 01       	cp.w	r1,0
80005152:	c0 70       	breq	80005160 <__call_exitprocs+0x40>
80005154:	58 06       	cp.w	r6,0
80005156:	c2 e0       	breq	800051b2 <__call_exitprocs+0x92>
80005158:	e6 f8 00 80 	ld.w	r8,r3[128]
8000515c:	02 38       	cp.w	r8,r1
8000515e:	c2 a1       	brne	800051b2 <__call_exitprocs+0x92>
80005160:	6e 19       	ld.w	r9,r7[0x4]
80005162:	64 08       	ld.w	r8,r2[0x0]
80005164:	20 19       	sub	r9,1
80005166:	12 35       	cp.w	r5,r9
80005168:	ef f5 0a 01 	st.weq	r7[0x4],r5
8000516c:	f9 b9 01 00 	movne	r9,0
80005170:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80005174:	58 08       	cp.w	r8,0
80005176:	c1 e0       	breq	800051b2 <__call_exitprocs+0x92>
80005178:	6e 10       	ld.w	r0,r7[0x4]
8000517a:	58 06       	cp.w	r6,0
8000517c:	c0 90       	breq	8000518e <__call_exitprocs+0x6e>
8000517e:	30 1a       	mov	r10,1
80005180:	f4 05 09 49 	lsl	r9,r10,r5
80005184:	ec fa 01 00 	ld.w	r10,r6[256]
80005188:	f3 ea 00 0a 	and	r10,r9,r10
8000518c:	c0 31       	brne	80005192 <__call_exitprocs+0x72>
8000518e:	5d 18       	icall	r8
80005190:	c0 b8       	rjmp	800051a6 <__call_exitprocs+0x86>
80005192:	ec fa 01 04 	ld.w	r10,r6[260]
80005196:	66 0b       	ld.w	r11,r3[0x0]
80005198:	14 69       	and	r9,r10
8000519a:	c0 41       	brne	800051a2 <__call_exitprocs+0x82>
8000519c:	40 2c       	lddsp	r12,sp[0x8]
8000519e:	5d 18       	icall	r8
800051a0:	c0 38       	rjmp	800051a6 <__call_exitprocs+0x86>
800051a2:	16 9c       	mov	r12,r11
800051a4:	5d 18       	icall	r8
800051a6:	6e 18       	ld.w	r8,r7[0x4]
800051a8:	10 30       	cp.w	r0,r8
800051aa:	cc 41       	brne	80005132 <__call_exitprocs+0x12>
800051ac:	68 08       	ld.w	r8,r4[0x0]
800051ae:	0e 38       	cp.w	r8,r7
800051b0:	cc 11       	brne	80005132 <__call_exitprocs+0x12>
800051b2:	20 15       	sub	r5,1
800051b4:	20 43       	sub	r3,4
800051b6:	20 42       	sub	r2,4
800051b8:	58 05       	cp.w	r5,0
800051ba:	cc b4       	brge	80005150 <__call_exitprocs+0x30>
800051bc:	6e 18       	ld.w	r8,r7[0x4]
800051be:	58 08       	cp.w	r8,0
800051c0:	c0 f1       	brne	800051de <__call_exitprocs+0xbe>
800051c2:	6e 08       	ld.w	r8,r7[0x0]
800051c4:	58 08       	cp.w	r8,0
800051c6:	c0 c0       	breq	800051de <__call_exitprocs+0xbe>
800051c8:	89 08       	st.w	r4[0x0],r8
800051ca:	58 06       	cp.w	r6,0
800051cc:	c0 40       	breq	800051d4 <__call_exitprocs+0xb4>
800051ce:	0c 9c       	mov	r12,r6
800051d0:	fe b0 fc 30 	rcall	80004a30 <free>
800051d4:	0e 9c       	mov	r12,r7
800051d6:	fe b0 fc 2d 	rcall	80004a30 <free>
800051da:	68 07       	ld.w	r7,r4[0x0]
800051dc:	c0 38       	rjmp	800051e2 <__call_exitprocs+0xc2>
800051de:	0e 94       	mov	r4,r7
800051e0:	6e 07       	ld.w	r7,r7[0x0]
800051e2:	58 07       	cp.w	r7,0
800051e4:	ca b1       	brne	8000513a <__call_exitprocs+0x1a>
800051e6:	2f dd       	sub	sp,-12
800051e8:	d8 32       	popm	r0-r7,pc
800051ea:	d7 03       	nop
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	5d 18       	icall	r8

800051f0 <__errno>:
800051f0:	48 28       	lddpc	r8,800051f8 <__errno+0x8>
800051f2:	70 0c       	ld.w	r12,r8[0x0]
800051f4:	2f 4c       	sub	r12,-12
800051f6:	5e fc       	retal	r12
800051f8:	00 00       	add	r0,r0
800051fa:	01 e0       	ld.ub	r0,r0[0x6]

800051fc <_fflush_r>:
800051fc:	d4 21       	pushm	r4-r7,lr
800051fe:	16 97       	mov	r7,r11
80005200:	18 96       	mov	r6,r12
80005202:	76 48       	ld.w	r8,r11[0x10]
80005204:	58 08       	cp.w	r8,0
80005206:	c7 c0       	breq	800052fe <_fflush_r+0x102>
80005208:	58 0c       	cp.w	r12,0
8000520a:	c0 50       	breq	80005214 <_fflush_r+0x18>
8000520c:	78 68       	ld.w	r8,r12[0x18]
8000520e:	58 08       	cp.w	r8,0
80005210:	c0 21       	brne	80005214 <_fflush_r+0x18>
80005212:	cd 1c       	rcall	800053b4 <__sinit>
80005214:	4b b8       	lddpc	r8,80005300 <_fflush_r+0x104>
80005216:	10 37       	cp.w	r7,r8
80005218:	c0 31       	brne	8000521e <_fflush_r+0x22>
8000521a:	6c 07       	ld.w	r7,r6[0x0]
8000521c:	c0 a8       	rjmp	80005230 <_fflush_r+0x34>
8000521e:	4b a8       	lddpc	r8,80005304 <_fflush_r+0x108>
80005220:	10 37       	cp.w	r7,r8
80005222:	c0 31       	brne	80005228 <_fflush_r+0x2c>
80005224:	6c 17       	ld.w	r7,r6[0x4]
80005226:	c0 58       	rjmp	80005230 <_fflush_r+0x34>
80005228:	4b 88       	lddpc	r8,80005308 <_fflush_r+0x10c>
8000522a:	10 37       	cp.w	r7,r8
8000522c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80005230:	8e 6a       	ld.sh	r10,r7[0xc]
80005232:	14 98       	mov	r8,r10
80005234:	ed ba 00 03 	bld	r10,0x3
80005238:	c4 20       	breq	800052bc <_fflush_r+0xc0>
8000523a:	ab ba       	sbr	r10,0xb
8000523c:	ae 6a       	st.h	r7[0xc],r10
8000523e:	6e 18       	ld.w	r8,r7[0x4]
80005240:	58 08       	cp.w	r8,0
80005242:	e0 89 00 06 	brgt	8000524e <_fflush_r+0x52>
80005246:	6f 08       	ld.w	r8,r7[0x40]
80005248:	58 08       	cp.w	r8,0
8000524a:	e0 8a 00 5a 	brle	800052fe <_fflush_r+0x102>
8000524e:	6e b8       	ld.w	r8,r7[0x2c]
80005250:	58 08       	cp.w	r8,0
80005252:	c5 60       	breq	800052fe <_fflush_r+0x102>
80005254:	e2 1a 10 00 	andl	r10,0x1000,COH
80005258:	c0 30       	breq	8000525e <_fflush_r+0x62>
8000525a:	6f 55       	ld.w	r5,r7[0x54]
8000525c:	c0 f8       	rjmp	8000527a <_fflush_r+0x7e>
8000525e:	30 19       	mov	r9,1
80005260:	6e 8b       	ld.w	r11,r7[0x20]
80005262:	0c 9c       	mov	r12,r6
80005264:	5d 18       	icall	r8
80005266:	18 95       	mov	r5,r12
80005268:	5b fc       	cp.w	r12,-1
8000526a:	c0 81       	brne	8000527a <_fflush_r+0x7e>
8000526c:	6c 38       	ld.w	r8,r6[0xc]
8000526e:	59 d8       	cp.w	r8,29
80005270:	c4 70       	breq	800052fe <_fflush_r+0x102>
80005272:	8e 68       	ld.sh	r8,r7[0xc]
80005274:	a7 a8       	sbr	r8,0x6
80005276:	ae 68       	st.h	r7[0xc],r8
80005278:	d8 22       	popm	r4-r7,pc
8000527a:	8e 68       	ld.sh	r8,r7[0xc]
8000527c:	ed b8 00 02 	bld	r8,0x2
80005280:	c0 91       	brne	80005292 <_fflush_r+0x96>
80005282:	6e 18       	ld.w	r8,r7[0x4]
80005284:	10 15       	sub	r5,r8
80005286:	6e d8       	ld.w	r8,r7[0x34]
80005288:	58 08       	cp.w	r8,0
8000528a:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000528e:	eb d8 e1 15 	subne	r5,r5,r8
80005292:	6e b8       	ld.w	r8,r7[0x2c]
80005294:	0c 9c       	mov	r12,r6
80005296:	30 09       	mov	r9,0
80005298:	0a 9a       	mov	r10,r5
8000529a:	6e 8b       	ld.w	r11,r7[0x20]
8000529c:	5d 18       	icall	r8
8000529e:	8e 68       	ld.sh	r8,r7[0xc]
800052a0:	0a 3c       	cp.w	r12,r5
800052a2:	c2 61       	brne	800052ee <_fflush_r+0xf2>
800052a4:	ab d8       	cbr	r8,0xb
800052a6:	30 0c       	mov	r12,0
800052a8:	6e 49       	ld.w	r9,r7[0x10]
800052aa:	ae 68       	st.h	r7[0xc],r8
800052ac:	8f 1c       	st.w	r7[0x4],r12
800052ae:	8f 09       	st.w	r7[0x0],r9
800052b0:	ed b8 00 0c 	bld	r8,0xc
800052b4:	c2 51       	brne	800052fe <_fflush_r+0x102>
800052b6:	ef 45 00 54 	st.w	r7[84],r5
800052ba:	d8 22       	popm	r4-r7,pc
800052bc:	6e 45       	ld.w	r5,r7[0x10]
800052be:	58 05       	cp.w	r5,0
800052c0:	c1 f0       	breq	800052fe <_fflush_r+0x102>
800052c2:	6e 04       	ld.w	r4,r7[0x0]
800052c4:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800052c8:	8f 05       	st.w	r7[0x0],r5
800052ca:	f9 b8 01 00 	movne	r8,0
800052ce:	ef f8 00 05 	ld.weq	r8,r7[0x14]
800052d2:	0a 14       	sub	r4,r5
800052d4:	8f 28       	st.w	r7[0x8],r8
800052d6:	c1 18       	rjmp	800052f8 <_fflush_r+0xfc>
800052d8:	08 99       	mov	r9,r4
800052da:	0a 9a       	mov	r10,r5
800052dc:	6e a8       	ld.w	r8,r7[0x28]
800052de:	6e 8b       	ld.w	r11,r7[0x20]
800052e0:	0c 9c       	mov	r12,r6
800052e2:	5d 18       	icall	r8
800052e4:	18 14       	sub	r4,r12
800052e6:	58 0c       	cp.w	r12,0
800052e8:	e0 89 00 07 	brgt	800052f6 <_fflush_r+0xfa>
800052ec:	8e 68       	ld.sh	r8,r7[0xc]
800052ee:	a7 a8       	sbr	r8,0x6
800052f0:	3f fc       	mov	r12,-1
800052f2:	ae 68       	st.h	r7[0xc],r8
800052f4:	d8 22       	popm	r4-r7,pc
800052f6:	18 05       	add	r5,r12
800052f8:	58 04       	cp.w	r4,0
800052fa:	fe 99 ff ef 	brgt	800052d8 <_fflush_r+0xdc>
800052fe:	d8 2a       	popm	r4-r7,pc,r12=0
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	5d 1c       	icall	r12
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	5d 3c       	musfr	r12
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	5d 5c       	*unknown*

8000530c <__sfp_lock_acquire>:
8000530c:	5e fc       	retal	r12

8000530e <__sfp_lock_release>:
8000530e:	5e fc       	retal	r12

80005310 <_cleanup_r>:
80005310:	d4 01       	pushm	lr
80005312:	fe cb fa de 	sub	r11,pc,-1314
80005316:	cb 3d       	rcall	8000567c <_fwalk>
80005318:	d8 02       	popm	pc
8000531a:	d7 03       	nop

8000531c <__sfmoreglue>:
8000531c:	d4 21       	pushm	r4-r7,lr
8000531e:	16 95       	mov	r5,r11
80005320:	f6 06 10 5c 	mul	r6,r11,92
80005324:	ec cb ff f4 	sub	r11,r6,-12
80005328:	fe b0 fb 96 	rcall	80004a54 <_malloc_r>
8000532c:	18 97       	mov	r7,r12
8000532e:	c0 90       	breq	80005340 <__sfmoreglue+0x24>
80005330:	99 15       	st.w	r12[0x4],r5
80005332:	30 0b       	mov	r11,0
80005334:	2f 4c       	sub	r12,-12
80005336:	0c 9a       	mov	r10,r6
80005338:	8f 2c       	st.w	r7[0x8],r12
8000533a:	8f 0b       	st.w	r7[0x0],r11
8000533c:	fe b0 fd a6 	rcall	80004e88 <memset>
80005340:	0e 9c       	mov	r12,r7
80005342:	d8 22       	popm	r4-r7,pc

80005344 <__sfp>:
80005344:	d4 21       	pushm	r4-r7,lr
80005346:	49 b8       	lddpc	r8,800053b0 <__sfp+0x6c>
80005348:	18 96       	mov	r6,r12
8000534a:	70 07       	ld.w	r7,r8[0x0]
8000534c:	6e 68       	ld.w	r8,r7[0x18]
8000534e:	58 08       	cp.w	r8,0
80005350:	c0 31       	brne	80005356 <__sfp+0x12>
80005352:	0e 9c       	mov	r12,r7
80005354:	c3 0c       	rcall	800053b4 <__sinit>
80005356:	ee c7 ff 28 	sub	r7,r7,-216
8000535a:	30 05       	mov	r5,0
8000535c:	6e 2c       	ld.w	r12,r7[0x8]
8000535e:	6e 18       	ld.w	r8,r7[0x4]
80005360:	c0 68       	rjmp	8000536c <__sfp+0x28>
80005362:	98 69       	ld.sh	r9,r12[0xc]
80005364:	ea 09 19 00 	cp.h	r9,r5
80005368:	c1 10       	breq	8000538a <__sfp+0x46>
8000536a:	2a 4c       	sub	r12,-92
8000536c:	20 18       	sub	r8,1
8000536e:	cf a7       	brpl	80005362 <__sfp+0x1e>
80005370:	6e 08       	ld.w	r8,r7[0x0]
80005372:	58 08       	cp.w	r8,0
80005374:	c0 61       	brne	80005380 <__sfp+0x3c>
80005376:	30 4b       	mov	r11,4
80005378:	0c 9c       	mov	r12,r6
8000537a:	cd 1f       	rcall	8000531c <__sfmoreglue>
8000537c:	8f 0c       	st.w	r7[0x0],r12
8000537e:	c0 30       	breq	80005384 <__sfp+0x40>
80005380:	6e 07       	ld.w	r7,r7[0x0]
80005382:	ce db       	rjmp	8000535c <__sfp+0x18>
80005384:	30 c8       	mov	r8,12
80005386:	8d 38       	st.w	r6[0xc],r8
80005388:	d8 22       	popm	r4-r7,pc
8000538a:	30 08       	mov	r8,0
8000538c:	f9 48 00 4c 	st.w	r12[76],r8
80005390:	99 08       	st.w	r12[0x0],r8
80005392:	99 28       	st.w	r12[0x8],r8
80005394:	99 18       	st.w	r12[0x4],r8
80005396:	99 48       	st.w	r12[0x10],r8
80005398:	99 58       	st.w	r12[0x14],r8
8000539a:	99 68       	st.w	r12[0x18],r8
8000539c:	99 d8       	st.w	r12[0x34],r8
8000539e:	99 e8       	st.w	r12[0x38],r8
800053a0:	f9 48 00 48 	st.w	r12[72],r8
800053a4:	3f f8       	mov	r8,-1
800053a6:	b8 78       	st.h	r12[0xe],r8
800053a8:	30 18       	mov	r8,1
800053aa:	b8 68       	st.h	r12[0xc],r8
800053ac:	d8 22       	popm	r4-r7,pc
800053ae:	d7 03       	nop
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	5d 18       	icall	r8

800053b4 <__sinit>:
800053b4:	d4 21       	pushm	r4-r7,lr
800053b6:	18 96       	mov	r6,r12
800053b8:	78 67       	ld.w	r7,r12[0x18]
800053ba:	58 07       	cp.w	r7,0
800053bc:	c4 91       	brne	8000544e <__sinit+0x9a>
800053be:	fe c8 00 ae 	sub	r8,pc,174
800053c2:	30 15       	mov	r5,1
800053c4:	99 a8       	st.w	r12[0x28],r8
800053c6:	f9 47 00 d8 	st.w	r12[216],r7
800053ca:	f9 47 00 dc 	st.w	r12[220],r7
800053ce:	f9 47 00 e0 	st.w	r12[224],r7
800053d2:	99 65       	st.w	r12[0x18],r5
800053d4:	cb 8f       	rcall	80005344 <__sfp>
800053d6:	8d 0c       	st.w	r6[0x0],r12
800053d8:	0c 9c       	mov	r12,r6
800053da:	cb 5f       	rcall	80005344 <__sfp>
800053dc:	8d 1c       	st.w	r6[0x4],r12
800053de:	0c 9c       	mov	r12,r6
800053e0:	cb 2f       	rcall	80005344 <__sfp>
800053e2:	6c 09       	ld.w	r9,r6[0x0]
800053e4:	30 48       	mov	r8,4
800053e6:	93 07       	st.w	r9[0x0],r7
800053e8:	b2 68       	st.h	r9[0xc],r8
800053ea:	93 17       	st.w	r9[0x4],r7
800053ec:	93 27       	st.w	r9[0x8],r7
800053ee:	6c 18       	ld.w	r8,r6[0x4]
800053f0:	b2 77       	st.h	r9[0xe],r7
800053f2:	93 47       	st.w	r9[0x10],r7
800053f4:	93 57       	st.w	r9[0x14],r7
800053f6:	93 67       	st.w	r9[0x18],r7
800053f8:	93 89       	st.w	r9[0x20],r9
800053fa:	91 07       	st.w	r8[0x0],r7
800053fc:	91 17       	st.w	r8[0x4],r7
800053fe:	91 27       	st.w	r8[0x8],r7
80005400:	fe ce fc e8 	sub	lr,pc,-792
80005404:	fe cb fd 18 	sub	r11,pc,-744
80005408:	93 9e       	st.w	r9[0x24],lr
8000540a:	93 ab       	st.w	r9[0x28],r11
8000540c:	fe ca fd 40 	sub	r10,pc,-704
80005410:	fe c4 fd 4c 	sub	r4,pc,-692
80005414:	93 ba       	st.w	r9[0x2c],r10
80005416:	93 c4       	st.w	r9[0x30],r4
80005418:	30 99       	mov	r9,9
8000541a:	b0 69       	st.h	r8[0xc],r9
8000541c:	b0 75       	st.h	r8[0xe],r5
8000541e:	91 c4       	st.w	r8[0x30],r4
80005420:	91 47       	st.w	r8[0x10],r7
80005422:	91 57       	st.w	r8[0x14],r7
80005424:	91 67       	st.w	r8[0x18],r7
80005426:	91 88       	st.w	r8[0x20],r8
80005428:	91 9e       	st.w	r8[0x24],lr
8000542a:	91 ab       	st.w	r8[0x28],r11
8000542c:	91 ba       	st.w	r8[0x2c],r10
8000542e:	8d 2c       	st.w	r6[0x8],r12
80005430:	31 28       	mov	r8,18
80005432:	99 07       	st.w	r12[0x0],r7
80005434:	b8 68       	st.h	r12[0xc],r8
80005436:	99 17       	st.w	r12[0x4],r7
80005438:	99 27       	st.w	r12[0x8],r7
8000543a:	30 28       	mov	r8,2
8000543c:	b8 78       	st.h	r12[0xe],r8
8000543e:	99 c4       	st.w	r12[0x30],r4
80005440:	99 67       	st.w	r12[0x18],r7
80005442:	99 9e       	st.w	r12[0x24],lr
80005444:	99 ab       	st.w	r12[0x28],r11
80005446:	99 ba       	st.w	r12[0x2c],r10
80005448:	99 47       	st.w	r12[0x10],r7
8000544a:	99 57       	st.w	r12[0x14],r7
8000544c:	99 8c       	st.w	r12[0x20],r12
8000544e:	d8 22       	popm	r4-r7,pc

80005450 <_malloc_trim_r>:
80005450:	d4 21       	pushm	r4-r7,lr
80005452:	16 95       	mov	r5,r11
80005454:	18 97       	mov	r7,r12
80005456:	fe b0 f7 31 	rcall	800042b8 <__malloc_lock>
8000545a:	4a 24       	lddpc	r4,800054e0 <_malloc_trim_r+0x90>
8000545c:	68 28       	ld.w	r8,r4[0x8]
8000545e:	70 16       	ld.w	r6,r8[0x4]
80005460:	e0 16 ff fc 	andl	r6,0xfffc
80005464:	ec c8 ff 91 	sub	r8,r6,-111
80005468:	f0 05 01 05 	sub	r5,r8,r5
8000546c:	e0 15 ff 80 	andl	r5,0xff80
80005470:	ea c5 00 80 	sub	r5,r5,128
80005474:	e0 45 00 7f 	cp.w	r5,127
80005478:	e0 8a 00 23 	brle	800054be <_malloc_trim_r+0x6e>
8000547c:	30 0b       	mov	r11,0
8000547e:	0e 9c       	mov	r12,r7
80005480:	fe b0 fd 0c 	rcall	80004e98 <_sbrk_r>
80005484:	68 28       	ld.w	r8,r4[0x8]
80005486:	0c 08       	add	r8,r6
80005488:	10 3c       	cp.w	r12,r8
8000548a:	c1 a1       	brne	800054be <_malloc_trim_r+0x6e>
8000548c:	ea 0b 11 00 	rsub	r11,r5,0
80005490:	0e 9c       	mov	r12,r7
80005492:	fe b0 fd 03 	rcall	80004e98 <_sbrk_r>
80005496:	5b fc       	cp.w	r12,-1
80005498:	c1 71       	brne	800054c6 <_malloc_trim_r+0x76>
8000549a:	30 0b       	mov	r11,0
8000549c:	0e 9c       	mov	r12,r7
8000549e:	fe b0 fc fd 	rcall	80004e98 <_sbrk_r>
800054a2:	68 28       	ld.w	r8,r4[0x8]
800054a4:	f8 08 01 09 	sub	r9,r12,r8
800054a8:	58 f9       	cp.w	r9,15
800054aa:	e0 8a 00 0a 	brle	800054be <_malloc_trim_r+0x6e>
800054ae:	a1 a9       	sbr	r9,0x0
800054b0:	91 19       	st.w	r8[0x4],r9
800054b2:	48 d8       	lddpc	r8,800054e4 <_malloc_trim_r+0x94>
800054b4:	70 09       	ld.w	r9,r8[0x0]
800054b6:	48 d8       	lddpc	r8,800054e8 <_malloc_trim_r+0x98>
800054b8:	f8 09 01 09 	sub	r9,r12,r9
800054bc:	91 09       	st.w	r8[0x0],r9
800054be:	0e 9c       	mov	r12,r7
800054c0:	fe b0 f7 02 	rcall	800042c4 <__malloc_unlock>
800054c4:	d8 2a       	popm	r4-r7,pc,r12=0
800054c6:	68 28       	ld.w	r8,r4[0x8]
800054c8:	0a 16       	sub	r6,r5
800054ca:	a1 a6       	sbr	r6,0x0
800054cc:	91 16       	st.w	r8[0x4],r6
800054ce:	48 78       	lddpc	r8,800054e8 <_malloc_trim_r+0x98>
800054d0:	70 09       	ld.w	r9,r8[0x0]
800054d2:	0a 19       	sub	r9,r5
800054d4:	0e 9c       	mov	r12,r7
800054d6:	91 09       	st.w	r8[0x0],r9
800054d8:	fe b0 f6 f6 	rcall	800042c4 <__malloc_unlock>
800054dc:	da 2a       	popm	r4-r7,pc,r12=1
800054de:	d7 03       	nop
800054e0:	00 00       	add	r0,r0
800054e2:	01 e4       	ld.ub	r4,r0[0x6]
800054e4:	00 00       	add	r0,r0
800054e6:	05 f0       	ld.ub	r0,r2[0x7]
800054e8:	00 00       	add	r0,r0
800054ea:	09 e4       	ld.ub	r4,r4[0x6]

800054ec <_free_r>:
800054ec:	d4 21       	pushm	r4-r7,lr
800054ee:	16 96       	mov	r6,r11
800054f0:	18 97       	mov	r7,r12
800054f2:	58 0b       	cp.w	r11,0
800054f4:	e0 80 00 c2 	breq	80005678 <_free_r+0x18c>
800054f8:	fe b0 f6 e0 	rcall	800042b8 <__malloc_lock>
800054fc:	20 86       	sub	r6,8
800054fe:	4c ba       	lddpc	r10,80005628 <_free_r+0x13c>
80005500:	6c 18       	ld.w	r8,r6[0x4]
80005502:	74 2e       	ld.w	lr,r10[0x8]
80005504:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005508:	a1 c8       	cbr	r8,0x0
8000550a:	ec 08 00 09 	add	r9,r6,r8
8000550e:	72 1b       	ld.w	r11,r9[0x4]
80005510:	e0 1b ff fc 	andl	r11,0xfffc
80005514:	1c 39       	cp.w	r9,lr
80005516:	c1 c1       	brne	8000554e <_free_r+0x62>
80005518:	f6 08 00 08 	add	r8,r11,r8
8000551c:	58 0c       	cp.w	r12,0
8000551e:	c0 81       	brne	8000552e <_free_r+0x42>
80005520:	6c 09       	ld.w	r9,r6[0x0]
80005522:	12 16       	sub	r6,r9
80005524:	12 08       	add	r8,r9
80005526:	6c 3b       	ld.w	r11,r6[0xc]
80005528:	6c 29       	ld.w	r9,r6[0x8]
8000552a:	97 29       	st.w	r11[0x8],r9
8000552c:	93 3b       	st.w	r9[0xc],r11
8000552e:	10 99       	mov	r9,r8
80005530:	95 26       	st.w	r10[0x8],r6
80005532:	a1 a9       	sbr	r9,0x0
80005534:	8d 19       	st.w	r6[0x4],r9
80005536:	4b e9       	lddpc	r9,8000562c <_free_r+0x140>
80005538:	72 09       	ld.w	r9,r9[0x0]
8000553a:	12 38       	cp.w	r8,r9
8000553c:	c0 53       	brcs	80005546 <_free_r+0x5a>
8000553e:	4b d8       	lddpc	r8,80005630 <_free_r+0x144>
80005540:	0e 9c       	mov	r12,r7
80005542:	70 0b       	ld.w	r11,r8[0x0]
80005544:	c8 6f       	rcall	80005450 <_malloc_trim_r>
80005546:	0e 9c       	mov	r12,r7
80005548:	fe b0 f6 be 	rcall	800042c4 <__malloc_unlock>
8000554c:	d8 22       	popm	r4-r7,pc
8000554e:	93 1b       	st.w	r9[0x4],r11
80005550:	58 0c       	cp.w	r12,0
80005552:	c0 30       	breq	80005558 <_free_r+0x6c>
80005554:	30 0c       	mov	r12,0
80005556:	c1 08       	rjmp	80005576 <_free_r+0x8a>
80005558:	6c 0e       	ld.w	lr,r6[0x0]
8000555a:	f4 c5 ff f8 	sub	r5,r10,-8
8000555e:	1c 16       	sub	r6,lr
80005560:	1c 08       	add	r8,lr
80005562:	6c 2e       	ld.w	lr,r6[0x8]
80005564:	0a 3e       	cp.w	lr,r5
80005566:	f9 bc 00 01 	moveq	r12,1
8000556a:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000556e:	eb fe 1a 02 	st.wne	r5[0x8],lr
80005572:	fd f5 1a 03 	st.wne	lr[0xc],r5
80005576:	f2 0b 00 0e 	add	lr,r9,r11
8000557a:	7c 1e       	ld.w	lr,lr[0x4]
8000557c:	ed be 00 00 	bld	lr,0x0
80005580:	c1 30       	breq	800055a6 <_free_r+0xba>
80005582:	16 08       	add	r8,r11
80005584:	58 0c       	cp.w	r12,0
80005586:	c0 c1       	brne	8000559e <_free_r+0xb2>
80005588:	4a 8e       	lddpc	lr,80005628 <_free_r+0x13c>
8000558a:	72 2b       	ld.w	r11,r9[0x8]
8000558c:	2f 8e       	sub	lr,-8
8000558e:	1c 3b       	cp.w	r11,lr
80005590:	c0 71       	brne	8000559e <_free_r+0xb2>
80005592:	97 36       	st.w	r11[0xc],r6
80005594:	97 26       	st.w	r11[0x8],r6
80005596:	8d 2b       	st.w	r6[0x8],r11
80005598:	8d 3b       	st.w	r6[0xc],r11
8000559a:	30 1c       	mov	r12,1
8000559c:	c0 58       	rjmp	800055a6 <_free_r+0xba>
8000559e:	72 2b       	ld.w	r11,r9[0x8]
800055a0:	72 39       	ld.w	r9,r9[0xc]
800055a2:	93 2b       	st.w	r9[0x8],r11
800055a4:	97 39       	st.w	r11[0xc],r9
800055a6:	10 99       	mov	r9,r8
800055a8:	ec 08 09 08 	st.w	r6[r8],r8
800055ac:	a1 a9       	sbr	r9,0x0
800055ae:	8d 19       	st.w	r6[0x4],r9
800055b0:	58 0c       	cp.w	r12,0
800055b2:	c6 01       	brne	80005672 <_free_r+0x186>
800055b4:	e0 48 01 ff 	cp.w	r8,511
800055b8:	e0 8b 00 13 	brhi	800055de <_free_r+0xf2>
800055bc:	a3 98       	lsr	r8,0x3
800055be:	f4 08 00 39 	add	r9,r10,r8<<0x3
800055c2:	72 2b       	ld.w	r11,r9[0x8]
800055c4:	8d 39       	st.w	r6[0xc],r9
800055c6:	8d 2b       	st.w	r6[0x8],r11
800055c8:	97 36       	st.w	r11[0xc],r6
800055ca:	93 26       	st.w	r9[0x8],r6
800055cc:	a3 48       	asr	r8,0x2
800055ce:	74 19       	ld.w	r9,r10[0x4]
800055d0:	30 1b       	mov	r11,1
800055d2:	f6 08 09 48 	lsl	r8,r11,r8
800055d6:	f3 e8 10 08 	or	r8,r9,r8
800055da:	95 18       	st.w	r10[0x4],r8
800055dc:	c4 b8       	rjmp	80005672 <_free_r+0x186>
800055de:	f0 0b 16 09 	lsr	r11,r8,0x9
800055e2:	58 4b       	cp.w	r11,4
800055e4:	e0 8b 00 06 	brhi	800055f0 <_free_r+0x104>
800055e8:	f0 0b 16 06 	lsr	r11,r8,0x6
800055ec:	2c 8b       	sub	r11,-56
800055ee:	c2 68       	rjmp	8000563a <_free_r+0x14e>
800055f0:	59 4b       	cp.w	r11,20
800055f2:	e0 8b 00 04 	brhi	800055fa <_free_r+0x10e>
800055f6:	2a 5b       	sub	r11,-91
800055f8:	c2 18       	rjmp	8000563a <_free_r+0x14e>
800055fa:	e0 4b 00 54 	cp.w	r11,84
800055fe:	e0 8b 00 06 	brhi	8000560a <_free_r+0x11e>
80005602:	f0 0b 16 0c 	lsr	r11,r8,0xc
80005606:	29 2b       	sub	r11,-110
80005608:	c1 98       	rjmp	8000563a <_free_r+0x14e>
8000560a:	e0 4b 01 54 	cp.w	r11,340
8000560e:	e0 8b 00 06 	brhi	8000561a <_free_r+0x12e>
80005612:	f0 0b 16 0f 	lsr	r11,r8,0xf
80005616:	28 9b       	sub	r11,-119
80005618:	c1 18       	rjmp	8000563a <_free_r+0x14e>
8000561a:	e0 4b 05 54 	cp.w	r11,1364
8000561e:	e0 88 00 0b 	brls	80005634 <_free_r+0x148>
80005622:	37 eb       	mov	r11,126
80005624:	c0 b8       	rjmp	8000563a <_free_r+0x14e>
80005626:	d7 03       	nop
80005628:	00 00       	add	r0,r0
8000562a:	01 e4       	ld.ub	r4,r0[0x6]
8000562c:	00 00       	add	r0,r0
8000562e:	05 ec       	ld.ub	r12,r2[0x6]
80005630:	00 00       	add	r0,r0
80005632:	09 e0       	ld.ub	r0,r4[0x6]
80005634:	f0 0b 16 12 	lsr	r11,r8,0x12
80005638:	28 4b       	sub	r11,-124
8000563a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000563e:	78 29       	ld.w	r9,r12[0x8]
80005640:	18 39       	cp.w	r9,r12
80005642:	c0 e1       	brne	8000565e <_free_r+0x172>
80005644:	74 18       	ld.w	r8,r10[0x4]
80005646:	a3 4b       	asr	r11,0x2
80005648:	30 1c       	mov	r12,1
8000564a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000564e:	f1 eb 10 0b 	or	r11,r8,r11
80005652:	12 98       	mov	r8,r9
80005654:	95 1b       	st.w	r10[0x4],r11
80005656:	c0 a8       	rjmp	8000566a <_free_r+0x17e>
80005658:	72 29       	ld.w	r9,r9[0x8]
8000565a:	18 39       	cp.w	r9,r12
8000565c:	c0 60       	breq	80005668 <_free_r+0x17c>
8000565e:	72 1a       	ld.w	r10,r9[0x4]
80005660:	e0 1a ff fc 	andl	r10,0xfffc
80005664:	14 38       	cp.w	r8,r10
80005666:	cf 93       	brcs	80005658 <_free_r+0x16c>
80005668:	72 38       	ld.w	r8,r9[0xc]
8000566a:	8d 38       	st.w	r6[0xc],r8
8000566c:	8d 29       	st.w	r6[0x8],r9
8000566e:	93 36       	st.w	r9[0xc],r6
80005670:	91 26       	st.w	r8[0x8],r6
80005672:	0e 9c       	mov	r12,r7
80005674:	fe b0 f6 28 	rcall	800042c4 <__malloc_unlock>
80005678:	d8 22       	popm	r4-r7,pc
8000567a:	d7 03       	nop

8000567c <_fwalk>:
8000567c:	d4 31       	pushm	r0-r7,lr
8000567e:	30 05       	mov	r5,0
80005680:	16 91       	mov	r1,r11
80005682:	f8 c7 ff 28 	sub	r7,r12,-216
80005686:	0a 92       	mov	r2,r5
80005688:	c4 2e       	rcall	8000530c <__sfp_lock_acquire>
8000568a:	3f f3       	mov	r3,-1
8000568c:	c1 68       	rjmp	800056b8 <_fwalk+0x3c>
8000568e:	6e 26       	ld.w	r6,r7[0x8]
80005690:	6e 14       	ld.w	r4,r7[0x4]
80005692:	2f 46       	sub	r6,-12
80005694:	c0 c8       	rjmp	800056ac <_fwalk+0x30>
80005696:	8c 08       	ld.sh	r8,r6[0x0]
80005698:	e4 08 19 00 	cp.h	r8,r2
8000569c:	c0 70       	breq	800056aa <_fwalk+0x2e>
8000569e:	8c 18       	ld.sh	r8,r6[0x2]
800056a0:	e6 08 19 00 	cp.h	r8,r3
800056a4:	c0 30       	breq	800056aa <_fwalk+0x2e>
800056a6:	5d 11       	icall	r1
800056a8:	18 45       	or	r5,r12
800056aa:	2a 46       	sub	r6,-92
800056ac:	20 14       	sub	r4,1
800056ae:	ec cc 00 0c 	sub	r12,r6,12
800056b2:	58 04       	cp.w	r4,0
800056b4:	cf 14       	brge	80005696 <_fwalk+0x1a>
800056b6:	6e 07       	ld.w	r7,r7[0x0]
800056b8:	58 07       	cp.w	r7,0
800056ba:	ce a1       	brne	8000568e <_fwalk+0x12>
800056bc:	c2 9e       	rcall	8000530e <__sfp_lock_release>
800056be:	0a 9c       	mov	r12,r5
800056c0:	d8 32       	popm	r0-r7,pc
800056c2:	d7 03       	nop

800056c4 <__sclose>:
800056c4:	d4 01       	pushm	lr
800056c6:	96 7b       	ld.sh	r11,r11[0xe]
800056c8:	c4 ac       	rcall	8000575c <_close_r>
800056ca:	d8 02       	popm	pc

800056cc <__sseek>:
800056cc:	d4 21       	pushm	r4-r7,lr
800056ce:	16 97       	mov	r7,r11
800056d0:	96 7b       	ld.sh	r11,r11[0xe]
800056d2:	cb 9c       	rcall	80005844 <_lseek_r>
800056d4:	8e 68       	ld.sh	r8,r7[0xc]
800056d6:	10 99       	mov	r9,r8
800056d8:	ad c8       	cbr	r8,0xc
800056da:	ad a9       	sbr	r9,0xc
800056dc:	5b fc       	cp.w	r12,-1
800056de:	ef f8 0c 06 	st.heq	r7[0xc],r8
800056e2:	ef f9 1c 06 	st.hne	r7[0xc],r9
800056e6:	ef fc 1a 15 	st.wne	r7[0x54],r12
800056ea:	d8 22       	popm	r4-r7,pc

800056ec <__swrite>:
800056ec:	d4 21       	pushm	r4-r7,lr
800056ee:	96 68       	ld.sh	r8,r11[0xc]
800056f0:	16 97       	mov	r7,r11
800056f2:	14 95       	mov	r5,r10
800056f4:	12 94       	mov	r4,r9
800056f6:	e2 18 01 00 	andl	r8,0x100,COH
800056fa:	18 96       	mov	r6,r12
800056fc:	c0 50       	breq	80005706 <__swrite+0x1a>
800056fe:	30 29       	mov	r9,2
80005700:	30 0a       	mov	r10,0
80005702:	96 7b       	ld.sh	r11,r11[0xe]
80005704:	ca 0c       	rcall	80005844 <_lseek_r>
80005706:	8e 68       	ld.sh	r8,r7[0xc]
80005708:	ad c8       	cbr	r8,0xc
8000570a:	08 99       	mov	r9,r4
8000570c:	0a 9a       	mov	r10,r5
8000570e:	8e 7b       	ld.sh	r11,r7[0xe]
80005710:	0c 9c       	mov	r12,r6
80005712:	ae 68       	st.h	r7[0xc],r8
80005714:	c1 0c       	rcall	80005734 <_write_r>
80005716:	d8 22       	popm	r4-r7,pc

80005718 <__sread>:
80005718:	d4 21       	pushm	r4-r7,lr
8000571a:	16 97       	mov	r7,r11
8000571c:	96 7b       	ld.sh	r11,r11[0xe]
8000571e:	ca 7c       	rcall	8000586c <_read_r>
80005720:	c0 65       	brlt	8000572c <__sread+0x14>
80005722:	6f 58       	ld.w	r8,r7[0x54]
80005724:	18 08       	add	r8,r12
80005726:	ef 48 00 54 	st.w	r7[84],r8
8000572a:	d8 22       	popm	r4-r7,pc
8000572c:	8e 68       	ld.sh	r8,r7[0xc]
8000572e:	ad c8       	cbr	r8,0xc
80005730:	ae 68       	st.h	r7[0xc],r8
80005732:	d8 22       	popm	r4-r7,pc

80005734 <_write_r>:
80005734:	d4 21       	pushm	r4-r7,lr
80005736:	16 98       	mov	r8,r11
80005738:	18 97       	mov	r7,r12
8000573a:	10 9c       	mov	r12,r8
8000573c:	30 08       	mov	r8,0
8000573e:	14 9b       	mov	r11,r10
80005740:	48 66       	lddpc	r6,80005758 <_write_r+0x24>
80005742:	12 9a       	mov	r10,r9
80005744:	8d 08       	st.w	r6[0x0],r8
80005746:	fe b0 f4 2d 	rcall	80003fa0 <_write>
8000574a:	5b fc       	cp.w	r12,-1
8000574c:	c0 51       	brne	80005756 <_write_r+0x22>
8000574e:	6c 08       	ld.w	r8,r6[0x0]
80005750:	58 08       	cp.w	r8,0
80005752:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005756:	d8 22       	popm	r4-r7,pc
80005758:	00 00       	add	r0,r0
8000575a:	0a 3c       	cp.w	r12,r5

8000575c <_close_r>:
8000575c:	d4 21       	pushm	r4-r7,lr
8000575e:	30 08       	mov	r8,0
80005760:	18 97       	mov	r7,r12
80005762:	48 76       	lddpc	r6,8000577c <_close_r+0x20>
80005764:	16 9c       	mov	r12,r11
80005766:	8d 08       	st.w	r6[0x0],r8
80005768:	fe b0 fc 52 	rcall	8000500c <_close>
8000576c:	5b fc       	cp.w	r12,-1
8000576e:	c0 51       	brne	80005778 <_close_r+0x1c>
80005770:	6c 08       	ld.w	r8,r6[0x0]
80005772:	58 08       	cp.w	r8,0
80005774:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005778:	d8 22       	popm	r4-r7,pc
8000577a:	d7 03       	nop
8000577c:	00 00       	add	r0,r0
8000577e:	0a 3c       	cp.w	r12,r5

80005780 <_fclose_r>:
80005780:	d4 21       	pushm	r4-r7,lr
80005782:	18 96       	mov	r6,r12
80005784:	16 97       	mov	r7,r11
80005786:	58 0b       	cp.w	r11,0
80005788:	c0 31       	brne	8000578e <_fclose_r+0xe>
8000578a:	16 95       	mov	r5,r11
8000578c:	c4 c8       	rjmp	80005824 <_fclose_r+0xa4>
8000578e:	fe b0 fd bf 	rcall	8000530c <__sfp_lock_acquire>
80005792:	58 06       	cp.w	r6,0
80005794:	c0 60       	breq	800057a0 <_fclose_r+0x20>
80005796:	6c 68       	ld.w	r8,r6[0x18]
80005798:	58 08       	cp.w	r8,0
8000579a:	c0 31       	brne	800057a0 <_fclose_r+0x20>
8000579c:	0c 9c       	mov	r12,r6
8000579e:	c0 be       	rcall	800053b4 <__sinit>
800057a0:	4a 28       	lddpc	r8,80005828 <_fclose_r+0xa8>
800057a2:	10 37       	cp.w	r7,r8
800057a4:	c0 31       	brne	800057aa <_fclose_r+0x2a>
800057a6:	6c 07       	ld.w	r7,r6[0x0]
800057a8:	c0 a8       	rjmp	800057bc <_fclose_r+0x3c>
800057aa:	4a 18       	lddpc	r8,8000582c <_fclose_r+0xac>
800057ac:	10 37       	cp.w	r7,r8
800057ae:	c0 31       	brne	800057b4 <_fclose_r+0x34>
800057b0:	6c 17       	ld.w	r7,r6[0x4]
800057b2:	c0 58       	rjmp	800057bc <_fclose_r+0x3c>
800057b4:	49 f8       	lddpc	r8,80005830 <_fclose_r+0xb0>
800057b6:	10 37       	cp.w	r7,r8
800057b8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800057bc:	8e 69       	ld.sh	r9,r7[0xc]
800057be:	30 08       	mov	r8,0
800057c0:	f0 09 19 00 	cp.h	r9,r8
800057c4:	c0 51       	brne	800057ce <_fclose_r+0x4e>
800057c6:	fe b0 fd a4 	rcall	8000530e <__sfp_lock_release>
800057ca:	30 05       	mov	r5,0
800057cc:	c2 c8       	rjmp	80005824 <_fclose_r+0xa4>
800057ce:	0e 9b       	mov	r11,r7
800057d0:	0c 9c       	mov	r12,r6
800057d2:	fe b0 fd 15 	rcall	800051fc <_fflush_r>
800057d6:	6e c8       	ld.w	r8,r7[0x30]
800057d8:	18 95       	mov	r5,r12
800057da:	58 08       	cp.w	r8,0
800057dc:	c0 60       	breq	800057e8 <_fclose_r+0x68>
800057de:	6e 8b       	ld.w	r11,r7[0x20]
800057e0:	0c 9c       	mov	r12,r6
800057e2:	5d 18       	icall	r8
800057e4:	f9 b5 05 ff 	movlt	r5,-1
800057e8:	8e 68       	ld.sh	r8,r7[0xc]
800057ea:	ed b8 00 07 	bld	r8,0x7
800057ee:	c0 41       	brne	800057f6 <_fclose_r+0x76>
800057f0:	6e 4b       	ld.w	r11,r7[0x10]
800057f2:	0c 9c       	mov	r12,r6
800057f4:	c7 ce       	rcall	800054ec <_free_r>
800057f6:	6e db       	ld.w	r11,r7[0x34]
800057f8:	58 0b       	cp.w	r11,0
800057fa:	c0 90       	breq	8000580c <_fclose_r+0x8c>
800057fc:	ee c8 ff bc 	sub	r8,r7,-68
80005800:	10 3b       	cp.w	r11,r8
80005802:	c0 30       	breq	80005808 <_fclose_r+0x88>
80005804:	0c 9c       	mov	r12,r6
80005806:	c7 3e       	rcall	800054ec <_free_r>
80005808:	30 08       	mov	r8,0
8000580a:	8f d8       	st.w	r7[0x34],r8
8000580c:	6f 2b       	ld.w	r11,r7[0x48]
8000580e:	58 0b       	cp.w	r11,0
80005810:	c0 60       	breq	8000581c <_fclose_r+0x9c>
80005812:	0c 9c       	mov	r12,r6
80005814:	c6 ce       	rcall	800054ec <_free_r>
80005816:	30 08       	mov	r8,0
80005818:	ef 48 00 48 	st.w	r7[72],r8
8000581c:	30 08       	mov	r8,0
8000581e:	ae 68       	st.h	r7[0xc],r8
80005820:	fe b0 fd 77 	rcall	8000530e <__sfp_lock_release>
80005824:	0a 9c       	mov	r12,r5
80005826:	d8 22       	popm	r4-r7,pc
80005828:	80 00       	ld.sh	r0,r0[0x0]
8000582a:	5d 1c       	icall	r12
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	5d 3c       	musfr	r12
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	5d 5c       	*unknown*

80005834 <fclose>:
80005834:	d4 01       	pushm	lr
80005836:	48 38       	lddpc	r8,80005840 <fclose+0xc>
80005838:	18 9b       	mov	r11,r12
8000583a:	70 0c       	ld.w	r12,r8[0x0]
8000583c:	ca 2f       	rcall	80005780 <_fclose_r>
8000583e:	d8 02       	popm	pc
80005840:	00 00       	add	r0,r0
80005842:	01 e0       	ld.ub	r0,r0[0x6]

80005844 <_lseek_r>:
80005844:	d4 21       	pushm	r4-r7,lr
80005846:	16 98       	mov	r8,r11
80005848:	18 97       	mov	r7,r12
8000584a:	10 9c       	mov	r12,r8
8000584c:	30 08       	mov	r8,0
8000584e:	14 9b       	mov	r11,r10
80005850:	48 66       	lddpc	r6,80005868 <_lseek_r+0x24>
80005852:	12 9a       	mov	r10,r9
80005854:	8d 08       	st.w	r6[0x0],r8
80005856:	fe b0 fb e7 	rcall	80005024 <_lseek>
8000585a:	5b fc       	cp.w	r12,-1
8000585c:	c0 51       	brne	80005866 <_lseek_r+0x22>
8000585e:	6c 08       	ld.w	r8,r6[0x0]
80005860:	58 08       	cp.w	r8,0
80005862:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005866:	d8 22       	popm	r4-r7,pc
80005868:	00 00       	add	r0,r0
8000586a:	0a 3c       	cp.w	r12,r5

8000586c <_read_r>:
8000586c:	d4 21       	pushm	r4-r7,lr
8000586e:	16 98       	mov	r8,r11
80005870:	18 97       	mov	r7,r12
80005872:	10 9c       	mov	r12,r8
80005874:	30 08       	mov	r8,0
80005876:	14 9b       	mov	r11,r10
80005878:	48 66       	lddpc	r6,80005890 <_read_r+0x24>
8000587a:	12 9a       	mov	r10,r9
8000587c:	8d 08       	st.w	r6[0x0],r8
8000587e:	fe b0 f3 03 	rcall	80003e84 <_read>
80005882:	5b fc       	cp.w	r12,-1
80005884:	c0 51       	brne	8000588e <_read_r+0x22>
80005886:	6c 08       	ld.w	r8,r6[0x0]
80005888:	58 08       	cp.w	r8,0
8000588a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000588e:	d8 22       	popm	r4-r7,pc
80005890:	00 00       	add	r0,r0
80005892:	0a 3c       	cp.w	r12,r5

80005894 <__do_global_ctors_aux>:
80005894:	d4 21       	pushm	r4-r7,lr
80005896:	48 57       	lddpc	r7,800058a8 <__do_global_ctors_aux+0x14>
80005898:	c0 28       	rjmp	8000589c <__do_global_ctors_aux+0x8>
8000589a:	5d 18       	icall	r8
8000589c:	20 47       	sub	r7,4
8000589e:	6e 08       	ld.w	r8,r7[0x0]
800058a0:	5b f8       	cp.w	r8,-1
800058a2:	cf c1       	brne	8000589a <__do_global_ctors_aux+0x6>
800058a4:	d8 22       	popm	r4-r7,pc
800058a6:	d7 03       	nop
800058a8:	00 00       	add	r0,r0
800058aa:	00 0c       	add	r12,r0

Disassembly of section .exception:

80005a00 <_evba>:
80005a00:	c0 08       	rjmp	80005a00 <_evba>
	...

80005a04 <_handle_TLB_Multiple_Hit>:
80005a04:	c0 08       	rjmp	80005a04 <_handle_TLB_Multiple_Hit>
	...

80005a08 <_handle_Bus_Error_Data_Fetch>:
80005a08:	c0 08       	rjmp	80005a08 <_handle_Bus_Error_Data_Fetch>
	...

80005a0c <_handle_Bus_Error_Instruction_Fetch>:
80005a0c:	c0 08       	rjmp	80005a0c <_handle_Bus_Error_Instruction_Fetch>
	...

80005a10 <_handle_NMI>:
80005a10:	c0 08       	rjmp	80005a10 <_handle_NMI>
	...

80005a14 <_handle_Instruction_Address>:
80005a14:	c0 08       	rjmp	80005a14 <_handle_Instruction_Address>
	...

80005a18 <_handle_ITLB_Protection>:
80005a18:	c0 08       	rjmp	80005a18 <_handle_ITLB_Protection>
	...

80005a1c <_handle_Breakpoint>:
80005a1c:	c0 08       	rjmp	80005a1c <_handle_Breakpoint>
	...

80005a20 <_handle_Illegal_Opcode>:
80005a20:	c0 08       	rjmp	80005a20 <_handle_Illegal_Opcode>
	...

80005a24 <_handle_Unimplemented_Instruction>:
80005a24:	c0 08       	rjmp	80005a24 <_handle_Unimplemented_Instruction>
	...

80005a28 <_handle_Privilege_Violation>:
80005a28:	c0 08       	rjmp	80005a28 <_handle_Privilege_Violation>
	...

80005a2c <_handle_Floating_Point>:
80005a2c:	c0 08       	rjmp	80005a2c <_handle_Floating_Point>
	...

80005a30 <_handle_Coprocessor_Absent>:
80005a30:	c0 08       	rjmp	80005a30 <_handle_Coprocessor_Absent>
	...

80005a34 <_handle_Data_Address_Read>:
80005a34:	c0 08       	rjmp	80005a34 <_handle_Data_Address_Read>
	...

80005a38 <_handle_Data_Address_Write>:
80005a38:	c0 08       	rjmp	80005a38 <_handle_Data_Address_Write>
	...

80005a3c <_handle_DTLB_Protection_Read>:
80005a3c:	c0 08       	rjmp	80005a3c <_handle_DTLB_Protection_Read>
	...

80005a40 <_handle_DTLB_Protection_Write>:
80005a40:	c0 08       	rjmp	80005a40 <_handle_DTLB_Protection_Write>
	...

80005a44 <_handle_DTLB_Modified>:
80005a44:	c0 08       	rjmp	80005a44 <_handle_DTLB_Modified>
	...

80005a50 <_handle_ITLB_Miss>:
80005a50:	c0 08       	rjmp	80005a50 <_handle_ITLB_Miss>
	...

80005a60 <_handle_DTLB_Miss_Read>:
80005a60:	c0 08       	rjmp	80005a60 <_handle_DTLB_Miss_Read>
	...

80005a70 <_handle_DTLB_Miss_Write>:
80005a70:	c0 08       	rjmp	80005a70 <_handle_DTLB_Miss_Write>
	...

80005b00 <_handle_Supervisor_Call>:
80005b00:	fe cf 19 90 	sub	pc,pc,6544

80005b04 <_int0>:
80005b04:	30 0c       	mov	r12,0
80005b06:	fe b0 e3 b5 	rcall	80002270 <_get_interrupt_handler>
80005b0a:	58 0c       	cp.w	r12,0
80005b0c:	f8 0f 17 10 	movne	pc,r12
80005b10:	d6 03       	rete

80005b12 <_int1>:
80005b12:	30 1c       	mov	r12,1
80005b14:	fe b0 e3 ae 	rcall	80002270 <_get_interrupt_handler>
80005b18:	58 0c       	cp.w	r12,0
80005b1a:	f8 0f 17 10 	movne	pc,r12
80005b1e:	d6 03       	rete

80005b20 <_int2>:
80005b20:	30 2c       	mov	r12,2
80005b22:	fe b0 e3 a7 	rcall	80002270 <_get_interrupt_handler>
80005b26:	58 0c       	cp.w	r12,0
80005b28:	f8 0f 17 10 	movne	pc,r12
80005b2c:	d6 03       	rete

80005b2e <_int3>:
80005b2e:	30 3c       	mov	r12,3
80005b30:	fe b0 e3 a0 	rcall	80002270 <_get_interrupt_handler>
80005b34:	58 0c       	cp.w	r12,0
80005b36:	f8 0f 17 10 	movne	pc,r12
80005b3a:	d6 03       	rete

80005b3c <ipr_val>:
80005b3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80005b4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005b5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005b6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005b7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005b8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005b9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005bac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005bbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005bcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005bdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005bec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005bfc:	d7 03 d7 03                                         ....

Disassembly of section .fini:

80005c00 <_fini>:
80005c00:	eb cd 40 40 	pushm	r6,lr
80005c04:	48 26       	lddpc	r6,80005c0c <_fini+0xc>
80005c06:	1e 26       	rsub	r6,pc
80005c08:	c0 48       	rjmp	80005c10 <_fini+0x10>
80005c0a:	d7 03       	nop
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	5b ea       	cp.w	r10,-2
80005c10:	fe b0 e2 3c 	rcall	80002088 <__do_global_dtors_aux>
80005c14:	e3 cd 80 40 	ldm	sp++,r6,pc
